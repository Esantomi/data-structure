# 운영체제

### 목차
- [1강. 운영체제 소개](#1강-운영체제-소개)
  - [운영체제란 무엇인가?](#운영체제란-무엇인가)
    - [커널](#커널)
  - [운영체제의 구성](#운영체제의-구성)
  - [운영체제의 유형](#운영체제의-유형)
- [2강. 프로세스와 쓰레드](#2강-프로세스와-쓰레드)
  - [프로세스](#프로세스)
  - [쓰레드](#쓰레드)

## 1강. 운영체제 소개
### 운영체제란 무엇인가?
- 컴퓨터 시스템의 구성
  - 하드웨어
    - CPU, 메모리, 저장장치, 입출력장치, 네트워크 장치 등
  - 소프트웨어  
    ![image](https://user-images.githubusercontent.com/61646760/220266879-64957689-4bd6-498c-97a3-1541577073fa.png)
    - **응용 소프트웨어(application software)** : 우리가 의식적으로 사용하는 소프트웨어들
    - **시스템 소프트웨어(system software)** : 응용 소프트웨어와 하드웨어 사이에서 매개체 역할을 수행(하드웨어 관리 역할이 주)
- **운영체제**
  - 대표적인 시스템 소프트웨어
  - 컴퓨터 시스템의 **자원을 관리**하고 컴퓨터 **프로그램이 동작하기 위한 서비스를 제공**하는 프로그램들의 모음
- 운영체제의 역할
  - **컴퓨터 시스템의 자원 관리**
    - 자원: 하드웨어 자원, 소프트웨어 자원, 데이터
      - `예) 저장장치에서 데이터 읽어 오기, 키보드나 마우스 제어, 프로그램 동시 실행 시 CPU와 메모리를 효율적으로 관리`
    - 컴퓨터 시스템을 **효율적으로 운영**하는 목적
  - **사용자 지원**
    - 사용자가 내린 명령을 해석하여 실행하게 함
    - 사용자와 하드웨어 사이의 매개체 역할
    - 사용자에게 편의성을 제공하는 목적
- 컴퓨터 시스템과 운영체제
  - **운영체제가 없던 초기의 컴퓨터 시스템**
    - **응용 프로그램이 직접 컴퓨터 시스템의 자원 제어**
      - 응용 프로그램 개발자는 하드웨어 제어방법을 잘 알아야 함
    - 여러 사용자가 하드웨어를 공유하는 경우 **자원 분할 어려움**  
      ![image](https://user-images.githubusercontent.com/61646760/220268778-a0e5fd42-253d-4377-8458-273c8e1e67a1.png)
      - 각각의 응용 프로그램이 독립적으로 동작하는 경우, **개별 응용 프로그램은 자신이 사용할 자원에 대해서만 제어를 수행하므로 충돌 가능성**이 있음
      - 가령 두 프로그램이 하드웨어의 특정 자원을 동시에 이용하려 한다면 문제가 발생할 수 있음
  - **운영체제가 있는 컴퓨터 시스템**
    - 하드웨어와 응용 프로그램 사이에 운영체제 위치
    - 운영체제가 컴퓨터 시스템의 자원 제어
    - 컴퓨터 시스템이 안정적이고 효율적으로 동작하도록 함  
      ![image](https://user-images.githubusercontent.com/61646760/220269643-9026b470-573f-4686-bde4-e2f0d19d1bbc.png)
      - 각각의 응용 프로그램이 독립적으로 동작하더라도, **운영체제가 중간에서** (순서 조정과 같은 방법으로) 사용할 자원의 중복이 없게끔 하는 등 **자원을 제어**해 줌
#### 커널
- **커널(kernel)**
  - 커널 모드에서 동작하는 **운영체제의 핵심 요소**
    - 응용 프로그램과 하드웨어 수준의 처리 사이의 가교 역할
  - 운영체제=커널?
    - 커널 구성 방식에 따라 다름
  - 구성 방식 : 일체형 커널, 마이크로커널
- **일체형 커널(monolithic kernel)**
  - 운영체제의 모든 서비스가 커널 내에 포함됨
    - 이 경우 **운영체제=커널**
  - 장점
    - 커널 내부 요소들이 서로 **효율적으로 상호작용**을 함
  - 단점
    - 한 요소라도 오류가 발생하면 시스템 전체에 장애 발생 가능
  - `예) UNIX, Linux`
- **마이크로커널(microkernel)**
  - 운영체제 요소의 대부분을 **커널 외부로 분리**
    - 운영체제의 기본적인 요소들만 남긴 채 커널 최소화
    - 메모리 관리, 멀티태스킹, 프로세스 간 통신(IPC) 등 **최소한의 요소만 커널 내**에 남김
  - 장점
    - 새로운 서비스를 추가하여 **운영체제를 확장하기 쉬움**
    - 유지보수가 용이하여 **안정성이 우수**함
  - 단점
    - 커널 외부 요소들 사이는 IPC(Inter-Process Communication)가 필요하여 **성능저하 발생**
- 커널 모드와 사용자 모드
  - **커널 모드(슈퍼바이저 모드)**
    - 하드웨어를 직접 제어할 수 있는 CPU 명령어를 사용할 수 있는 모드
    - 운영체제의 커널이 동작함  
      ![image](https://user-images.githubusercontent.com/61646760/220271469-786be568-8254-403f-9d56-52d540d4b40b.png)
  - **사용자 모드(보호 모드)**
    - 하드웨어를 직접 제어할 수 있는 CPU 명령어를 사용할 수 없는 모드
    - 응용 프로그램이 동작함  
      ![image](https://user-images.githubusercontent.com/61646760/220271678-4d6fd63e-f6ab-4bb8-bad0-5479675e48d9.png)
- **시스템 호출(system call)**
  - 응용 프로그램이 **하드웨어에 대한 제어가 필요한 경우** 이용
  - **운영체제에 서비스를 요청**하는 메커니즘  
    ![image](https://user-images.githubusercontent.com/61646760/220274541-664a6df0-633d-4728-a41b-1f38ad262111.png)
    - 시스템 호출을 통해 운영체제에게 하드웨어를 건드리고 싶다(하드웨어의 자원을 사용하고 싶다)고 요청하면, 사용자 모드에서 응용 프로그램이 동작하다가 그 순간 **커널 모드로 전환**됨
    - 시스템 호출에 맞춰 운영체제가 하드웨어를 제어하고 처리해 줌
    - 시스템 호출의 요구를 만족시키면 다시 응용 프로그램에 제어를 넘겨 주고, **커널 모드에서 사용자 모드로 전환**됨
### 운영체제의 구성
- 컴퓨터 시스템의 자원의 성격에 따라 구분  
  ![image](https://user-images.githubusercontent.com/61646760/220275829-ac04aa25-c6ee-4a61-81d2-24c7d4790ab5.png)
- **프로세스 관리자**
  - 프로세스의 생성 및 삭제
  - CPU 할당을 위한 스케줄 결정
  - 프로세스의 상태를 관리하며 상태 전이 처리  
    ![image](https://user-images.githubusercontent.com/61646760/220276168-5f9a21c2-8942-4e7d-a171-021c788866d9.png)
    - 저장 장치에 파일 형태로 들어 있는 **프로그램**을 메모리에 올려 실행시키면 **프로세스**가 됨
    - 프로세스 속 여러 명령어를 실행시키는 역할은 CPU가 하므로, **프로세스는 CPU를 할당받아 작업을 처리**해야 하며, 이 과정에 스케줄링이 필요함
  - 2강부터 상세히 설명
- **메모리 관리자**
  - 메모리(주기억장치) 공간에 대한 요구의 유효성 확인
  - 메모리 할당 및 회수
  - 메모리 공간 보호  
    ![image](https://user-images.githubusercontent.com/61646760/220285509-acb72a6d-6fa2-483b-be05-48f6f9fc8a80.png)
    - 메모리의 특정 영역을 브라우저라는 프로세스에게 할당
    - 문서편집기를 실행할 때 브라우저가 이미 할당받아 사용 중인 공간과 겹친다면 유효성을 확인하여 겹치지 않는 메모리 공간을 문서편집기에 할당
    - 운영체제 혹은 **커널도 시스템 프로세스로서 메모리 공간을 할당받아 사용**함
  - 8강부터 상세히 설명
- **장치 관리자**
  - 컴퓨터 시스템의 모든 장치 관리
  - 시스템 장치의 할당, 작동, 반환  
    ![image](https://user-images.githubusercontent.com/61646760/220286249-d432915a-283d-43a0-84a6-fba00e57977e.png)
  - 11강-12강에서 상세히 설명
- **파일 관리자**
  - 컴퓨터 시스템의 모든 파일 관리
  - 저장장치의 공간 관리
  - 파일의 접근 제한 관리  
    ![image](https://user-images.githubusercontent.com/61646760/220286404-b35abe38-01dc-497d-afd5-52a5bc33945f.png)
  - 12강에서 상세히 설명
### 운영체제의 유형
- 대표적인 4가지 유형
  - 일괄처리 운영체제
  - 시분할 운영체제
  - 실시간 운영체제
  - 분산 운영체제
- **일괄처리 운영체제(Batch processing)**
  - 작업을 모아서 **순서대로 처리**하는 방식
  - 사람(오퍼레이터)이 하던 일을 프로그램이 빠르게 처리하게 되면서 전체적인 작업 처리 속도가 향상됨
    - 운영체제가 없던 시절, 작업 처리를 위해서는 사람(오퍼레이터)이 직접 처리할 것을 하나하나 넣고 빼야 했음
  - 나중에 들어온 작업은 **앞선 작업들이 모두 끝날 때까지** 아무런 상호작용 없이 기다려야만 함
- **시분할 운영체제(Time-sharing)**
  - 각 사용자의 프로그램을 **한 번에 조금씩 수행**하는 방식
  - 대화형(interactive) 운영체제라고도 함
  - 사용자들은 마치 혼자 컴퓨터를 사용하는 듯한 느낌을 받음
  - 응답시간이 일괄처리 운영체제보다 크게 단축됨 (앞의 작업이 모두 끝나길 기다릴 필요가 없으므로)
    - **응답시간** : 요청한 시점부터 반응이 시작되는 시점까지의 소요시간
- **실시간 운영체제(Real-time), RTOS**
  - 원하는 시간 내에 프로그램의 결과를 얻을 수 있는 방식
  - 처리 결과가 현재의 결정에 영향을 주는 환경에서 사용됨
    - `예) 미사일 제어 시스템, 증권거래 관리 시스템 등`
  - 중요한 작업에 대한 **처리 기한을 맞추는 것이 중요**
    - **우선순위가 높은 작업을 우선 처리**할 수 있는 기법 활용
- **분산 운영체제**
  - 분산 시스템을 관리하기 위한 운영체제
    - **분산 시스템** : 2개 이상의 컴퓨터 시스템이 네트워크로 서로 연결되어 서로의 자원을 이용하는 시스템
  - 다른 컴퓨터 시스템의 자원을 이용하는 것이 **마치 자신의 컴퓨터 시스템에 있는 자원을 이용하는 것처럼 가능**해야 함
  - 13강에서 상세히 설명
### 1강 정리하기
- **운영체제**는 컴퓨터 시스템의 자원을 관리하고 컴퓨터 프로그램이 동작하기 위한 서비스를 제공하는 프로그램들의 모습으로 대표적인 시스템 소프트웨어이다.
- **커널 모드**는 하드웨어를 직접 제어할 수 있는 CPU의 명령어를 사용할 수 있는 모드이고, **사용자 모드**는 하드웨어를 직접 제어할 수 있는 CPU의 명령어를 사용할 수 없는 모드이다.
- 응용 프로그램은 사용자 모드에서 동작하기에, 하드웨어에 대한 제어가 필요한 경우 **시스템 호출**을 통해 필요한 서비스를 운영체제에 요청해야 한다.
- 운영체제의 주요 구성요소에는 **프로세스 관리자**, **메모리 관리자**, **장치 관리자**, **파일 관리자**가 있다.
- 운영체제의 대표적인 유형으로는 **일괄처리 운영체제**, **시분할 운영체제**, **실시간 운영체제**, **분산 운영체제**가 있다.

## 2강. 프로세스와 쓰레드
### 프로세스
- **프로세스(process)**
  - 실행 중인 프로그램
    - 프로세스 관리를 위해 운영체제가 각각의 프로세스에 '**PID(Process ID)**'를 부여함
      - 동명의 프로그램을 여러 개 실행하면 프로세스 이름이 중복되므로 각각 ID를 부여하여 구분할 필요가 있음
    - 프로세스는 **그 프로그램 사이즈보다 큼** (작업을 진행하며 데이터가 추가되는 등)
  - 프로그램? 프로세스?
    - **프로그램(program)** : 동작을 하지 않는 정적·수동적 개체
    - **프로세스(process)** : 동작을 하는 능동적 개체
      - 즉, 정적인 프로그램을 동적인 프로세스로 실행시키는 것  
  - 운영체제로부터 **자원을 할당받아 동작**
    - 자원 : CPU, 메모리, 입출력 장치, 파일 등
    - 동작 : **CPU가 프로세스의 명령을 실행** (**프로그램을 메모리에 올리고, 실행할 코드의 메모리 주소를 CPU 레지스터로 올림**)
  - 작업 관리자로 프로세스 확인 가능  
    ![image](https://user-images.githubusercontent.com/61646760/221199655-e571ae55-07de-4773-877a-d4628d8b331b.png)
- 운영체제(프로세스 관리자)가 처리하는 작업
  - 프로세스를 생성 및 종료
  - 프로세스를 실행시키기 위한 스케줄링 작업
  - 프로세스의 상태 관리
- 프로세스의 구성
  - **프로세스 메모리 구조(Process Memory Layout)**
    - 프로그램 실행에 직접적으로 필요한 코드와 데이터  
      ![image](https://user-images.githubusercontent.com/61646760/221203460-928fd26f-0967-484b-854e-103082834890.png)
      - **코드 영역(code area)**
        - 저장 장치에 파일 형태로 있던 프로그램이 메모리상의 코드 영역으로 올라온 것
      - **데이터 영역(data area)**
        - 코드 영역의 프로그램을 실행할 때 필요한 데이터를 저장
        - 데이터 영역의 세분화
          - **정적 데이터 영역(static data area)** : 상수나 전역 변수 등 프로그램 끝까지 유지되는 데이터
          - **스택 영역(stack area)** : 서브프로그램 호출에 필요한 지역 변수 등
          - **힙 영역(heap area)** : 사용자가 수동으로 할당한 변수들
        - 참고 : [메모리의 구조 - 코딩의 시작, TCP School](http://www.tcpschool.com/c/c_memory_structure)
  - **프로세스 제어 블록(PCB: Process Control Block)**
    - 운영체제가 **프로세스를 관리하기 위해 필요한 정보** 보유
      - PCB에 저장된 정보 중 대표적인 것으로 아래를 들 수 있음  
        ![image](https://user-images.githubusercontent.com/61646760/221206345-dae10646-0d50-4108-bf5d-2ce75707f6d3.png)
        - 프로세스 번호(PID)
        - 프로세스 상태 : 실행, 대기 등
        - 프로그램 카운터(PC) : 현재 실행 중인 명령어의 다음 명령어 위치 값을 가짐 (즉 제어의 흐름을 볼 수 있음)
        - 레지스터 : 작업이 미완이지만 할당받은 CPU를 다른 프로세스에 넘겨 줘야 하는 경우, 현재 상태의 레지스터 값들을 PCB에 저장했다가 이후 다시 CPU를 할당받아 복구함
        - 메모리 관리 정보
        - 프로세스 우선순위
    - 각 프로세스마다 존재
      - 개별 프로세스마다 PID 등의 프로세스 정보가 다름
    - **여러 프로세스가 번갈아 실행되는 경우 PCB에 저장된 정보 활용**
      - CPU를 여러 프로세스가 번갈아 쓰는 경우, 레지스터 정보가 필요하므로 이를 PCB에 저장
- 프로세스 상태 관리
  - **프로세스 상태(process state)**  
    ![image](https://user-images.githubusercontent.com/61646760/221208776-654fb60b-5df5-4f34-8f9f-57003f2a4365.png)
    - **생성(New)** : 프로그램을 메모리상에 올려 프로세스(즉 메모리 구조, PCB) 생성
    - **준비(Ready)** : 메모리 구조, PCB 모두 메모리상에 생성하여 필요한 정보는 모두 올라간 상태 (준비 큐에 프로세스에 들어간 상태)
    - **실행(Running)** : CPU가 할당되어 프로세스의 명령어 처리
    - **대기(Waiting)** : 특정 이벤트 발생으로 CPU가 노는 경우 CPU를 다른 프로세스에 양보하고 대기
    - **종료(Terminated)** : 프로세스 종료
  - 프로세스 상태 변화  
    ![image](https://user-images.githubusercontent.com/61646760/221208850-cb1394b9-740f-4894-a00e-b969c5a1e6d6.png)
    - **Dispatch** (ready -> running) : 특정 프로세스에 CPU를 할당해 주는 과정 자체
    - **Interrupt** (running -> ready)
      - 스케줄링에 따라 주어진 시간을 다 소모했는데도 작업이 미완인 경우
      - 우선순위가 더 높은 프로세스가 준비 큐에 들어와서 점유 중인 CPU를 디스패치해 줘야 하는 경우
    - **Block** (running -> waiting) : 입출력, 페이지 변환 같은 이벤트가 발생하여 CPU를 사용할 수 없으면 그동안 CPU를 다른 프로세스에 양보
    - **Wakeup** (waiting -> ready) : 다시 실행 가능한 상황이 되었을 때 준비 큐에 프로세스 적재
- 프로세스 생성 방법
  1. 사용자가 프로그램을 직접 실행
  2. 한 프로세스가 다른 프로세스를 생성
      - 프로세스 생성 [시스템 호출(system call)](#커널) 이용
      - **부모 프로세스(parent process)** : 시스템 호출을 하는 프로세스
      - **자식 프로세스(child process)** : 시스템 호출을 통해 새로 생성된 프로세스
- 프로세스 생성 시스템 호출
  - UNIX, LINUX : `fork()`
    - 자식 프로세스는 부모 프로세스의 복제본  
      ![image](https://user-images.githubusercontent.com/61646760/222679780-abeb8f9a-d3f4-4e4c-b066-f8b171daf099.png)
      - 기존의 프로세스(PID=10)의 PC가 가리키는 곳에 `fork()` 명령어가 있으므로 CPU에서 해당 명령어를 처리함
      - `fork()`라는 시스템 호출을 통해 OS가 기존 프로세스의 복제본(코드 영역, 데이터 영역 동일)인 자식 프로세스(PID=25)를 생성함
      - 부모 프로세스는 `fork()`의 결괏값으로 자식의 PID=25를 받고, 자식 프로세스는 `fork()`의 결괏값으로 0을 받음 (결괏값으로 자식/부모 구분 가능)
  - UNIX, LINUX : `exec()`
    - 자식 프로세스는 부모 프로세스와는 다른 프로그램 실행 (자식 프로세스에게 다른 작업을 수행시킬 때 사용)  
      ![image](https://user-images.githubusercontent.com/61646760/222681126-f21979bc-5195-4c1d-ae69-c994591be008.png)
      - 자식 프로세스(PID=25) `fork()` 명령어 다음, PID가 0이라면(=자식 프로세스라면) prg2라는 새로운 프로그램을 실행시킴
      - 코드 영역과 데이터 영역이 prg2 관련으로 바뀌고 PCB 내용도 PID를 제외하고 prg2에 맞춰 변경됨
  - Windows : `CreateProcess()`
    - 자식 프로세스는 새로운 프로그램으로 생성  
      ![image](https://user-images.githubusercontent.com/61646760/222683096-0b5f0494-7427-48ce-b2eb-006026dd0153.png)
      - 특정 프로세스(PID=10)가 prg2 프로그램을 생성하기 위해 `CreateProcess()`로 여러 인자 값을 받아옴
      - 생성된 자식 프로세스(PID=25)는 처음부터 prg2에 대한 내용으로 코드 영역, 데이터 영역, PCB가 채워짐
- 프로세스 종료 방법
  1. 프로세스가 모든 처리를 완료(정상적 종료)
  2. 부모 프로세스에 의해 자식 프로세스가 강제 종료
      - 프로세스 종료 시스템 호출 이용
      - 자식 프로세스 생성시 얻은 자식 PID 이용
  3. 부모 프로세스가 종료되는 경우 운영체제가 자식 프로세스 종료
### 쓰레드
- 전통적인 프로세스
  - 프로세스는 하나의 프로그램을 실행하기 위한 기본적인 단위  
    ![image](https://user-images.githubusercontent.com/61646760/222689538-82817ad7-6bd7-4fc9-8d03-0db34f690d20.png)
  - 프로세스는 두 가지 단위로 볼 수 있음
    - 자원 소유의 단위
      - 하나의 메모리 구조 : 하나의 메모리 구조 안에 필요한 메모리 자원들을 할당받고 있으므로 프로세스가 자원 소유의 단위가 됨
    - 디스패칭의 단위
      - 하나의 제어흐름 : 프로세스는 하나의 제어흐름만 가짐(코드 영역에서 현재 처리되고 있는 지점이 어디인지를 가리키는 PC가 1개만 존재)
  - 프로세스 내에서 다중처리 불가능
    - 쓰레드 도입!
- **쓰레드(thread)**
  - **프로세스 내에서 다중처리**를 위해 제안된 개념
    - 프로세스 안에 PC가 여러 개 존재할 수 있다는 의미
  - (요즘 OS를 사용하는 방식에서는) 쓰레드가 하나의 프로그램을 실행하기 위한 기본적인 단위 
  - 쓰레드는 **디스패칭의 단위**가 됨
    - 즉 쓰레드별로 디스패칭받음
    - cf) 자원 소유의 단위는 여전히 프로세스 (**프로세스는 하나의 메모리 구조를 가지나 디스패칭은 쓰레드별로 이루어짐**)
  - 하나의 프로세스 내에는 하나 이상의 쓰레드 존재  
    ![image](https://user-images.githubusercontent.com/61646760/222690928-79f04f09-4619-4278-8251-6f1e88e18fb2.png)
    - 프로그램 카운터(PC)는 PCB가 아닌 쓰레드별로 존재
    - 각각의 쓰레드는 CPU를 할당받아(=디스패칭) 코드 영역의 다른 지점 명령어를 처리
- 프로세스 비교
  - 전통적인 프로세스 : 하나의 PC로 디스패칭  
    ![image](https://user-images.githubusercontent.com/61646760/222692411-91e5d553-f504-481f-8df1-9faa39088046.png)
  - 쓰레드 있는 프로세스 : 프로세스 안에 별도로 쓰레드를 가지며, 쓰레드가 PC를 가짐 (쓰레드마다 디스패칭을 따로 수행)  
    ![image](https://user-images.githubusercontent.com/61646760/222692463-c05dca1c-868c-463c-b730-35b05c5fb2d2.png)
- 쓰레드와 프로세스  
  ![image](https://user-images.githubusercontent.com/61646760/222698358-299c79e8-8666-4415-9336-dacb4a4f7468.png)
  - 쓰레드는 실행에 필요한 최소한의 정보만 가짐
    - PC를 포함한 레지스터 값 : 레지스터 값은 CPU 처리에 필요한데, 각각의 쓰레드가 다른 명령어를 수행한다면 레지스터 값이 달라지므로, 쓰레드마다 레지스터 값을 가짐
    - 상태 정보 : 쓰레드마다 별도 관리
    - 스택 영역 : 쓰레드마다 별도 관리
  - 나머지 정보는 프로세스에 두고 다른 쓰레드와 공유
- 다중 쓰레드로 구성된 프로세스
  - **멀티 CPU** 또는 **멀티코어 컴퓨터 시스템**
    - 다중 쓰레드를 병렬로 처리 가능  
      ![image](https://user-images.githubusercontent.com/61646760/222699584-4fa87764-ac70-404c-a423-4423b79fd7b4.png)
      - t_1은 CPU1에게, t_2는 CPU2에게, t_3는 CPU3에게 할당하면, 3개 쓰레드를 통한 병렬처리가 가능함
      - CPU가 1개면 쓰레드가 여럿이어도 CPU는 한번에 하나에만 할당됨
  - 처리 속도별로 쓰레드가 나눠진 경우
    - 효율적인 처리 가능  
      ![image](https://user-images.githubusercontent.com/61646760/222699644-13360425-e0d6-448c-9d0d-2913969201a3.png)
      - CPU가 1개여도 계산용, 입력용, 백업용 등과 같이 쓰레드가 용도별로 구분되어 있다면 대부분은 계산용 쓰레드에 CPU가 할당되어 효율적이게 됨
