# 운영체제

### 목차
- [1강. 운영체제 소개](#1강-운영체제-소개)
  - [운영체제란 무엇인가?](#운영체제란-무엇인가)
    - [커널](#커널)
  - [운영체제의 구성](#운영체제의-구성)
  - [운영체제의 유형](#운영체제의-유형)
- [2강. 프로세스와 쓰레드](#2강-프로세스와-쓰레드)
  - [프로세스](#프로세스)
  - [쓰레드](#쓰레드)
- [3강. 프로세스 스케줄링](#3강-프로세스-스케줄링)
  - [프로세스 스케줄링](#프로세스-스케줄링)
  - [스케줄링 알고리즘](#프로세스-알고리즘)
    - [FCFS](#FCFS)
    - [SJF](#SJF)
    - [SRT](#SRT)
    - [RR](#RR)
    - [HRN](#HRN)
    - [다단계 피드백 큐](#다단계-피드백-큐)

## 1강. 운영체제 소개
### 운영체제란 무엇인가?
- 컴퓨터 시스템의 구성
  - 하드웨어
    - CPU, 메모리, 저장장치, 입출력장치, 네트워크 장치 등
  - 소프트웨어  
    ![image](https://user-images.githubusercontent.com/61646760/220266879-64957689-4bd6-498c-97a3-1541577073fa.png)
    - **응용 소프트웨어(application software)** : 우리가 의식적으로 사용하는 소프트웨어들
    - **시스템 소프트웨어(system software)** : 응용 소프트웨어와 하드웨어 사이에서 매개체 역할을 수행(하드웨어 관리 역할이 주)
- **운영체제**
  - 대표적인 시스템 소프트웨어
  - 컴퓨터 시스템의 **자원을 관리**하고 컴퓨터 **프로그램이 동작하기 위한 서비스를 제공**하는 프로그램들의 모음
- 운영체제의 역할
  - **컴퓨터 시스템의 자원 관리**
    - 자원: 하드웨어 자원, 소프트웨어 자원, 데이터
      - `예) 저장장치에서 데이터 읽어 오기, 키보드나 마우스 제어, 프로그램 동시 실행 시 CPU와 메모리를 효율적으로 관리`
    - 컴퓨터 시스템을 **효율적으로 운영**하는 목적
  - **사용자 지원**
    - 사용자가 내린 명령을 해석하여 실행하게 함
    - 사용자와 하드웨어 사이의 매개체 역할
    - 사용자에게 편의성을 제공하는 목적
- 컴퓨터 시스템과 운영체제
  - **운영체제가 없던 초기의 컴퓨터 시스템**
    - **응용 프로그램이 직접 컴퓨터 시스템의 자원 제어**
      - 응용 프로그램 개발자는 하드웨어 제어방법을 잘 알아야 함
    - 여러 사용자가 하드웨어를 공유하는 경우 **자원 분할 어려움**  
      ![image](https://user-images.githubusercontent.com/61646760/220268778-a0e5fd42-253d-4377-8458-273c8e1e67a1.png)
      - 각각의 응용 프로그램이 독립적으로 동작하는 경우, **개별 응용 프로그램은 자신이 사용할 자원에 대해서만 제어를 수행하므로 충돌 가능성**이 있음
      - 가령 두 프로그램이 하드웨어의 특정 자원을 동시에 이용하려 한다면 문제가 발생할 수 있음
  - **운영체제가 있는 컴퓨터 시스템**
    - 하드웨어와 응용 프로그램 사이에 운영체제 위치
    - 운영체제가 컴퓨터 시스템의 자원 제어
    - 컴퓨터 시스템이 안정적이고 효율적으로 동작하도록 함  
      ![image](https://user-images.githubusercontent.com/61646760/220269643-9026b470-573f-4686-bde4-e2f0d19d1bbc.png)
      - 각각의 응용 프로그램이 독립적으로 동작하더라도, **운영체제가 중간에서** (순서 조정과 같은 방법으로) 사용할 자원의 중복이 없게끔 하는 등 **자원을 제어**해 줌
#### 커널
- **커널(kernel)**
  - 커널 모드에서 동작하는 **운영체제의 핵심 요소**
    - 응용 프로그램과 하드웨어 수준의 처리 사이의 가교 역할
  - 운영체제=커널?
    - 커널 구성 방식에 따라 다름
  - 구성 방식 : 일체형 커널, 마이크로커널
- **일체형 커널(monolithic kernel)**
  - 운영체제의 모든 서비스가 커널 내에 포함됨
    - 이 경우 **운영체제=커널**
  - 장점
    - 커널 내부 요소들이 서로 **효율적으로 상호작용**을 함
  - 단점
    - 한 요소라도 오류가 발생하면 시스템 전체에 장애 발생 가능
  - `예) UNIX, Linux`
- **마이크로커널(microkernel)**
  - 운영체제 요소의 대부분을 **커널 외부로 분리**
    - 운영체제의 기본적인 요소들만 남긴 채 커널 최소화
    - 메모리 관리, 멀티태스킹, 프로세스 간 통신(IPC) 등 **최소한의 요소만 커널 내**에 남김
  - 장점
    - 새로운 서비스를 추가하여 **운영체제를 확장하기 쉬움**
    - 유지보수가 용이하여 **안정성이 우수**함
  - 단점
    - 커널 외부 요소들 사이는 IPC(Inter-Process Communication)가 필요하여 **성능저하 발생**
- 커널 모드와 사용자 모드
  - **커널 모드(슈퍼바이저 모드)**
    - 하드웨어를 직접 제어할 수 있는 CPU 명령어를 사용할 수 있는 모드
    - 운영체제의 커널이 동작함  
      ![image](https://user-images.githubusercontent.com/61646760/220271469-786be568-8254-403f-9d56-52d540d4b40b.png)
  - **사용자 모드(보호 모드)**
    - 하드웨어를 직접 제어할 수 있는 CPU 명령어를 사용할 수 없는 모드
    - 응용 프로그램이 동작함  
      ![image](https://user-images.githubusercontent.com/61646760/220271678-4d6fd63e-f6ab-4bb8-bad0-5479675e48d9.png)
- **시스템 호출(system call)**
  - 응용 프로그램이 **하드웨어에 대한 제어가 필요한 경우** 이용
  - **운영체제에 서비스를 요청**하는 메커니즘  
    ![image](https://user-images.githubusercontent.com/61646760/220274541-664a6df0-633d-4728-a41b-1f38ad262111.png)
    - 시스템 호출을 통해 운영체제에게 하드웨어를 건드리고 싶다(하드웨어의 자원을 사용하고 싶다)고 요청하면, 사용자 모드에서 응용 프로그램이 동작하다가 그 순간 **커널 모드로 전환**됨
    - 시스템 호출에 맞춰 운영체제가 하드웨어를 제어하고 처리해 줌
    - 시스템 호출의 요구를 만족시키면 다시 응용 프로그램에 제어를 넘겨 주고, **커널 모드에서 사용자 모드로 전환**됨
### 운영체제의 구성
- 컴퓨터 시스템의 자원의 성격에 따라 구분  
  ![image](https://user-images.githubusercontent.com/61646760/220275829-ac04aa25-c6ee-4a61-81d2-24c7d4790ab5.png)
- **프로세스 관리자**
  - 프로세스의 생성 및 삭제
  - CPU 할당을 위한 스케줄 결정
  - 프로세스의 상태를 관리하며 상태 전이 처리  
    ![image](https://user-images.githubusercontent.com/61646760/220276168-5f9a21c2-8942-4e7d-a171-021c788866d9.png)
    - 저장 장치에 파일 형태로 들어 있는 **프로그램**을 메모리에 올려 실행시키면 **프로세스**가 됨
    - 프로세스 속 여러 명령어를 실행시키는 역할은 CPU가 하므로, **프로세스는 CPU를 할당받아 작업을 처리**해야 하며, 이 과정에 스케줄링이 필요함
  - 2강부터 상세히 설명
- **메모리 관리자**
  - 메모리(주기억장치) 공간에 대한 요구의 유효성 확인
  - 메모리 할당 및 회수
  - 메모리 공간 보호  
    ![image](https://user-images.githubusercontent.com/61646760/220285509-acb72a6d-6fa2-483b-be05-48f6f9fc8a80.png)
    - 메모리의 특정 영역을 브라우저라는 프로세스에게 할당
    - 문서편집기를 실행할 때 브라우저가 이미 할당받아 사용 중인 공간과 겹친다면 유효성을 확인하여 겹치지 않는 메모리 공간을 문서편집기에 할당
    - 운영체제 혹은 **커널도 시스템 프로세스로서 메모리 공간을 할당받아 사용**함
  - 8강부터 상세히 설명
- **장치 관리자**
  - 컴퓨터 시스템의 모든 장치 관리
  - 시스템 장치의 할당, 작동, 반환  
    ![image](https://user-images.githubusercontent.com/61646760/220286249-d432915a-283d-43a0-84a6-fba00e57977e.png)
  - 11강-12강에서 상세히 설명
- **파일 관리자**
  - 컴퓨터 시스템의 모든 파일 관리
  - 저장장치의 공간 관리
  - 파일의 접근 제한 관리  
    ![image](https://user-images.githubusercontent.com/61646760/220286404-b35abe38-01dc-497d-afd5-52a5bc33945f.png)
  - 12강에서 상세히 설명
### 운영체제의 유형
- 대표적인 4가지 유형
  - 일괄처리 운영체제
  - 시분할 운영체제
  - 실시간 운영체제
  - 분산 운영체제
- **일괄처리 운영체제(Batch processing)**
  - 작업을 모아서 **순서대로 처리**하는 방식
  - 사람(오퍼레이터)이 하던 일을 프로그램이 빠르게 처리하게 되면서 전체적인 작업 처리 속도가 향상됨
    - 운영체제가 없던 시절, 작업 처리를 위해서는 사람(오퍼레이터)이 직접 처리할 것을 하나하나 넣고 빼야 했음
  - 나중에 들어온 작업은 **앞선 작업들이 모두 끝날 때까지** 아무런 상호작용 없이 기다려야만 함
- **시분할 운영체제(Time-sharing)**
  - 각 사용자의 프로그램을 **한 번에 조금씩 수행**하는 방식
  - 대화형(interactive) 운영체제라고도 함
  - 사용자들은 마치 혼자 컴퓨터를 사용하는 듯한 느낌을 받음
  - 응답시간이 일괄처리 운영체제보다 크게 단축됨 (앞의 작업이 모두 끝나길 기다릴 필요가 없으므로)
    - **응답시간** : 요청한 시점부터 반응이 시작되는 시점까지의 소요시간
- **실시간 운영체제(Real-time), RTOS**
  - 원하는 시간 내에 프로그램의 결과를 얻을 수 있는 방식
  - 처리 결과가 현재의 결정에 영향을 주는 환경에서 사용됨
    - `예) 미사일 제어 시스템, 증권거래 관리 시스템 등`
  - 중요한 작업에 대한 **처리 기한을 맞추는 것이 중요**
    - **우선순위가 높은 작업을 우선 처리**할 수 있는 기법 활용
- **분산 운영체제**
  - 분산 시스템을 관리하기 위한 운영체제
    - **분산 시스템** : 2개 이상의 컴퓨터 시스템이 네트워크로 서로 연결되어 서로의 자원을 이용하는 시스템
  - 다른 컴퓨터 시스템의 자원을 이용하는 것이 **마치 자신의 컴퓨터 시스템에 있는 자원을 이용하는 것처럼 가능**해야 함
  - 13강에서 상세히 설명
### 1강 정리하기
- **운영체제**는 컴퓨터 시스템의 자원을 관리하고 컴퓨터 프로그램이 동작하기 위한 서비스를 제공하는 프로그램들의 모습으로 대표적인 시스템 소프트웨어이다.
- **커널 모드**는 하드웨어를 직접 제어할 수 있는 CPU의 명령어를 사용할 수 있는 모드이고, **사용자 모드**는 하드웨어를 직접 제어할 수 있는 CPU의 명령어를 사용할 수 없는 모드이다.
- 응용 프로그램은 사용자 모드에서 동작하기에, 하드웨어에 대한 제어가 필요한 경우 **시스템 호출**을 통해 필요한 서비스를 운영체제에 요청해야 한다.
- 운영체제의 주요 구성요소에는 **프로세스 관리자**, **메모리 관리자**, **장치 관리자**, **파일 관리자**가 있다.
- 운영체제의 대표적인 유형으로는 **일괄처리 운영체제**, **시분할 운영체제**, **실시간 운영체제**, **분산 운영체제**가 있다.

## 2강. 프로세스와 쓰레드
### 프로세스
- **프로세스(process)**
  - 실행 중인 프로그램
    - 프로세스 관리를 위해 운영체제가 각각의 프로세스에 '**PID(Process ID)**'를 부여함
      - 동명의 프로그램을 여러 개 실행하면 프로세스 이름이 중복되므로 각각 ID를 부여하여 구분할 필요가 있음
    - 프로세스는 **그 프로그램 사이즈보다 큼** (작업을 진행하며 데이터가 추가되는 등)
  - 프로그램? 프로세스?
    - **프로그램(program)** : 동작을 하지 않는 정적·수동적 개체
    - **프로세스(process)** : 동작을 하는 능동적 개체
      - 즉, 정적인 프로그램을 동적인 프로세스로 실행시키는 것  
  - 운영체제로부터 **자원을 할당받아 동작**
    - 자원 : CPU, 메모리, 입출력 장치, 파일 등
    - 동작 : **CPU가 프로세스의 명령을 실행** (**프로그램을 메모리에 올리고, 실행할 코드의 메모리 주소를 CPU 레지스터로 올림**)
  - 작업 관리자로 프로세스 확인 가능  
    ![image](https://user-images.githubusercontent.com/61646760/221199655-e571ae55-07de-4773-877a-d4628d8b331b.png)
- 운영체제(프로세스 관리자)가 처리하는 작업
  - 프로세스를 생성 및 종료
  - 프로세스를 실행시키기 위한 스케줄링 작업
  - 프로세스의 상태 관리
- 프로세스의 구성
  - **프로세스 메모리 구조(Process Memory Layout)**
    - 프로그램 실행에 직접적으로 필요한 코드와 데이터  
      ![image](https://user-images.githubusercontent.com/61646760/221203460-928fd26f-0967-484b-854e-103082834890.png)
      - **코드 영역(code area)**
        - 저장 장치에 파일 형태로 있던 프로그램이 메모리상의 코드 영역으로 올라온 것
      - **데이터 영역(data area)**
        - 코드 영역의 프로그램을 실행할 때 필요한 데이터를 저장
        - 데이터 영역의 세분화
          - **정적 데이터 영역(static data area)** : 상수나 전역 변수 등 프로그램 끝까지 유지되는 데이터
          - **스택 영역(stack area)** : 서브프로그램 호출에 필요한 지역 변수 등
          - **힙 영역(heap area)** : 사용자가 수동으로 할당한 변수들
        - 참고 : [메모리의 구조 - 코딩의 시작, TCP School](http://www.tcpschool.com/c/c_memory_structure)
  - **프로세스 제어 블록(PCB: Process Control Block)**
    - 운영체제가 **프로세스를 관리하기 위해 필요한 정보** 보유
      - PCB에 저장된 정보 중 대표적인 것으로 아래를 들 수 있음  
        ![image](https://user-images.githubusercontent.com/61646760/221206345-dae10646-0d50-4108-bf5d-2ce75707f6d3.png)
        - 프로세스 번호(PID)
        - 프로세스 상태 : 실행, 대기 등
        - 프로그램 카운터(PC) : 현재 실행 중인 명령어의 다음 명령어 위치 값을 가짐 (즉 제어의 흐름을 볼 수 있음)
        - 레지스터 : 작업이 미완이지만 할당받은 CPU를 다른 프로세스에 넘겨 줘야 하는 경우, 현재 상태의 레지스터 값들을 PCB에 저장했다가 이후 다시 CPU를 할당받아 복구함
        - 메모리 관리 정보
        - 프로세스 우선순위
    - 각 프로세스마다 존재
      - 개별 프로세스마다 PID 등의 프로세스 정보가 다름
    - **여러 프로세스가 번갈아 실행되는 경우 PCB에 저장된 정보 활용**
      - CPU를 여러 프로세스가 번갈아 쓰는 경우, 레지스터 정보가 필요하므로 이를 PCB에 저장
- 프로세스 상태 관리
  - **프로세스 상태(process state)**  
    ![image](https://user-images.githubusercontent.com/61646760/221208776-654fb60b-5df5-4f34-8f9f-57003f2a4365.png)
    - **생성(New)** : 프로그램을 메모리상에 올려 프로세스(즉 메모리 구조, PCB) 생성
    - **준비(Ready)** : 메모리 구조, PCB 모두 메모리상에 생성하여 필요한 정보는 모두 올라간 상태 (준비 큐에 프로세스에 들어간 상태)
    - **실행(Running)** : CPU가 할당되어 프로세스의 명령어 처리
    - **대기(Waiting)** : 특정 이벤트 발생으로 CPU가 노는 경우 CPU를 다른 프로세스에 양보하고 대기
    - **종료(Terminated)** : 프로세스 종료
  - 프로세스 상태 변화  
    ![image](https://user-images.githubusercontent.com/61646760/221208850-cb1394b9-740f-4894-a00e-b969c5a1e6d6.png)
    - **Dispatch** (ready -> running) : 특정 프로세스에 CPU를 할당해 주는 과정 자체
    - **Interrupt** (running -> ready)
      - 스케줄링에 따라 주어진 시간을 다 소모했는데도 작업이 미완인 경우
      - 우선순위가 더 높은 프로세스가 준비 큐에 들어와서 점유 중인 CPU를 디스패치해 줘야 하는 경우
    - **Block** (running -> waiting) : 입출력, 페이지 변환 같은 이벤트가 발생하여 CPU를 사용할 수 없으면 그동안 CPU를 다른 프로세스에 양보
    - **Wakeup** (waiting -> ready) : 다시 실행 가능한 상황이 되었을 때 준비 큐에 프로세스 적재
- 프로세스 생성 방법
  1. 사용자가 프로그램을 직접 실행
  2. 한 프로세스가 다른 프로세스를 생성
      - 프로세스 생성 [시스템 호출(system call)](#커널) 이용
      - **부모 프로세스(parent process)** : 시스템 호출을 하는 프로세스
      - **자식 프로세스(child process)** : 시스템 호출을 통해 새로 생성된 프로세스
- 프로세스 생성 시스템 호출
  - UNIX, LINUX : `fork()`
    - 자식 프로세스는 부모 프로세스의 복제본  
      ![image](https://user-images.githubusercontent.com/61646760/222679780-abeb8f9a-d3f4-4e4c-b066-f8b171daf099.png)
      - 기존의 프로세스(PID=10)의 PC가 가리키는 곳에 `fork()` 명령어가 있으므로 CPU에서 해당 명령어를 처리함
      - `fork()`라는 시스템 호출을 통해 OS가 기존 프로세스의 복제본(코드 영역, 데이터 영역 동일)인 자식 프로세스(PID=25)를 생성함
      - 부모 프로세스는 `fork()`의 결괏값으로 자식의 PID=25를 받고, 자식 프로세스는 `fork()`의 결괏값으로 0을 받음 (결괏값으로 자식/부모 구분 가능)
  - UNIX, LINUX : `exec()`
    - 자식 프로세스는 부모 프로세스와는 다른 프로그램 실행 (자식 프로세스에게 다른 작업을 수행시킬 때 사용)  
      ![image](https://user-images.githubusercontent.com/61646760/222681126-f21979bc-5195-4c1d-ae69-c994591be008.png)
      - 자식 프로세스(PID=25) `fork()` 명령어 다음, PID가 0이라면(=자식 프로세스라면) prg2라는 새로운 프로그램을 실행시킴
      - 코드 영역과 데이터 영역이 prg2 관련으로 바뀌고 PCB 내용도 PID를 제외하고 prg2에 맞춰 변경됨
  - Windows : `CreateProcess()`
    - 자식 프로세스는 새로운 프로그램으로 생성  
      ![image](https://user-images.githubusercontent.com/61646760/222683096-0b5f0494-7427-48ce-b2eb-006026dd0153.png)
      - 특정 프로세스(PID=10)가 prg2 프로그램을 생성하기 위해 `CreateProcess()`로 여러 인자 값을 받아옴
      - 생성된 자식 프로세스(PID=25)는 처음부터 prg2에 대한 내용으로 코드 영역, 데이터 영역, PCB가 채워짐
- 프로세스 종료 방법
  1. 프로세스가 모든 처리를 완료(정상적 종료)
  2. 부모 프로세스에 의해 자식 프로세스가 강제 종료
      - 프로세스 종료 시스템 호출 이용
      - 자식 프로세스 생성시 얻은 자식 PID 이용
  3. 부모 프로세스가 종료되는 경우 운영체제가 자식 프로세스 종료
### 쓰레드
- 전통적인 프로세스
  - 프로세스는 하나의 프로그램을 실행하기 위한 기본적인 단위  
    ![image](https://user-images.githubusercontent.com/61646760/222689538-82817ad7-6bd7-4fc9-8d03-0db34f690d20.png)
  - 프로세스는 두 가지 단위로 볼 수 있음
    - 자원 소유의 단위
      - 하나의 메모리 구조 : 하나의 메모리 구조 안에 필요한 메모리 자원들을 할당받고 있으므로 프로세스가 자원 소유의 단위가 됨
    - 디스패칭의 단위
      - 하나의 제어흐름 : 프로세스는 하나의 제어흐름만 가짐(코드 영역에서 현재 처리되고 있는 지점이 어디인지를 가리키는 PC가 1개만 존재)
  - 프로세스 내에서 다중처리 불가능
    - 쓰레드 도입!
- **쓰레드(thread)**
  - **프로세스 내에서 다중처리**를 위해 제안된 개념
    - 프로세스 안에 PC가 여러 개 존재할 수 있다는 의미
  - (요즘 OS를 사용하는 방식에서는) 쓰레드가 하나의 프로그램을 실행하기 위한 기본적인 단위 
  - 쓰레드는 **디스패칭의 단위**가 됨
    - 즉 쓰레드별로 디스패칭받음
    - cf) 자원 소유의 단위는 여전히 프로세스 (**프로세스는 하나의 메모리 구조를 가지나 디스패칭은 쓰레드별로 이루어짐**)
  - 하나의 프로세스 내에는 하나 이상의 쓰레드 존재  
    ![image](https://user-images.githubusercontent.com/61646760/222690928-79f04f09-4619-4278-8251-6f1e88e18fb2.png)
    - 프로그램 카운터(PC)는 PCB가 아닌 쓰레드별로 존재
    - 각각의 쓰레드는 CPU를 할당받아(=디스패칭) 코드 영역의 다른 지점 명령어를 처리
- 프로세스 비교
  - 전통적인 프로세스 : 하나의 PC로 디스패칭  
    ![image](https://user-images.githubusercontent.com/61646760/222692411-91e5d553-f504-481f-8df1-9faa39088046.png)
  - 쓰레드 있는 프로세스 : 프로세스 안에 별도로 쓰레드를 가지며, 쓰레드가 PC를 가짐 (쓰레드마다 디스패칭을 따로 수행)  
    ![image](https://user-images.githubusercontent.com/61646760/222692463-c05dca1c-868c-463c-b730-35b05c5fb2d2.png)
- 쓰레드와 프로세스  
  ![image](https://user-images.githubusercontent.com/61646760/222698358-299c79e8-8666-4415-9336-dacb4a4f7468.png)
  - 쓰레드는 실행에 필요한 최소한의 정보만 가짐
    - PC를 포함한 레지스터 값 : 레지스터 값은 CPU 처리에 필요한데, 각각의 쓰레드가 다른 명령어를 수행한다면 레지스터 값이 달라지므로, 쓰레드마다 레지스터 값을 가짐
    - 상태 정보 : 쓰레드마다 별도 관리
    - 스택 영역 : 쓰레드마다 별도 관리
  - 나머지 정보는 프로세스에 두고 다른 쓰레드와 공유
- 다중 쓰레드로 구성된 프로세스
  - **멀티 CPU** 또는 **멀티코어 컴퓨터 시스템**
    - 다중 쓰레드를 병렬로 처리 가능  
      ![image](https://user-images.githubusercontent.com/61646760/222699584-4fa87764-ac70-404c-a423-4423b79fd7b4.png)
      - t_1은 CPU1에게, t_2는 CPU2에게, t_3는 CPU3에게 할당하면, 3개 쓰레드를 통한 병렬처리가 가능함
      - CPU가 1개면 쓰레드가 여럿이어도 CPU는 한번에 하나에만 할당됨
  - 처리 속도별로 쓰레드가 나눠진 경우
    - 효율적인 처리 가능  
      ![image](https://user-images.githubusercontent.com/61646760/222699644-13360425-e0d6-448c-9d0d-2913969201a3.png)
      - CPU가 1개여도 계산용, 입력용, 백업용 등과 같이 쓰레드가 용도별로 구분되어 있다면 대부분은 계산용 쓰레드에 CPU가 할당되어 효율적이게 됨

## 3강. 프로세스 스케줄링
### 프로세스 스케줄링
- 스케줄링(scheduling)
  - 여러 가지 작업의 처리 순서를 결정하는 것
  - `예) 프로세스 스케줄링, 디스크 스케줄링 등`
- **프로세스 스케줄링(process scheduling)**
  - 주어진 프로세스가 여러 개인 경우, 프로세스 처리 순서를 결정하는 것
- 스케줄링 단계  
  ![image](https://user-images.githubusercontent.com/61646760/222732410-2e4a9b52-2be3-4b5c-981b-3f7523ebc351.png)
  - 먼저 요청된 작업을 작업 큐에 삽입함
  - **상위단계 스케줄링(high level scheduling)**
    - 작업 큐에 있는 작업 중 무엇을 먼저 프로세스로 만들 것인지 결정하는 단계
      - 시스템 자원을 효율적으로 이용하기 위함
    - 일반적인 PC의 경우 요청이 들어오면 바로바로 프로세스를 생성하므로 상위단계 스케줄링이 거의 없음
  - **하위단계 스케줄링(low level scheduling)**
    - 생성된 프로세스는 준비 큐에 삽입되어 CPU 할당을 기다림
    - 각각의 프로세스 중 어느 프로세스에 CPU를 할당할 것인지 결정하는 단계
      - 즉 **준비 큐에 있는 프로세스를 선택**하여 **사용 가능한 CPU를 할당(디스패치)하는 역할**
    - 수행 주체 : **디스패처(dispatcher)**
  - **중간단계 스케줄링(intermediate level scheduling)**
    - 시스템 자원에 부하가 클 경우, 시스템에 대한 단기적 부하를 줄이기 위한 단계
    - CPU 작업이 너무 많을 경우 일부 프로세스를 일시 중지시키는 것
- 스케줄링의 목표
  - 스케줄링 기본 목표
    - 공정성
      - 모든 프로세스가 적정 수준에서 CPU 작업을 할 수 있게 함
      - 즉, 한 프로세스만 CPU를 독점하면 불공정
    - 균형
      - 시스템 자원이 충분히 활용될 수 있게 함
      - 프로세스들이 자원을 골고루 사용할 수 있도록 함
  - 운영체제의 유형에 따른 스케줄링의 목표
    - 일괄처리 운영체제
      - 처리량(주어진 시간에 처리한 프로세스 수)의 극대화
      - 반환시간(프로세스 생성 시점부터 종료 시점까지의 소요시간)의 최소화
      - CPU 활용의 극대화
    - 시분할 운영체제
      - 빠른 응답시간(요청한 시점부터 반응이 시작되는 시점까지의 소요시간)
        - 여러 사용자들이 혼자 시스템을 사용하는 것처럼 느끼게 해야 하므로 응답시간이 중요함
      - 과다한 대기시간(프로세스가 종료될 때까지 준비 큐에서 기다린 시간의 합) 방지
    - 실시간 운영체제
      - 처리기한 맞춤
- 스케줄링 정책
  - 스케줄링의 목표에 따라 우선적으로 고려해야 할 기본적인 정책
    - 선점 스케줄링 정책(preemptive scheduling)
    - 비선점 스케줄링 정책(non-preemptive scheduling)
- **선점 스케줄링 정책(preemptive scheduling)**
  - 실행 중인 **프로세스에 인터럽트**를 걸고 **다른 프로세스에 CPU를 할당**할 수 있는 스케줄링 방식
  - 높은 우선순위의 프로세스를 우선 처리해야 하는 경우에 유용
    - 실시간 시스템, 시분할 시스템
  - **문맥 교환에 따른 오버헤드** 발생
    - 운영체제는 문맥 교환이 매우 빠르게 실행되도록 만들어져야 함
      - 잠시 멈추고 레지스터 값을 프로세스 A에 저장하고 프로세스 B에서 새 레지스터 값을 가져오고 하는 등이 오버헤드가 됨
      - **오버헤드(overhead)** : 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간·메모리 등
    - **문맥(context)**
      - CPU의 모든 레지스터와 기타 운영체제에 따라 요구되는 프로세스의 상태
      - CPU가 동작할 때 레지스터 값 등을 바탕으로 특정 프로세스 작업을 실행하는데, 이러한 값들을 문맥이라고 함
    - **문맥 교환(context switching)**
      - CPU가 현재 실행하고 있는 프로세스의 문맥을 PCB에 저장하고 다른 프로세스의 PCB로부터 문맥을 복원하는 작업
      - 즉, 우선순위 등의 문제로 다른 프로세스에 CPU를 할당해야 할 때, 문맥 정보를 PCB에 전부 저장하고 다른 프로세스의 문맥 정보를 가져오는 것  
        ![image](https://user-images.githubusercontent.com/61646760/222752873-d82e9c3c-415b-4cc2-87e8-3203fcebaf64.png)
        1. 프로세스 A 실행에 필요한 여러 레지스터 정보가 CPU에 보관돼 있음
        2. 문맥 교환이 필요하면 CPU 레지스터의 값들을 프로세스 A의 PCB에 저장함
        3. 새롭게 CPU를 할당받은 프로세스 B의 PCB에 있는 정보들을 CPU의 레지스터로 보냄
        4. 이제 CPU는 프로세스 B를 실행할 수 있는 정보를 갖춤
- **비선점 스케줄링 정책(non-preemptive scheduling)**
  - 실행 중인 프로세스를 **바로 준비 상태로 전이시킬 수 없는** 스케줄링 방식
    - 즉, 자발적으로 CPU를 내놓을 수는 있으나 강제적으로 내놓지는 않음
  - CPU를 할당받아 실행이 시작된 프로세스는 대기 상태나 종료 상태로 전이될 때까지 계속 실행상태에 있게 됨
    - 즉, 실행 상태에서 준비 상태로의 전이만 불가능함
  - 강제적인 문맥 교환이 없어 오버헤드 발생하지 않음
  - 긴 프로세스가 실행 중이라면 **짧은 프로세스가 오래 기다리게 되는 경우** 발생
- 스케줄링의 평가 기준
  - **평균대기시간(average waiting time)**
    - 각 프로세스가 수행이 완료될 때까지 준비 큐에서 기다리는 시간의 합의 평균값
  - **평균반환시간(average turnaround time)**
    - 각 프로세스가 생성된 시점부터 수행이 완료된 시점까지의 소요시간의 평균값
  - 예시  
    ![image](https://user-images.githubusercontent.com/61646760/222756462-c4716f31-e79b-4e01-be83-423b9e646e50.png)
    - 프로세스 A의 경우
      - 시각 0에 프로세스 A가 생성되어 준비 큐에서 대기함
      - 시각 2에 디스패치되어 실행
      - 시각 4에 프로세스 A가 종료됨
      - 이때 프로세스 A의 대기시간과 반환시간은?
        - 대기시간은 준비 큐에서 기다리는 시간이므로 `2`
        - 반환시간은 생성 시각부터 종료 시각까지이므로 `4`
    - 프로세스 B의 경우
      - 시각 1에 프로세스 B가 생성되어 준비 큐에서 대기함
      - 시각 4에 디스패치되어 실행
      - 시각 7에 프로세스 B가 종료됨
      - 이때 프로세스 B의 대기시간과 반환시간은?
        - 대기시간 `3`, 반환시간 `6`
    - 평균대기시간 `2.5`, 평균반환시간 `5`
### 스케줄링 알고리즘
- 스케줄링 알고리즘
  - FCFS 스케줄링
  - SJF 스케줄링
  - SRT 스케줄링
  - RR 스케줄링
  - HRN 스케줄링
  - 다단계 피드백 큐 스케줄링
#### FCFS
- **FCFS 스케줄링(First-Come First-Served Scheduling)**
  - 먼저 들어온 것을 먼저 처리
    - 즉, 순차적 처리
  - 비선점 방식
  - 준비 큐에 도착한 순서에 따라 디스패치  
    ![image](https://user-images.githubusercontent.com/61646760/222906095-c03a924c-70c4-463e-a685-1bd53d2a31d3.png)
    1. A, B, C, D 순으로 도착했으니 A 먼저 디스패치
    2. A가 끝나면 B, C, D 순으로 디스패치
    3. 비선점 방식이므로 한번 디스패칭되면 해당 프로세스가 종료될 때까지 CPU 독점
  - 장점
    - 가장 간단한 스케줄링 기법
  - 단점
    - (비선점 방식이므로) 짧은 프로세스가 긴 프로세스를 기다리거나 중요한 프로세스가 나중에 수행될 수도 있음
      - 시분할 운영체제나 실시간 운영체제에는 부적합
    - 프로세스들의 **도착 순서에 따라 평균반환시간이 크게 변함**
      - 아래 예시의 도착 순서가 다른 경우 참고
- FCFS 스케줄링의 예
  - 전제  
    ![image](https://user-images.githubusercontent.com/61646760/222906491-5ae6e1fa-97d7-4f30-a770-19f773dfdfbf.png)
  - 예시  
    ![image](https://user-images.githubusercontent.com/61646760/222907018-15aa5d92-280b-4110-9fca-0810a33ed81d.png)
    1. 준비 큐 A, B, C, D 순
    2. 프로세스 A는 CPU 사이클이 7이므로 시각 7까지 실행
    3. 시각 7에 B 디스패칭하고 시각 11에 B 종료
    4. C는 시각 12, D는 시각 15에 종료
    - 스케줄링 평가 기준  
      ![image](https://user-images.githubusercontent.com/61646760/222907058-b79360ff-61d6-481e-9bb5-05c19dfa709a.png)
      - 대기시간은 프로세스 생성 후 준비 큐에서 대기한 시간
      - 반환시간은 프로세스 생성 후 완전히 종료될 때까지 걸린 시간
  - 도착 순서가 다른 경우  
    ![image](https://user-images.githubusercontent.com/61646760/222907484-77248163-7bbe-4c89-9274-b06a845258c5.png)
    - 준비 큐에 C, D, B, A 순서로 도착
    - 스케줄링 평가 기준  
      ![image](https://user-images.githubusercontent.com/61646760/222907509-8df12804-4789-40fe-9968-12e9424037ce.png)
      - 상기 예시와 완전히 동일한 조건이지만 프로세스가 준비 큐에 도착한 순서가 달라 평균대기시간, 평균반환시간이 크게 달라짐
#### SJF
- **SJF 스케줄링(Shortest Job First Scheduling)**
  - 가장 짧게 끝낼 수 있는 프로세스 먼저 수행
  - 비선점 방식
  - 준비 큐에서 기다리는 **프로세스 중 실행 시간이 가장 짧다고 예상되는 것을 먼저 디스패치**
  - 장점
    - 일괄처리 환경에서 구현하기 쉬움
  - 단점
    - 실제로는 먼저 처리할 **프로세스의 CPU 시간을 예상할 수 없음**
    - 새로 들어온 **짧은 프로세스가 긴 프로세스를 기다리거나** 중요한 프로세스가 나중에 수행될 수도 있음
      - 시분할 운영체제나 실시간 운영체제에는 부적합
- SJF 스케줄링의 예
  - 전제  
    ![image](https://user-images.githubusercontent.com/61646760/222909571-a3a19abb-92e1-4e79-8595-66eeeccfa327.png)
    - 프로세스 도착 시간이 A 0, B 2, C 4, D 5로 각각 다름
  - 예시  
    ![image](https://user-images.githubusercontent.com/61646760/222909660-67540423-a97b-4304-bb8d-ef4ab2034a17.png)
    1. 비선점 방식이므로 A가 시각 7만큼 실행됨
    2. A가 실행되는 도중에 들어온 B, C는 각각 CPU 사이클이 4, 1이므로 실행 시간이 짧은 C가 먼저 실행됨
    3. 결국 A, C, D, B 순서로 실행됨
  - 스케줄링 평가 기준  
    ![image](https://user-images.githubusercontent.com/61646760/222909982-f9bc81c6-0605-4a06-b655-308e646129ca.png)
    - 비선점 방식이라 A가 종료될 때까지 더 짧은 프로세스들이 대기해야 함
#### SRT
- **SRT 스케줄링(Shortest Remaining Time Scheduling)**
  - 남은 시간을 비교해 가장 짧은 것 먼저 수행
  - SJF 알고리즘의 **선점 방식**
  - 준비 큐에서 **기다리는 프로세스 중 남은 실행 시간이 가장 짧다고 예상되는 것을 먼저** 디스패치
  - 장점
    - SJF보다 평균대기시간이나 평균반환시간에서 효율적임
  - 단점
    - 실제로는 프로세스의 CPU 시간을 예상할 수 없음
    - 각 프로세스의 **실행 시간 추적**, **선점을 위한 문맥 교환** 등 SJF보다 **오버헤드가 큼**  
      ![image](https://user-images.githubusercontent.com/61646760/222912730-807dffc3-c3a0-41cb-9f48-d03489dbc2e6.png)
- SRT 스케줄링의 예
  - 전제  
    ![image](https://user-images.githubusercontent.com/61646760/222913385-841d6047-fd74-4183-bb85-dea33c92c72b.png)
  - 예시  
    ![image](https://user-images.githubusercontent.com/61646760/222913411-4e82268a-e753-49fa-b798-c48bee1e5edc.png)
    1. A는 CPU 사이클이 7이라 7만큼 시간이 필요하지만, 시각 2에 들어온 B는 4만큼 있으면 끝낼 수 있음
    2. A를 2만큼 수행한 시점(완료까지 5 남음)에 준비 큐에 대기시키고 B 먼저 수행
    3. B를 2만큼 수행한 시점(완료까지 2 남음)에 C가 들어옴
    4. C는 시각 1이면 끝나므로, B도 준비 큐에 대기시키고 C 먼저 수행
    5. A(5)보다 B(2)가 남은 시간이 더 짧으므로, 준비 큐에 B가 우선적으로 위치함
    6. 시각 5에 프로세스 C가 종료되면서 D가 들어옴
    7. 남은 시간은 각각 A(5), B(2), D(3)이므로 B 먼저 수행하고 그다음 순서는 D(3), A(5)
    8. 시각 15에 전체 작업 종료
  - 스케줄링 평가 기준  
    ![image](https://user-images.githubusercontent.com/61646760/222913435-54db020d-7952-4d55-9d4a-8830e265f1c8.png)
    - 준비 큐에 있었던 시간이 대기시간이므로 A의 대기시간은 시각 2부터 10까지인 8
    - 나머지 생각해 볼 것
#### RR
- **RR 스케줄링(Round Robin Scheduling)**
  - 선점 방식
  - 준비 큐에 도착한 순서대로 디스패치하지만 **정해진 시간 할당량**에 의해 실행 제한
    - 기본적으로 FCFS 스케줄링과 유사하나(도착한 순서대로 디스패치) 정해진 시간 할당량이 있음
  - 시간 할당량 안에 종료하지 못한 프로세스는 **준비 큐의 마지막에 배치**됨  
    ![image](https://user-images.githubusercontent.com/61646760/222952454-5c9f67c0-843e-410a-96d1-375fb8499ea0.png)
    1. A가 먼저 디스패칭
    2. A에게 주어진 시간 할당량이 4인데 4 안에 종료를 못했다면 A가 준비 큐의 맨 마지막으로 가게 됨 (B, C, D, ⋯, A)
  - 장점
    - CPU를 독점하지 않고 공평하게 이용
      - 시분할 운영체제에 적합
  - 단점
    - 시간 할당량이 너무 크면 **FCFS 스케줄링과 동일**
    - 시간 할당량이 너무 작으면 **너무 많은 문맥 교환 발생으로 오버헤드**가 커짐
- RR 스케줄링의 예
  - 전제  
    ![image](https://user-images.githubusercontent.com/61646760/222952615-058e2609-9c35-49f4-9fad-debef5b7fff3.png)
  - 예시 : 시간 할당량=4  
    ![image](https://user-images.githubusercontent.com/61646760/222952671-d2aa15e3-59be-4957-bd60-691f4e58d236.png)
    1. 시각 0에 A 디스패칭, 시각 2에 B 생성되어 대기
    2. A의 CPU 사이클은 7이지만 시간 할당량이 4이므로 시각 4에 A(남은 시간 3)는 준비 큐 맨 뒤에서 대기
    3. 시각 4에 C가 더 늦게 들어올 수도 있으나, 이론상으로 A가 준비 큐 맨 뒤에 위치하므로 C, A 순
    4. 먼저 기다리고 있던 B가 시각 4에 디스패칭
    5. 시각 5에 뒤가 준비 큐에 들어옴
    6. 시각 8에 CPU 사이클 4인 B는 딱 맞춰 종료됨
    7. C 실행, A 실행, D 실행
  - 스케줄링 평가 기준  
    ![image](https://user-images.githubusercontent.com/61646760/222952689-a772b796-fa20-40c7-9614-6a4c029c4076.png)
#### HRN
- **HRN 스케줄링(Highest Response Ratio Next Scheduling)**
  - 비선점 방식
  - 준비 큐에서 기다리는 프로세스 중 **응답비율이 가장 큰 것을 먼저 디스패치**  
    ![image](https://user-images.githubusercontent.com/61646760/222953342-5b1d068d-a392-4d1b-aafd-77466178f4c2.png)
    - 예상실행시간이 짧을수록, 대기시간이 길수록 응답비율이 커짐
    - 즉, 예상실행시간이 짧고, 대기시간이 긴 작업을 우선적으로 디스패칭함
  - 장점
    - **SJF 스케줄링의 단점을 보완**
      - 예상실행시간이 긴 프로세스도 **오래 대기하면 응답비율이 커져** 나중에 들어오는 짧은 프로세스보다 먼저 디스패치 가능
  - 단점
    - 실제로는 프로세스의 CPU 시간을 예상할 수 없음
- HRN 스케줄링의 예
  - 전제  
    ![image](https://user-images.githubusercontent.com/61646760/222953541-ae80c035-f548-46a7-9a66-d5dc5a159f79.png)
  - 예시  
    ![image](https://user-images.githubusercontent.com/61646760/222953552-a824eda0-baa7-4ab7-9a88-7f7a0ea47afb.png)
    1. 비선점 방식이니 A가 시각 7까지 혼자 CPU 사용
    2. 준비 큐의 B, C, D 중 응답비율이 높은 것을 선택해서 디스패칭
        - B : 대기시간은 2-7이니 5이고, 예상실행시간(CPU 사이클)은 4이므로 (5/4)+1은 2.25. 이하 생략
    3. 응답비율이 4인 C를 선택해 디스패칭
    4. C 종료 후 B, D의 응답비율을 계산하여 응답비율이 더 큰 B에 디스패칭
  - 스케줄링 평가 기준  
    ![image](https://user-images.githubusercontent.com/61646760/222953563-0af1fb4d-f3a6-4fcc-9ccc-bcb3a91c2f57.png)
#### 다단계 피드백 큐
- **다단계 피드백 큐 스케줄링(Multilevel Feedback Queue Scheduling)**
  - 선점 방식
  - **I/O 중심 프로세스**와 **연산 중심 프로세스**의 특성에 따라 **서로 다른 시간 할당량** 부여
    - 다수의 준비 큐를 통해 RR 스케줄링을 확대시킨 것으로 봐도 무방함
  - 단계 1부터 단계 n까지 하나씩의 준비 큐 존재  
    ![image](https://user-images.githubusercontent.com/61646760/222954294-3845c284-9fb0-4b9a-b717-c9ad9cdcccb9.png)
    1. RR 스케줄링처럼 먼저 들어온 것에 디스패칭
    2. 시간 할당량이 끝나면 같은 단계 준비 큐 맨 뒤로 가는 게 아니라, **그다음 단계 맨 뒤로 가서 대기**함
        - 즉, 시간 안에 못 끝내면 점점 단계가 높아짐
  - 단계 k는 단계 k+1에 피드백
    - **단계가 커질수록 시간 할당량도 커짐**
  - **앞 단계 준비 큐가 모두 비어 있어야 디스패칭**이 가능함
    - 그림과 달리 실제 CPU는 1개이므로 **단계 1을 모두 처리하고, 그다음 단계 2를 처리하고, 그다음 단계 3을 처리**하는 식
  - 스케줄링 방법
    - 디스패치 후 대기상태로 갔다가 준비상태가 될 때에는 현재와 동일한 단계의 준비 큐에 배치
    - 시간 할당량을 다 썼으면 **다음 단계의 준비 큐로 이동 배치**
    - 단계 k의 준비 큐에 있는 프로세스가 디스패치되려면 **단계 1부터 단계 k-1까지 모든 준비 큐가 비어 있어야만** 함
- 특징
  - **I/O 위주 프로세스**는 **높은 우선권** 유지
  - **연산 위주의 프로세스**는 **낮은 우선권이지만 긴 시간 할당량**
#### 스케줄링 알고리즘 정리
![image](https://user-images.githubusercontent.com/61646760/222954980-2c5e6508-a768-4408-969d-2a80ffd5f593.png)
- 비선점 : FCFS, SJF, HRN
- 선점 : RR, SRT, 다단계 피드백 큐
