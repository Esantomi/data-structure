# 운영체제

### 목차
- [1강. 운영체제 소개](#1강-운영체제-소개)
  - [운영체제란 무엇인가?](#운영체제란-무엇인가)
    - [커널](#커널)
  - [운영체제의 구성](#운영체제의-구성)
  - [운영체제의 유형](#운영체제의-유형)
- [2강. 프로세스와 쓰레드](#2강-프로세스와-쓰레드)
  - [프로세스](#프로세스)
  - [쓰레드](#쓰레드)
- [3강. 프로세스 스케줄링](#3강-프로세스-스케줄링)
  - [프로세스 스케줄링](#프로세스-스케줄링)
  - [스케줄링 알고리즘](#프로세스-알고리즘)
    - [FCFS](#FCFS)
    - [SJF](#SJF)
    - [SRT](#SRT)
    - [RR](#RR)
    - [HRN](#HRN)
    - [다단계 피드백 큐](#다단계-피드백-큐)
- [4강. 병행 프로세스 I](#4강-병행-프로세스-I)
  - [병행 프로세스의 개요](#병행-프로세스의-개요)
  - [병행성 문제](#병행성-문제)
  - [세마포어](#세마포어)
- [5강. 병행 프로세스 II](#5강-병행-프로세스-II)
  - [생산자-소비자 문제](#생산자-소비자-문제)
  - [판독기-기록기 문제](#판독기-기록기-문제)
  - [프로세스 간 통신](#프로세스-간-통신)
- [6강. 교착상태 I](#6강-교착상태-I)
  - [교착상태의 개요](#교착상태의-개요)
  - [교착상태의 특성](#교착상태의-특성)
    - [자원할당 그래프](#자원할당-그래프)
  - [교착상태 예방](#교착상태-예방)
- [7강. 교착상태 II](#7강-교착상태-II)
  - [교착상태 회피](#교착상태-회피)
    - [교착상태 회피 알고리즘](#교착상태-회피-알고리즘)
  - [교착상태 탐지 및 복구](#교착상태-탐지-및-복구)
- [8강. 메모리 관리](#8강-메모리-관리)
  - [프로세스와 메모리](#프로세스와-메모리)
  - [단일 프로그래밍 환경](#단일-프로그래밍-환경)
  - [다중 프로그래밍 환경](#다중-프로그래밍-환경)
  - [메모리 배치기법](#메모리-배치기법)
- [9강. 가상 메모리](#9강-가상-메모리)
  - [가상 메모리의 개념](#가상-메모리의-개념)
  - [블록 단위 주소변환](#블록-단위-주소변환)
    - [페이지, 세그먼트](#페이지-세그먼트)
  - [메모리 호출기법](#메모리-호출기법)
- [10강. 페이지 교체 알고리즘](#10강-페이지-교체-알고리즘)
    - [페이지 교체 알고리즘](#페이지-교체-알고리즘)
    - [프로세스별 페이지 집합관리](#프로세스별-페이지-집합관리)
      - [워킹 세트 알고리즘](#워킹-세트-알고리즘)
      - [PFF 알고리즘](#PFF-알고리즘)
- [11강. 장치관리](#11강-장치관리)
  - [장치의 개념](#장치의-개념)
  - [장치의 구성](#장치의-구성)
  - [입출력 처리 유형](#입출력-처리-유형)
  - [입출력 관리](#입출력-관리)

## 1강. 운영체제 소개
### 운영체제란 무엇인가?
- 컴퓨터 시스템의 구성
  - 하드웨어
    - CPU, 메모리, 저장장치, 입출력장치, 네트워크 장치 등
  - 소프트웨어  
    ![image](https://user-images.githubusercontent.com/61646760/220266879-64957689-4bd6-498c-97a3-1541577073fa.png)
    - **응용 소프트웨어(application software)** : 우리가 의식적으로 사용하는 소프트웨어들
    - **시스템 소프트웨어(system software)** : 응용 소프트웨어와 하드웨어 사이에서 매개체 역할을 수행(하드웨어 관리 역할이 주)
- **운영체제**
  - 대표적인 시스템 소프트웨어
  - 컴퓨터 시스템의 **자원을 관리**하고 컴퓨터 **프로그램이 동작하기 위한 서비스를 제공**하는 프로그램들의 모음
- 운영체제의 역할
  - **컴퓨터 시스템의 자원 관리**
    - 자원: 하드웨어 자원, 소프트웨어 자원, 데이터
      - `예) 저장장치에서 데이터 읽어 오기, 키보드나 마우스 제어, 프로그램 동시 실행 시 CPU와 메모리를 효율적으로 관리`
    - 컴퓨터 시스템을 **효율적으로 운영**하는 목적
  - **사용자 지원**
    - 사용자가 내린 명령을 해석하여 실행하게 함
    - 사용자와 하드웨어 사이의 매개체 역할
    - 사용자에게 편의성을 제공하는 목적
- 컴퓨터 시스템과 운영체제
  - **운영체제가 없던 초기의 컴퓨터 시스템**
    - **응용 프로그램이 직접 컴퓨터 시스템의 자원 제어**
      - 응용 프로그램 개발자는 하드웨어 제어방법을 잘 알아야 함
    - 여러 사용자가 하드웨어를 공유하는 경우 **자원 분할 어려움**  
      ![image](https://user-images.githubusercontent.com/61646760/220268778-a0e5fd42-253d-4377-8458-273c8e1e67a1.png)
      - 각각의 응용 프로그램이 독립적으로 동작하는 경우, **개별 응용 프로그램은 자신이 사용할 자원에 대해서만 제어를 수행하므로 충돌 가능성**이 있음
      - 가령 두 프로그램이 하드웨어의 특정 자원을 동시에 이용하려 한다면 문제가 발생할 수 있음
  - **운영체제가 있는 컴퓨터 시스템**
    - 하드웨어와 응용 프로그램 사이에 운영체제 위치
    - 운영체제가 컴퓨터 시스템의 자원 제어
    - 컴퓨터 시스템이 안정적이고 효율적으로 동작하도록 함  
      ![image](https://user-images.githubusercontent.com/61646760/220269643-9026b470-573f-4686-bde4-e2f0d19d1bbc.png)
      - 각각의 응용 프로그램이 독립적으로 동작하더라도, **운영체제가 중간에서** (순서 조정과 같은 방법으로) 사용할 자원의 중복이 없게끔 하는 등 **자원을 제어**해 줌
#### 커널
- **커널(kernel)**
  - 커널 모드에서 동작하는 **운영체제의 핵심 요소**
    - 응용 프로그램과 하드웨어 수준의 처리 사이의 가교 역할
  - 운영체제=커널?
    - 커널 구성 방식에 따라 다름
  - 구성 방식 : 일체형 커널, 마이크로커널
- **일체형 커널(monolithic kernel)**
  - 운영체제의 모든 서비스가 커널 내에 포함됨
    - 이 경우 **운영체제=커널**
  - 장점
    - 커널 내부 요소들이 서로 **효율적으로 상호작용**을 함
  - 단점
    - 한 요소라도 오류가 발생하면 시스템 전체에 장애 발생 가능
  - `예) UNIX, Linux`
- **마이크로커널(microkernel)**
  - 운영체제 요소의 대부분을 **커널 외부로 분리**
    - 운영체제의 기본적인 요소들만 남긴 채 커널 최소화
    - 메모리 관리, 멀티태스킹, 프로세스 간 통신(IPC) 등 **최소한의 요소만 커널 내**에 남김
  - 장점
    - 새로운 서비스를 추가하여 **운영체제를 확장하기 쉬움**
    - 유지보수가 용이하여 **안정성이 우수**함
  - 단점
    - 커널 외부 요소들 사이는 IPC(Inter-Process Communication)가 필요하여 **성능저하 발생**
- 커널 모드와 사용자 모드
  - **커널 모드(슈퍼바이저 모드)**
    - 하드웨어를 직접 제어할 수 있는 CPU 명령어를 사용할 수 있는 모드
    - 운영체제의 커널이 동작함  
      ![image](https://user-images.githubusercontent.com/61646760/220271469-786be568-8254-403f-9d56-52d540d4b40b.png)
  - **사용자 모드(보호 모드)**
    - 하드웨어를 직접 제어할 수 있는 CPU 명령어를 사용할 수 없는 모드
    - 응용 프로그램이 동작함  
      ![image](https://user-images.githubusercontent.com/61646760/220271678-4d6fd63e-f6ab-4bb8-bad0-5479675e48d9.png)
- **시스템 호출(system call)**
  - 응용 프로그램이 **하드웨어에 대한 제어가 필요한 경우** 이용
  - **운영체제에 서비스를 요청**하는 메커니즘  
    ![image](https://user-images.githubusercontent.com/61646760/220274541-664a6df0-633d-4728-a41b-1f38ad262111.png)
    - 시스템 호출을 통해 운영체제에게 하드웨어를 건드리고 싶다(하드웨어의 자원을 사용하고 싶다)고 요청하면, 사용자 모드에서 응용 프로그램이 동작하다가 그 순간 **커널 모드로 전환**됨
    - 시스템 호출에 맞춰 운영체제가 하드웨어를 제어하고 처리해 줌
    - 시스템 호출의 요구를 만족시키면 다시 응용 프로그램에 제어를 넘겨 주고, **커널 모드에서 사용자 모드로 전환**됨
### 운영체제의 구성
- 컴퓨터 시스템의 자원의 성격에 따라 구분  
  ![image](https://user-images.githubusercontent.com/61646760/220275829-ac04aa25-c6ee-4a61-81d2-24c7d4790ab5.png)
- **프로세스 관리자**
  - 프로세스의 생성 및 삭제
  - CPU 할당을 위한 스케줄 결정
  - 프로세스의 상태를 관리하며 상태 전이 처리  
    ![image](https://user-images.githubusercontent.com/61646760/220276168-5f9a21c2-8942-4e7d-a171-021c788866d9.png)
    - 저장 장치에 파일 형태로 들어 있는 **프로그램**을 메모리에 올려 실행시키면 **프로세스**가 됨
    - 프로세스 속 여러 명령어를 실행시키는 역할은 CPU가 하므로, **프로세스는 CPU를 할당받아 작업을 처리**해야 하며, 이 과정에 스케줄링이 필요함
  - 2강부터 상세히 설명
- **메모리 관리자**
  - 메모리(주기억장치) 공간에 대한 요구의 유효성 확인
  - 메모리 할당 및 회수
  - 메모리 공간 보호  
    ![image](https://user-images.githubusercontent.com/61646760/220285509-acb72a6d-6fa2-483b-be05-48f6f9fc8a80.png)
    - 메모리의 특정 영역을 브라우저라는 프로세스에게 할당
    - 문서편집기를 실행할 때 브라우저가 이미 할당받아 사용 중인 공간과 겹친다면 유효성을 확인하여 겹치지 않는 메모리 공간을 문서편집기에 할당
    - 운영체제 혹은 **커널도 시스템 프로세스로서 메모리 공간을 할당받아 사용**함
  - 8강부터 상세히 설명
- **장치 관리자**
  - 컴퓨터 시스템의 모든 장치 관리
  - 시스템 장치의 할당, 작동, 반환  
    ![image](https://user-images.githubusercontent.com/61646760/220286249-d432915a-283d-43a0-84a6-fba00e57977e.png)
  - 11강-12강에서 상세히 설명
- **파일 관리자**
  - 컴퓨터 시스템의 모든 파일 관리
  - 저장장치의 공간 관리
  - 파일의 접근 제한 관리  
    ![image](https://user-images.githubusercontent.com/61646760/220286404-b35abe38-01dc-497d-afd5-52a5bc33945f.png)
  - 12강에서 상세히 설명
### 운영체제의 유형
- 대표적인 4가지 유형
  - 일괄처리 운영체제
  - 시분할 운영체제
  - 실시간 운영체제
  - 분산 운영체제
- **일괄처리 운영체제(Batch processing)**
  - 작업을 모아서 **순서대로 처리**하는 방식
  - 사람(오퍼레이터)이 하던 일을 프로그램이 빠르게 처리하게 되면서 전체적인 작업 처리 속도가 향상됨
    - 운영체제가 없던 시절, 작업 처리를 위해서는 사람(오퍼레이터)이 직접 처리할 것을 하나하나 넣고 빼야 했음
  - 나중에 들어온 작업은 **앞선 작업들이 모두 끝날 때까지** 아무런 상호작용 없이 기다려야만 함
- **시분할 운영체제(Time-sharing)**
  - 각 사용자의 프로그램을 **한 번에 조금씩 수행**하는 방식
  - 대화형(interactive) 운영체제라고도 함
  - 사용자들은 마치 혼자 컴퓨터를 사용하는 듯한 느낌을 받음
  - 응답시간이 일괄처리 운영체제보다 크게 단축됨 (앞의 작업이 모두 끝나길 기다릴 필요가 없으므로)
    - **응답시간** : 요청한 시점부터 반응이 시작되는 시점까지의 소요시간
- **실시간 운영체제(Real-time), RTOS**
  - 원하는 시간 내에 프로그램의 결과를 얻을 수 있는 방식
  - 처리 결과가 현재의 결정에 영향을 주는 환경에서 사용됨
    - `예) 미사일 제어 시스템, 증권거래 관리 시스템 등`
  - 중요한 작업에 대한 **처리 기한을 맞추는 것이 중요**
    - **우선순위가 높은 작업을 우선 처리**할 수 있는 기법 활용
- **분산 운영체제**
  - 분산 시스템을 관리하기 위한 운영체제
    - **분산 시스템** : 2개 이상의 컴퓨터 시스템이 네트워크로 서로 연결되어 서로의 자원을 이용하는 시스템
  - 다른 컴퓨터 시스템의 자원을 이용하는 것이 **마치 자신의 컴퓨터 시스템에 있는 자원을 이용하는 것처럼 가능**해야 함
  - 13강에서 상세히 설명
### 1강 정리하기
- **운영체제**는 컴퓨터 시스템의 자원을 관리하고 컴퓨터 프로그램이 동작하기 위한 서비스를 제공하는 프로그램들의 모습으로 대표적인 시스템 소프트웨어이다.
- **커널 모드**는 하드웨어를 직접 제어할 수 있는 CPU의 명령어를 사용할 수 있는 모드이고, **사용자 모드**는 하드웨어를 직접 제어할 수 있는 CPU의 명령어를 사용할 수 없는 모드이다.
- 응용 프로그램은 사용자 모드에서 동작하기에, 하드웨어에 대한 제어가 필요한 경우 **시스템 호출**을 통해 필요한 서비스를 운영체제에 요청해야 한다.
- 운영체제의 주요 구성요소에는 **프로세스 관리자**, **메모리 관리자**, **장치 관리자**, **파일 관리자**가 있다.
- 운영체제의 대표적인 유형으로는 **일괄처리 운영체제**, **시분할 운영체제**, **실시간 운영체제**, **분산 운영체제**가 있다.

## 2강. 프로세스와 쓰레드
### 프로세스
- **프로세스(process)**
  - 실행 중인 프로그램
    - 프로세스 관리를 위해 운영체제가 각각의 프로세스에 '**PID(Process ID)**'를 부여함
      - 동명의 프로그램을 여러 개 실행하면 프로세스 이름이 중복되므로 각각 ID를 부여하여 구분할 필요가 있음
    - 프로세스는 **그 프로그램 사이즈보다 큼** (작업을 진행하며 데이터가 추가되는 등)
  - 프로그램? 프로세스?
    - **프로그램(program)** : 동작을 하지 않는 정적·수동적 개체
    - **프로세스(process)** : 동작을 하는 능동적 개체
      - 즉, 정적인 프로그램을 동적인 프로세스로 실행시키는 것  
  - 운영체제로부터 **자원을 할당받아 동작**
    - 자원 : CPU, 메모리, 입출력 장치, 파일 등
    - 동작 : **CPU가 프로세스의 명령을 실행** (**프로그램을 메모리에 올리고, 실행할 코드의 메모리 주소를 CPU 레지스터로 올림**)
  - 작업 관리자로 프로세스 확인 가능  
    ![image](https://user-images.githubusercontent.com/61646760/221199655-e571ae55-07de-4773-877a-d4628d8b331b.png)
- 운영체제(프로세스 관리자)가 처리하는 작업
  - 프로세스를 생성 및 종료
  - 프로세스를 실행시키기 위한 스케줄링 작업
  - 프로세스의 상태 관리
- 프로세스의 구성
  - **프로세스 메모리 구조(Process Memory Layout)**
    - 프로그램 실행에 직접적으로 필요한 코드와 데이터  
      ![image](https://user-images.githubusercontent.com/61646760/221203460-928fd26f-0967-484b-854e-103082834890.png)
      - **코드 영역(code area)**
        - 저장 장치에 파일 형태로 있던 프로그램이 메모리상의 코드 영역으로 올라온 것
      - **데이터 영역(data area)**
        - 코드 영역의 프로그램을 실행할 때 필요한 데이터를 저장
        - 데이터 영역의 세분화
          - **정적 데이터 영역(static data area)** : 상수나 전역 변수 등 프로그램 끝까지 유지되는 데이터
          - **스택 영역(stack area)** : 서브프로그램 호출에 필요한 지역 변수 등
          - **힙 영역(heap area)** : 사용자가 수동으로 할당한 변수들
        - 참고 : [메모리의 구조 - 코딩의 시작, TCP School](http://www.tcpschool.com/c/c_memory_structure)
  - **프로세스 제어 블록(PCB: Process Control Block)**
    - 운영체제가 **프로세스를 관리하기 위해 필요한 정보** 보유
      - PCB에 저장된 정보 중 대표적인 것으로 아래를 들 수 있음  
        ![image](https://user-images.githubusercontent.com/61646760/221206345-dae10646-0d50-4108-bf5d-2ce75707f6d3.png)
        - 프로세스 번호(PID)
        - 프로세스 상태 : 실행, 대기 등
        - 프로그램 카운터(PC) : 현재 실행 중인 명령어의 다음 명령어 위치 값을 가짐 (즉 제어의 흐름을 볼 수 있음)
        - 레지스터 : 작업이 미완이지만 할당받은 CPU를 다른 프로세스에 넘겨 줘야 하는 경우, 현재 상태의 레지스터 값들을 PCB에 저장했다가 이후 다시 CPU를 할당받아 복구함
        - 메모리 관리 정보
        - 프로세스 우선순위
    - 각 프로세스마다 존재
      - 개별 프로세스마다 PID 등의 프로세스 정보가 다름
    - **여러 프로세스가 번갈아 실행되는 경우 PCB에 저장된 정보 활용**
      - CPU를 여러 프로세스가 번갈아 쓰는 경우, 레지스터 정보가 필요하므로 이를 PCB에 저장
- 프로세스 상태 관리
  - **프로세스 상태(process state)**  
    ![image](https://user-images.githubusercontent.com/61646760/221208776-654fb60b-5df5-4f34-8f9f-57003f2a4365.png)
    - **생성(New)** : 프로그램을 메모리상에 올려 프로세스(즉 메모리 구조, PCB) 생성
    - **준비(Ready)** : 메모리 구조, PCB 모두 메모리상에 생성하여 필요한 정보는 모두 올라간 상태 (준비 큐에 프로세스에 들어간 상태)
    - **실행(Running)** : CPU가 할당되어 프로세스의 명령어 처리
    - **대기(Waiting)** : 특정 이벤트 발생으로 CPU가 노는 경우 CPU를 다른 프로세스에 양보하고 대기
    - **종료(Terminated)** : 프로세스 종료
  - 프로세스 상태 변화  
    ![image](https://user-images.githubusercontent.com/61646760/221208850-cb1394b9-740f-4894-a00e-b969c5a1e6d6.png)
    - **Dispatch** (ready -> running) : 특정 프로세스에 CPU를 할당해 주는 과정 자체
    - **Interrupt** (running -> ready)
      - 스케줄링에 따라 주어진 시간을 다 소모했는데도 작업이 미완인 경우
      - 우선순위가 더 높은 프로세스가 준비 큐에 들어와서 점유 중인 CPU를 디스패치해 줘야 하는 경우
    - **Block** (running -> waiting) : 입출력, 페이지 변환 같은 이벤트가 발생하여 CPU를 사용할 수 없으면 그동안 CPU를 다른 프로세스에 양보
    - **Wakeup** (waiting -> ready) : 다시 실행 가능한 상황이 되었을 때 준비 큐에 프로세스 적재
- 프로세스 생성 방법
  1. 사용자가 프로그램을 직접 실행
  2. 한 프로세스가 다른 프로세스를 생성
      - 프로세스 생성 [시스템 호출(system call)](#커널) 이용
      - **부모 프로세스(parent process)** : 시스템 호출을 하는 프로세스
      - **자식 프로세스(child process)** : 시스템 호출을 통해 새로 생성된 프로세스
- 프로세스 생성 시스템 호출
  - UNIX, LINUX : `fork()`
    - 자식 프로세스는 부모 프로세스의 복제본  
      ![image](https://user-images.githubusercontent.com/61646760/222679780-abeb8f9a-d3f4-4e4c-b066-f8b171daf099.png)
      - 기존의 프로세스(PID=10)의 PC가 가리키는 곳에 `fork()` 명령어가 있으므로 CPU에서 해당 명령어를 처리함
      - `fork()`라는 시스템 호출을 통해 OS가 기존 프로세스의 복제본(코드 영역, 데이터 영역 동일)인 자식 프로세스(PID=25)를 생성함
      - 부모 프로세스는 `fork()`의 결괏값으로 자식의 PID=25를 받고, 자식 프로세스는 `fork()`의 결괏값으로 0을 받음 (결괏값으로 자식/부모 구분 가능)
  - UNIX, LINUX : `exec()`
    - 자식 프로세스는 부모 프로세스와는 다른 프로그램 실행 (자식 프로세스에게 다른 작업을 수행시킬 때 사용)  
      ![image](https://user-images.githubusercontent.com/61646760/222681126-f21979bc-5195-4c1d-ae69-c994591be008.png)
      - 자식 프로세스(PID=25) `fork()` 명령어 다음, PID가 0이라면(=자식 프로세스라면) prg2라는 새로운 프로그램을 실행시킴
      - 코드 영역과 데이터 영역이 prg2 관련으로 바뀌고 PCB 내용도 PID를 제외하고 prg2에 맞춰 변경됨
  - Windows : `CreateProcess()`
    - 자식 프로세스는 새로운 프로그램으로 생성  
      ![image](https://user-images.githubusercontent.com/61646760/222683096-0b5f0494-7427-48ce-b2eb-006026dd0153.png)
      - 특정 프로세스(PID=10)가 prg2 프로그램을 생성하기 위해 `CreateProcess()`로 여러 인자 값을 받아옴
      - 생성된 자식 프로세스(PID=25)는 처음부터 prg2에 대한 내용으로 코드 영역, 데이터 영역, PCB가 채워짐
- 프로세스 종료 방법
  1. 프로세스가 모든 처리를 완료(정상적 종료)
  2. 부모 프로세스에 의해 자식 프로세스가 강제 종료
      - 프로세스 종료 시스템 호출 이용
      - 자식 프로세스 생성시 얻은 자식 PID 이용
  3. 부모 프로세스가 종료되는 경우 운영체제가 자식 프로세스 종료
### 쓰레드
- 전통적인 프로세스
  - 프로세스는 하나의 프로그램을 실행하기 위한 기본적인 단위  
    ![image](https://user-images.githubusercontent.com/61646760/222689538-82817ad7-6bd7-4fc9-8d03-0db34f690d20.png)
  - 프로세스는 두 가지 단위로 볼 수 있음
    - 자원 소유의 단위
      - 하나의 메모리 구조 : 하나의 메모리 구조 안에 필요한 메모리 자원들을 할당받고 있으므로 프로세스가 자원 소유의 단위가 됨
    - 디스패칭의 단위
      - 하나의 제어흐름 : 프로세스는 하나의 제어흐름만 가짐(코드 영역에서 현재 처리되고 있는 지점이 어디인지를 가리키는 PC가 1개만 존재)
  - 프로세스 내에서 다중처리 불가능
    - 쓰레드 도입!
- **쓰레드(thread)**
  - **프로세스 내에서 다중처리**를 위해 제안된 개념
    - 프로세스 안에 PC가 여러 개 존재할 수 있다는 의미
  - (요즘 OS를 사용하는 방식에서는) 쓰레드가 하나의 프로그램을 실행하기 위한 기본적인 단위 
  - 쓰레드는 **디스패칭의 단위**가 됨
    - 즉 쓰레드별로 디스패칭받음
    - cf) 자원 소유의 단위는 여전히 프로세스 (**프로세스는 하나의 메모리 구조를 가지나 디스패칭은 쓰레드별로 이루어짐**)
  - 하나의 프로세스 내에는 하나 이상의 쓰레드 존재  
    ![image](https://user-images.githubusercontent.com/61646760/222690928-79f04f09-4619-4278-8251-6f1e88e18fb2.png)
    - 프로그램 카운터(PC)는 PCB가 아닌 쓰레드별로 존재
    - 각각의 쓰레드는 CPU를 할당받아(=디스패칭) 코드 영역의 다른 지점 명령어를 처리
- 프로세스 비교
  - 전통적인 프로세스 : 하나의 PC로 디스패칭  
    ![image](https://user-images.githubusercontent.com/61646760/222692411-91e5d553-f504-481f-8df1-9faa39088046.png)
  - 쓰레드 있는 프로세스 : 프로세스 안에 별도로 쓰레드를 가지며, 쓰레드가 PC를 가짐 (쓰레드마다 디스패칭을 따로 수행)  
    ![image](https://user-images.githubusercontent.com/61646760/222692463-c05dca1c-868c-463c-b730-35b05c5fb2d2.png)
- 쓰레드와 프로세스  
  ![image](https://user-images.githubusercontent.com/61646760/222698358-299c79e8-8666-4415-9336-dacb4a4f7468.png)
  - 쓰레드는 실행에 필요한 최소한의 정보만 가짐
    - PC를 포함한 레지스터 값 : 레지스터 값은 CPU 처리에 필요한데, 각각의 쓰레드가 다른 명령어를 수행한다면 레지스터 값이 달라지므로, 쓰레드마다 레지스터 값을 가짐
    - 상태 정보 : 쓰레드마다 별도 관리
    - 스택 영역 : 쓰레드마다 별도 관리
  - 나머지 정보는 프로세스에 두고 다른 쓰레드와 공유
- 다중 쓰레드로 구성된 프로세스
  - **멀티 CPU** 또는 **멀티코어 컴퓨터 시스템**
    - 다중 쓰레드를 병렬로 처리 가능  
      ![image](https://user-images.githubusercontent.com/61646760/222699584-4fa87764-ac70-404c-a423-4423b79fd7b4.png)
      - t_1은 CPU1에게, t_2는 CPU2에게, t_3는 CPU3에게 할당하면, 3개 쓰레드를 통한 병렬처리가 가능함
      - CPU가 1개면 쓰레드가 여럿이어도 CPU는 한번에 하나에만 할당됨
  - 처리 속도별로 쓰레드가 나눠진 경우
    - 효율적인 처리 가능  
      ![image](https://user-images.githubusercontent.com/61646760/222699644-13360425-e0d6-448c-9d0d-2913969201a3.png)
      - CPU가 1개여도 계산용, 입력용, 백업용 등과 같이 쓰레드가 용도별로 구분되어 있다면 대부분은 계산용 쓰레드에 CPU가 할당되어 효율적이게 됨

## 3강. 프로세스 스케줄링
### 프로세스 스케줄링
- 스케줄링(scheduling)
  - 여러 가지 작업의 처리 순서를 결정하는 것
  - `예) 프로세스 스케줄링, 디스크 스케줄링 등`
- **프로세스 스케줄링(process scheduling)**
  - 주어진 프로세스가 여러 개인 경우, 프로세스 처리 순서를 결정하는 것
- 스케줄링 단계  
  ![image](https://user-images.githubusercontent.com/61646760/222732410-2e4a9b52-2be3-4b5c-981b-3f7523ebc351.png)
  - 먼저 요청된 작업을 작업 큐에 삽입함
  - **상위단계 스케줄링(high level scheduling)**
    - 작업 큐에 있는 작업 중 무엇을 먼저 프로세스로 만들 것인지 결정하는 단계
      - 시스템 자원을 효율적으로 이용하기 위함
    - 일반적인 PC의 경우 요청이 들어오면 바로바로 프로세스를 생성하므로 상위단계 스케줄링이 거의 없음
  - **하위단계 스케줄링(low level scheduling)**
    - 생성된 프로세스는 준비 큐에 삽입되어 CPU 할당을 기다림
    - 각각의 프로세스 중 어느 프로세스에 CPU를 할당할 것인지 결정하는 단계
      - 즉 **준비 큐에 있는 프로세스를 선택**하여 **사용 가능한 CPU를 할당(디스패치)하는 역할**
    - 수행 주체 : **디스패처(dispatcher)**
  - **중간단계 스케줄링(intermediate level scheduling)**
    - 시스템 자원에 부하가 클 경우, 시스템에 대한 단기적 부하를 줄이기 위한 단계
    - CPU 작업이 너무 많을 경우 일부 프로세스를 일시 중지시키는 것
- 스케줄링의 목표
  - 스케줄링 기본 목표
    - 공정성
      - 모든 프로세스가 적정 수준에서 CPU 작업을 할 수 있게 함
      - 즉, 한 프로세스만 CPU를 독점하면 불공정
    - 균형
      - 시스템 자원이 충분히 활용될 수 있게 함
      - 프로세스들이 자원을 골고루 사용할 수 있도록 함
  - 운영체제의 유형에 따른 스케줄링의 목표
    - 일괄처리 운영체제
      - 처리량(주어진 시간에 처리한 프로세스 수)의 극대화
      - 반환시간(프로세스 생성 시점부터 종료 시점까지의 소요시간)의 최소화
      - CPU 활용의 극대화
    - 시분할 운영체제
      - 빠른 응답시간(요청한 시점부터 반응이 시작되는 시점까지의 소요시간)
        - 여러 사용자들이 혼자 시스템을 사용하는 것처럼 느끼게 해야 하므로 응답시간이 중요함
      - 과다한 대기시간(프로세스가 종료될 때까지 준비 큐에서 기다린 시간의 합) 방지
    - 실시간 운영체제
      - 처리기한 맞춤
- 스케줄링 정책
  - 스케줄링의 목표에 따라 우선적으로 고려해야 할 기본적인 정책
    - 선점 스케줄링 정책(preemptive scheduling)
    - 비선점 스케줄링 정책(non-preemptive scheduling)
- **선점 스케줄링 정책(preemptive scheduling)**
  - 실행 중인 **프로세스에 인터럽트**를 걸고 **다른 프로세스에 CPU를 할당**할 수 있는 스케줄링 방식
  - 높은 우선순위의 프로세스를 우선 처리해야 하는 경우에 유용
    - 실시간 시스템, 시분할 시스템
  - **문맥 교환에 따른 오버헤드** 발생
    - 운영체제는 문맥 교환이 매우 빠르게 실행되도록 만들어져야 함
      - 잠시 멈추고 레지스터 값을 프로세스 A에 저장하고 프로세스 B에서 새 레지스터 값을 가져오고 하는 등이 오버헤드가 됨
      - **오버헤드(overhead)** : 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간·메모리 등
    - **문맥(context)**
      - CPU의 모든 레지스터와 기타 운영체제에 따라 요구되는 프로세스의 상태
      - CPU가 동작할 때 레지스터 값 등을 바탕으로 특정 프로세스 작업을 실행하는데, 이러한 값들을 문맥이라고 함
    - **문맥 교환(context switching)**
      - CPU가 현재 실행하고 있는 프로세스의 문맥을 PCB에 저장하고 다른 프로세스의 PCB로부터 문맥을 복원하는 작업
      - 즉, 우선순위 등의 문제로 다른 프로세스에 CPU를 할당해야 할 때, 문맥 정보를 PCB에 전부 저장하고 다른 프로세스의 문맥 정보를 가져오는 것  
        ![image](https://user-images.githubusercontent.com/61646760/222752873-d82e9c3c-415b-4cc2-87e8-3203fcebaf64.png)
        1. 프로세스 A 실행에 필요한 여러 레지스터 정보가 CPU에 보관돼 있음
        2. 문맥 교환이 필요하면 CPU 레지스터의 값들을 프로세스 A의 PCB에 저장함
        3. 새롭게 CPU를 할당받은 프로세스 B의 PCB에 있는 정보들을 CPU의 레지스터로 보냄
        4. 이제 CPU는 프로세스 B를 실행할 수 있는 정보를 갖춤
- **비선점 스케줄링 정책(non-preemptive scheduling)**
  - 실행 중인 프로세스를 **바로 준비 상태로 전이시킬 수 없는** 스케줄링 방식
    - 즉, 자발적으로 CPU를 내놓을 수는 있으나 강제적으로 내놓지는 않음
  - CPU를 할당받아 실행이 시작된 프로세스는 대기 상태나 종료 상태로 전이될 때까지 계속 실행상태에 있게 됨
    - 즉, 실행 상태에서 준비 상태로의 전이만 불가능함
  - 강제적인 문맥 교환이 없어 오버헤드 발생하지 않음
  - 긴 프로세스가 실행 중이라면 **짧은 프로세스가 오래 기다리게 되는 경우** 발생
- 스케줄링의 평가 기준
  - **평균대기시간(average waiting time)**
    - 각 프로세스가 수행이 완료될 때까지 준비 큐에서 기다리는 시간의 합의 평균값
  - **평균반환시간(average turnaround time)**
    - 각 프로세스가 생성된 시점부터 수행이 완료된 시점까지의 소요시간의 평균값
  - 예시  
    ![image](https://user-images.githubusercontent.com/61646760/222756462-c4716f31-e79b-4e01-be83-423b9e646e50.png)
    - 프로세스 A의 경우
      - 시각 0에 프로세스 A가 생성되어 준비 큐에서 대기함
      - 시각 2에 디스패치되어 실행
      - 시각 4에 프로세스 A가 종료됨
      - 이때 프로세스 A의 대기시간과 반환시간은?
        - 대기시간은 준비 큐에서 기다리는 시간이므로 `2`
        - 반환시간은 생성 시각부터 종료 시각까지이므로 `4`
    - 프로세스 B의 경우
      - 시각 1에 프로세스 B가 생성되어 준비 큐에서 대기함
      - 시각 4에 디스패치되어 실행
      - 시각 7에 프로세스 B가 종료됨
      - 이때 프로세스 B의 대기시간과 반환시간은?
        - 대기시간 `3`, 반환시간 `6`
    - 평균대기시간 `2.5`, 평균반환시간 `5`
### 스케줄링 알고리즘
- 스케줄링 알고리즘
  - FCFS 스케줄링
  - SJF 스케줄링
  - SRT 스케줄링
  - RR 스케줄링
  - HRN 스케줄링
  - 다단계 피드백 큐 스케줄링
#### FCFS
- **FCFS 스케줄링(First-Come First-Served Scheduling)**
  - 먼저 들어온 것을 먼저 처리
    - 즉, 순차적 처리
  - 비선점 방식
  - 준비 큐에 도착한 순서에 따라 디스패치  
    ![image](https://user-images.githubusercontent.com/61646760/222906095-c03a924c-70c4-463e-a685-1bd53d2a31d3.png)
    1. A, B, C, D 순으로 도착했으니 A 먼저 디스패치
    2. A가 끝나면 B, C, D 순으로 디스패치
    3. 비선점 방식이므로 한번 디스패칭되면 해당 프로세스가 종료될 때까지 CPU 독점
  - 장점
    - 가장 간단한 스케줄링 기법
  - 단점
    - (비선점 방식이므로) 짧은 프로세스가 긴 프로세스를 기다리거나 중요한 프로세스가 나중에 수행될 수도 있음
      - 시분할 운영체제나 실시간 운영체제에는 부적합
    - 프로세스들의 **도착 순서에 따라 평균반환시간이 크게 변함**
      - 아래 예시의 도착 순서가 다른 경우 참고
- FCFS 스케줄링의 예
  - 전제  
    ![image](https://user-images.githubusercontent.com/61646760/222906491-5ae6e1fa-97d7-4f30-a770-19f773dfdfbf.png)
  - 예시  
    ![image](https://user-images.githubusercontent.com/61646760/222907018-15aa5d92-280b-4110-9fca-0810a33ed81d.png)
    1. 준비 큐 A, B, C, D 순
    2. 프로세스 A는 CPU 사이클이 7이므로 시각 7까지 실행
    3. 시각 7에 B 디스패칭하고 시각 11에 B 종료
    4. C는 시각 12, D는 시각 15에 종료
    - 스케줄링 평가 기준  
      ![image](https://user-images.githubusercontent.com/61646760/222907058-b79360ff-61d6-481e-9bb5-05c19dfa709a.png)
      - 대기시간은 프로세스 생성 후 준비 큐에서 대기한 시간
      - 반환시간은 프로세스 생성 후 완전히 종료될 때까지 걸린 시간
  - 도착 순서가 다른 경우  
    ![image](https://user-images.githubusercontent.com/61646760/222907484-77248163-7bbe-4c89-9274-b06a845258c5.png)
    - 준비 큐에 C, D, B, A 순서로 도착
    - 스케줄링 평가 기준  
      ![image](https://user-images.githubusercontent.com/61646760/222907509-8df12804-4789-40fe-9968-12e9424037ce.png)
      - 상기 예시와 완전히 동일한 조건이지만 프로세스가 준비 큐에 도착한 순서가 달라 평균대기시간, 평균반환시간이 크게 달라짐
#### SJF
- **SJF 스케줄링(Shortest Job First Scheduling)**
  - 가장 짧게 끝낼 수 있는 프로세스 먼저 수행
  - 비선점 방식
  - 준비 큐에서 기다리는 **프로세스 중 실행 시간이 가장 짧다고 예상되는 것을 먼저 디스패치**
  - 장점
    - 일괄처리 환경에서 구현하기 쉬움
  - 단점
    - 실제로는 먼저 처리할 **프로세스의 CPU 시간을 예상할 수 없음**
    - 새로 들어온 **짧은 프로세스가 긴 프로세스를 기다리거나** 중요한 프로세스가 나중에 수행될 수도 있음
      - 시분할 운영체제나 실시간 운영체제에는 부적합
- SJF 스케줄링의 예
  - 전제  
    ![image](https://user-images.githubusercontent.com/61646760/222909571-a3a19abb-92e1-4e79-8595-66eeeccfa327.png)
    - 프로세스 도착 시간이 A 0, B 2, C 4, D 5로 각각 다름
  - 예시  
    ![image](https://user-images.githubusercontent.com/61646760/222909660-67540423-a97b-4304-bb8d-ef4ab2034a17.png)
    1. 비선점 방식이므로 A가 시각 7만큼 실행됨
    2. A가 실행되는 도중에 들어온 B, C는 각각 CPU 사이클이 4, 1이므로 실행 시간이 짧은 C가 먼저 실행됨
    3. 결국 A, C, D, B 순서로 실행됨
  - 스케줄링 평가 기준  
    ![image](https://user-images.githubusercontent.com/61646760/222909982-f9bc81c6-0605-4a06-b655-308e646129ca.png)
    - 비선점 방식이라 A가 종료될 때까지 더 짧은 프로세스들이 대기해야 함
#### SRT
- **SRT 스케줄링(Shortest Remaining Time Scheduling)**
  - 남은 시간을 비교해 가장 짧은 것 먼저 수행
  - SJF 알고리즘의 **선점 방식**
  - 준비 큐에서 **기다리는 프로세스 중 남은 실행 시간이 가장 짧다고 예상되는 것을 먼저** 디스패치
  - 장점
    - SJF보다 평균대기시간이나 평균반환시간에서 효율적임
  - 단점
    - 실제로는 프로세스의 CPU 시간을 예상할 수 없음
    - 각 프로세스의 **실행 시간 추적**, **선점을 위한 문맥 교환** 등 SJF보다 **오버헤드가 큼**  
      ![image](https://user-images.githubusercontent.com/61646760/222912730-807dffc3-c3a0-41cb-9f48-d03489dbc2e6.png)
- SRT 스케줄링의 예
  - 전제  
    ![image](https://user-images.githubusercontent.com/61646760/222913385-841d6047-fd74-4183-bb85-dea33c92c72b.png)
  - 예시  
    ![image](https://user-images.githubusercontent.com/61646760/222913411-4e82268a-e753-49fa-b798-c48bee1e5edc.png)
    1. A는 CPU 사이클이 7이라 7만큼 시간이 필요하지만, 시각 2에 들어온 B는 4만큼 있으면 끝낼 수 있음
    2. A를 2만큼 수행한 시점(완료까지 5 남음)에 준비 큐에 대기시키고 B 먼저 수행
    3. B를 2만큼 수행한 시점(완료까지 2 남음)에 C가 들어옴
    4. C는 시각 1이면 끝나므로, B도 준비 큐에 대기시키고 C 먼저 수행
    5. A(5)보다 B(2)가 남은 시간이 더 짧으므로, 준비 큐에 B가 우선적으로 위치함
    6. 시각 5에 프로세스 C가 종료되면서 D가 들어옴
    7. 남은 시간은 각각 A(5), B(2), D(3)이므로 B 먼저 수행하고 그다음 순서는 D(3), A(5)
    8. 시각 15에 전체 작업 종료
  - 스케줄링 평가 기준  
    ![image](https://user-images.githubusercontent.com/61646760/222913435-54db020d-7952-4d55-9d4a-8830e265f1c8.png)
    - 준비 큐에 있었던 시간이 대기시간이므로 A의 대기시간은 시각 2부터 10까지인 8
    - 나머지 생각해 볼 것
#### RR
- **RR 스케줄링(Round Robin Scheduling)**
  - 선점 방식
  - 준비 큐에 도착한 순서대로 디스패치하지만 **정해진 시간 할당량**에 의해 실행 제한
    - 기본적으로 FCFS 스케줄링과 유사하나(도착한 순서대로 디스패치) 정해진 시간 할당량이 있음
  - 시간 할당량 안에 종료하지 못한 프로세스는 **준비 큐의 마지막에 배치**됨  
    ![image](https://user-images.githubusercontent.com/61646760/222952454-5c9f67c0-843e-410a-96d1-375fb8499ea0.png)
    1. A가 먼저 디스패칭
    2. A에게 주어진 시간 할당량이 4인데 4 안에 종료를 못했다면 A가 준비 큐의 맨 마지막으로 가게 됨 (B, C, D, ⋯, A)
  - 장점
    - CPU를 독점하지 않고 공평하게 이용
      - 시분할 운영체제에 적합
  - 단점
    - 시간 할당량이 너무 크면 **FCFS 스케줄링과 동일**
    - 시간 할당량이 너무 작으면 **너무 많은 문맥 교환 발생으로 오버헤드**가 커짐
- RR 스케줄링의 예
  - 전제  
    ![image](https://user-images.githubusercontent.com/61646760/222952615-058e2609-9c35-49f4-9fad-debef5b7fff3.png)
  - 예시 : 시간 할당량=4  
    ![image](https://user-images.githubusercontent.com/61646760/222952671-d2aa15e3-59be-4957-bd60-691f4e58d236.png)
    1. 시각 0에 A 디스패칭, 시각 2에 B 생성되어 대기
    2. A의 CPU 사이클은 7이지만 시간 할당량이 4이므로 시각 4에 A(남은 시간 3)는 준비 큐 맨 뒤에서 대기
    3. 시각 4에 C가 더 늦게 들어올 수도 있으나, 이론상으로 A가 준비 큐 맨 뒤에 위치하므로 C, A 순
    4. 먼저 기다리고 있던 B가 시각 4에 디스패칭
    5. 시각 5에 뒤가 준비 큐에 들어옴
    6. 시각 8에 CPU 사이클 4인 B는 딱 맞춰 종료됨
    7. C 실행, A 실행, D 실행
  - 스케줄링 평가 기준  
    ![image](https://user-images.githubusercontent.com/61646760/222952689-a772b796-fa20-40c7-9614-6a4c029c4076.png)
#### HRN
- **HRN 스케줄링(Highest Response Ratio Next Scheduling)**
  - 비선점 방식
  - 준비 큐에서 기다리는 프로세스 중 **응답비율이 가장 큰 것을 먼저 디스패치**  
    ![image](https://user-images.githubusercontent.com/61646760/222953342-5b1d068d-a392-4d1b-aafd-77466178f4c2.png)
    - 예상실행시간이 짧을수록, 대기시간이 길수록 응답비율이 커짐
    - 즉, 예상실행시간이 짧고, 대기시간이 긴 작업을 우선적으로 디스패칭함
  - 장점
    - **SJF 스케줄링의 단점을 보완**
      - 예상실행시간이 긴 프로세스도 **오래 대기하면 응답비율이 커져** 나중에 들어오는 짧은 프로세스보다 먼저 디스패치 가능
  - 단점
    - 실제로는 프로세스의 CPU 시간을 예상할 수 없음
- HRN 스케줄링의 예
  - 전제  
    ![image](https://user-images.githubusercontent.com/61646760/222953541-ae80c035-f548-46a7-9a66-d5dc5a159f79.png)
  - 예시  
    ![image](https://user-images.githubusercontent.com/61646760/222953552-a824eda0-baa7-4ab7-9a88-7f7a0ea47afb.png)
    1. 비선점 방식이니 A가 시각 7까지 혼자 CPU 사용
    2. 준비 큐의 B, C, D 중 응답비율이 높은 것을 선택해서 디스패칭
        - B : 대기시간은 2-7이니 5이고, 예상실행시간(CPU 사이클)은 4이므로 (5/4)+1은 2.25. 이하 생략
    3. 응답비율이 4인 C를 선택해 디스패칭
    4. C 종료 후 B, D의 응답비율을 계산하여 응답비율이 더 큰 B에 디스패칭
  - 스케줄링 평가 기준  
    ![image](https://user-images.githubusercontent.com/61646760/222953563-0af1fb4d-f3a6-4fcc-9ccc-bcb3a91c2f57.png)
#### 다단계 피드백 큐
- **다단계 피드백 큐 스케줄링(Multilevel Feedback Queue Scheduling)**
  - 선점 방식
  - **I/O 중심 프로세스**와 **연산 중심 프로세스**의 특성에 따라 **서로 다른 시간 할당량** 부여
    - 다수의 준비 큐를 통해 RR 스케줄링을 확대시킨 것으로 봐도 무방함
  - 단계 1부터 단계 n까지 하나씩의 준비 큐 존재  
    ![image](https://user-images.githubusercontent.com/61646760/222954294-3845c284-9fb0-4b9a-b717-c9ad9cdcccb9.png)
    1. RR 스케줄링처럼 먼저 들어온 것에 디스패칭
    2. 시간 할당량이 끝나면 같은 단계 준비 큐 맨 뒤로 가는 게 아니라, **그다음 단계 맨 뒤로 가서 대기**함
        - 즉, 시간 안에 못 끝내면 점점 단계가 높아짐
  - 단계 k는 단계 k+1에 피드백
    - **단계가 커질수록 시간 할당량도 커짐**
  - **앞 단계 준비 큐가 모두 비어 있어야 디스패칭**이 가능함
    - 그림과 달리 실제 CPU는 1개이므로 **단계 1을 모두 처리하고, 그다음 단계 2를 처리하고, 그다음 단계 3을 처리**하는 식
  - 스케줄링 방법
    - 디스패치 후 대기상태로 갔다가 준비상태가 될 때에는 현재와 동일한 단계의 준비 큐에 배치
    - 시간 할당량을 다 썼으면 **다음 단계의 준비 큐로 이동 배치**
    - 단계 k의 준비 큐에 있는 프로세스가 디스패치되려면 **단계 1부터 단계 k-1까지 모든 준비 큐가 비어 있어야만** 함
- 특징
  - **I/O 위주 프로세스**는 **높은 우선권** 유지
  - **연산 위주의 프로세스**는 **낮은 우선권이지만 긴 시간 할당량**
#### 스케줄링 알고리즘 정리
![image](https://user-images.githubusercontent.com/61646760/222954980-2c5e6508-a768-4408-969d-2a80ffd5f593.png)
- 비선점 : FCFS, SJF, HRN
- 선점 : RR, SRT, 다단계 피드백 큐

## 4강. 병행 프로세스 I
### 병행 프로세스의 개요
- **병행성(concurrency)**
  - 여러 개의 프로세스 또는 쓰레드가 동시 수행되는 시스템의 특성  
    ![image](https://user-images.githubusercontent.com/61646760/227431192-3efaf5a9-a92c-49f3-8180-99302d75055e.png)
- **병행 프로세스(concurrent process)**
  - 동시 수행되는 여러 개의 프로세스 또는 쓰레드
- 병행 프로세스의 실행 형태
  - 1개의 CPU : **인터리빙(interleaving) 형식**  
    ![image](https://user-images.githubusercontent.com/61646760/227431465-916ba944-50df-474d-b851-2b319611137b.png)
  - 여러 개의 CPU : **병렬처리(parallel processing) 형식**  
    ![image](https://user-images.githubusercontent.com/61646760/227431509-658d811a-acb9-4eb4-a5a9-435e5c639063.png)
  - 멀티프로세서 시스템에서의 메모리 구조에 따라  
    - **강결합 시스템(Tightly-coupled system)** : i.e. **공유 메모리 구조**  
      ![image](https://user-images.githubusercontent.com/61646760/227431798-810be4f3-a3d8-4403-9155-4ecc3addf490.png)
    - **약결합 시스템(Loosely-coupled system)** : i.e. **분산 메모리 구조**  
      ![image](https://user-images.githubusercontent.com/61646760/227431821-bcd4b2c3-d523-4589-aebd-9b07e772e28b.png)
- 프로세스 간의 관계
  - **독립 프로세스(independent process)**
    - 수행 중인 다른 프로세스에 영향을 주지도 받지도 않음
    - 데이터 및 상태를 다른 프로세스와 공유하지 않음
    - 프로세스의 실행
      - **결정적** : 실행 결과는 입력에 의해서만 결정됨
      - **재생 가능** : 같은 입력에 대해 항상 동일한 실행 결과
  - **협력 프로세스(cooperating process)**
    - 수행 중인 다른 프로세스와 영향을 주고받음
    - 데이터 및 상태를 다른 프로세스와 공유
    - 프로세스의 실행
      - **비결정적** : 실행 결과는 실행 순서에 좌우됨
      - **재생 불가능** : 같은 입력에 대해 항상 동일한 실행 결과를 보장하지 못함
### 병행성 문제
- 병행성 문제 : 협력 프로세스인 경우 발생 가능한 문제
  - 상호배제
  - 동기화
  - 통신
- **상호배제(mutual exclusion, Mutex)**
  - 2개 이상의 프로세스가 동시에 임계 영역을 수행하지 못하도록 하는 것
  - **임계영역(critical section)**
    - 2개 이상의 프로세스가 동시에 사용하면 안 되는 공유 자원을 액세스하는 프로그램 코드 영역  
      ![image](https://user-images.githubusercontent.com/61646760/227432799-d5c91a1a-7765-4d14-b403-bad587931416.png)
      - 프로세스 A는 공유 자원에 5천 원 입금
        - 입금하기 전 공유 자원의 잔고를 확인하고, 입금할 돈을 더하고, 최종 금액을 공유 자원에 쓰는 순서로 프로그램이 작성됨
        - 잔고가 1만 원인 걸 확인하고 5천 원을 더해 공유 자원의 잔고를 1.5만 원으로 입력함
      - 프로세스 B는 공유 자원에 8천 원 입금
        - 프로세스 B가 프로세스 A와 동시에 진행될 경우 잔고를 1만 원으로 파악함
        - 그러나 프로세스 A가 이미 공유 자원의 잔고를 1.5만 원으로 갱신한 상황임
        - 프로세스 B는 잔고 1만 원에 8천 원을 더해서 공유 자원의 잔고를 1.8만 원으로 갱신함
        - 1.8만 ≠ 2.3만!
        - 이는 프로세스 A가 잔고를 읽고 더해서 갱신하는 과정에 프로세스 B가 읽기 작업을 수행했기 때문임
          - **상호 배제가 잘못**되었음
          - **임계영역을 설정**하여 두 개 이상의 프로세스가 **동시에 임계영역을 수행하지 못하도록** 해야 함
      - 최종적으로 공유 자원의 잔고는 23,000원이 되어야 함  
      ![image](https://user-images.githubusercontent.com/61646760/227432861-b024793b-73c3-47e2-93ec-c4d613112e88.png)
      - 빨간 박스가 임계영역에 해당
        - 해당 부분이 수행되는 도중에 다른 프로세스가 해당 부분을 실행할 수 없음
      - 프로세스 A가 잔고를 읽고 더해서 갱신할 때까지 프로세스 B는 잔고를 읽지 못하고 대기함
      - 2.3만 원!
- **동기화(synchronization)**
  - 2개 이상의 프로세스에 대한 처리 순서를 결정하는 것
    - 프로세스 동기화
  - **상호배제는 임계영역에 대한 동기화 문제** (임계영역 사용에 대한 순서를 정해야 함)  
    ![image](https://user-images.githubusercontent.com/61646760/227434549-ac752fd2-9c6f-415e-855a-60bc1006f2a3.png)
    - 계좌 1의 5만 원 중 1만 원을 계좌 2의 3만 원에 더하는(1만 원을 인출해 입금시키는) 작업
    - 출금 프로세스와 입금 프로세스가 별도로 존재함
      - 계좌 1에서 1만 원을 출금
      - 출금한 1만 원을 계좌 2에 입금
      - 전체 잔고는 항상 8만 원으로 유지됨
    - 정상적으로 동기화가 이루어진 상태  
    ![image](https://user-images.githubusercontent.com/61646760/227434604-57e059dd-8293-44e7-a60b-05cbc9f9b10c.png)
    - 출금 프로세스와 입금 프로세스의 순서가 꼬인 상황
    - 출금 프로세스가 출금하기 전 입금 프로세스가 먼저 1만 원을 계좌 2에 입금함
      - 그 순간 계좌의 전체 잔고는 9만 원이 됨
      - 동기화가 잘못됨
    - **서로 다른 프로세스지만 둘 사이의 순서 관계를 정해 줘야 함** (=프로세스 동기화)
- 통신
  - 프로세스들이 데이터를 공유하기 위해 반드시 필요
    - **프로세스 간 통신(IPC)**
  - 통신 방법
    - 하나의 변수 사용
    - 메시지를 서로 주고받음
  - 뒤에서 좀 더 자세히 다룰 예정
### 세마포어
- **세마포어(Semaphore)**
  - 상호배제와 동기화 문제를 해결하기 위한 도구
    - Dijkstra가 제안
  - **정수형 공용변수**
    - 저장값 : 사용 가능한 자원의 수 또는 잠김이나 풀림의 상태
  - 상황에 맞춰 0 이상인 정수로 초기화
  - 두 기본연산 P와 V에 의해서만 사용됨
    - 기본연산 : 인터럽트되지 않고 하나의 단위로 처리됨
  - 세마포어마다 **대기 큐 필요**
- **연산 P**
  - 검사, 감소시키려는 시도
    ```
    void P(semaphore s)
    {
      if (s > 0)
        s--;
      else
        현재 프로세스를 대기시킴;
    }
    ```
- **연산 V**
  - 증가
    ```
    void V(semaphore s)
    {
      if (대기 중인 프로세스 없음)
        s++;
      else
        대기 중인 프로세스 1개 진행;
    }
    ```
- 상호배제 해결
  - 상호배제를 위한 일반적인 요구사항
    - 한 프로세스가 임계영역 수행 중
      - 다른 프로세스는 임계영역에 진입해서는 안 됨
    - 임계영역 수행 중이던 프로세스가 임계영역 벗어남
      - 누군가 하나는 임계영역을 새로이 수행할 수 있어야 함
    - 임계영역 진입 못하고 대기하는 프로세스
      - 적절한 시간 내에 임계영역 수행을 시작할 수 있어야 함
  - 상호배제를 위한 임계영역 주변의 코드 영역  
    ![image](https://user-images.githubusercontent.com/61646760/227436699-ae1f5485-a3fc-446a-86be-1f09420a8b01.png)
    - 임계영역에 대한 수행을 해도 되는지 체크
    - 다른 프로세스가 임계영역 수행을 시작할 수 있도록 함
  - 세마포어 이용  
    ![image](https://user-images.githubusercontent.com/61646760/227436853-385608c2-ede6-4511-a034-bb04258193c7.png)
    - 세마포어 **mutex 초깃값은 1**
    - 진입영역 : **P(mutex)**
    - 해제영역 : **V(mutex)**
    - 대기 큐는 FIFO로 동작
- 상호배제 해결 예  
  ![image](https://user-images.githubusercontent.com/61646760/227437046-49d21778-94ff-42bb-8ada-45fa05a94136.png)
  - mutex 초깃값은 1
  - 프로세스 A가 P 호출
    - mutex 체크했더니 0보다 크므로 mutex-- 후 P 종료
    - mutex는 0이 되고 프로세스 A는 임계영역 수행
  - 프로세스 B가 P 호출
    - mutex 체크했더니 0보다 크지 않으므로(0이므로) 대기
    - 프로세스 B는 대기 큐에 들어가 대기함
  - 프로세스 C가 P 호출
    - mutex 체크했더니 0이므로 대기 큐에서 대기
  - 프로세스 A가 임계영역을 끝내면 연산 V를 호출
    - 대기 중인 프로세스가 존재하므로, 프로세스 B가 임계영역을 수행하게끔 함
  - 프로세스 B가 임계영역을 끝내면 연산 V를 호출
    - 대기 중인 프로세스가 존재하므로, 프로세스 C가 임계영역을 수행하게끔 함
  - 프로세스 C가 임계영역을 끝내면 연산 V를 호출
    - 대기 중인 프로세스가 없음
    - mutex++ 후 프로세스 종료
    - 이후 다른 프로세스가 P 호출했을 때 mutex가 1이므로 임계영역 수행 가능
  - semaphore인 **mutex의 초깃값을 1로 설정**해 둠으로써 **한 프로세스만 진입할 수 있게 하여 상호배제를 해결함**
- 동기화 해결
  - 상황 : 프로세스 A가 코드 S_1을 수행한 후 프로세스 B가 코드 S_2를 수행하도록 동기화
  - 세마포어 **sync 초깃값은 0**  
    ![image](https://user-images.githubusercontent.com/61646760/227438417-d842757c-1725-45ca-8d5f-688c9c2c45a3.png)
    - **프로세스 A가 S_1을 수행하면 그다음 B가 S_2를 수행해야 함**
      - S_1이 끝나면 V 연산 호출
      - S_2가 시작되기 전에 P 연산 호출
    - **일반적인 경우 (프로세스 A가 S_1에 먼저 접근하는 경우)**
      - S_1이 끝나면 V 연산 호출
        - 대기 중인 프로세스가 없으므로 sync++하여 sync 값 1
      - S_2가 시작되기 전에 P 연산 호출
        - semaphore가 0보다 큰지 체크
        - sync 값은 1이므로 sync--하여 sync 값 0
    - **프로세스 B가 S_2에 먼저 접근하는 경우**
      - S_2가 시작되기 전에 P 연산 호출
        - sync 값을 보니 0보다 크지 않음(초깃값 0)
        - 프로세스 B는 대기 큐에 대기시킴
      - S_1이 끝나면 V 연산 호출
        - 대기 큐에 B가 대기 중이므로 B가 S_2를 처리하게 함
      - 즉 B가 먼저 S_2를 처리하려고 했지만, P 연산에 의해 계속 대기하고 있다가, A가 S_1을 처리한 뒤에야, V 연산에 의해 깨어나 S_2를 처리함
        - S_1을 수행한 후 S_2를 처리하고자 한 상황에 완벽히 부합함 (동기화 완료)
## 5강. 병행 프로세스 II
### 생산자-소비자 문제
### 판독기-기록기 문제
### 프로세스 간 통신

## 6강. 교착상태 I
### 교착상태의 개요
- 프로세스의 자원 사용 절차
  - **요구 → 사용 → 해제**
  - 요구과정에서 가용한 자원이 없으면 자원을 획득할 때까지 대기  
    ![image](https://user-images.githubusercontent.com/61646760/227468866-465388c1-38d5-47a0-8c9d-7dcb3991fc03.png)
- **교착상태(deadlock)**
  - 여러 개의 프로세스가 서로 상대방의 작업이 끝나기만 기다리고 있어 어느 쪽도 영원히 진행하지 못하는 상태  
    ![image](https://user-images.githubusercontent.com/61646760/227469048-1a4bb006-b447-4563-8f64-6a95580512b4.png)
- **기아상태(starvation)**
  - 프로세스가 끊임없이 필요한 컴퓨터 자원을 가져오지 못하는 상황
- 교착상태와 기아상태의 차이  
  ![image](https://user-images.githubusercontent.com/61646760/227468745-ae4d5c95-d4bf-4a4d-a1d0-005270ecfdbb.png)
  - 자동차가 전진만 할 수 있다고 가정할 경우, 교착상태는 영원히 해결되지 못함
  - 기아상태의 경우, 자동차의 연쇄적 행 이동이 언젠가 끝나면 해결될 수 있음
### 교착상태의 특성
- 교착상태의 필요조건
  - 네 가지 조건이 동시에 만족될 때 교착상태 발생 가능
    - 상호배제
    - 점유대기
    - 비선점
    - 환형대기
  - 필요충분조건이 아닌 필요조건이므로, 네 가지 조건이 동시에 만족되더라도 반드시 교착상태가 발생하는 것은 아님
- **상호배제(mutual exclusion) 조건**
  - 프로세스가 자원에 대한 배타적인 통제권을 요구
    - 적어도 하나 이상의 자원은 여러 프로세스에 의해 동시에 사용될 수 없음
  - 다른 프로세스가 점유한 자원이 필요하면 반드시 대기  
    ![image](https://user-images.githubusercontent.com/61646760/227470304-69689845-e138-4f98-9f6c-29087e63028d.png)
- **점유대기(hold and wait) 조건**
  - 프로세스가 이미 한 자원을 할당받아 점유하고 있는 상황에서 다른 프로세스가 점유하고 있는 또 다른 자원을 요구하여 해제되기를 기다리는 상황  
    ![image](https://user-images.githubusercontent.com/61646760/227471050-2d39d33c-0483-4371-aded-8f55b761a2df.png)
- **비선점(no preemption) 조건**
  - 프로세스에 할당된 자원은 그 프로세스가 사용을 마치고 스스로 반환하기 전에는 해제되지 않음
  - 할당된 자원은 타의에 의해서는 해제되지 않음  
    ![image](https://user-images.githubusercontent.com/61646760/227471481-eb9af7c6-c76e-400d-b3bb-18a40befd404.png)
- **환형대기(circular wait) 조건**
  - 프로세스의 자원 점유 및 점유된 자원의 요구 관계가 환형을 이루며 대기하는 상황  
    ![image](https://user-images.githubusercontent.com/61646760/227471894-dc51cd3d-257e-412a-9d4a-ac01f0a46658.png)
#### 자원할당 그래프
- `G = (V, E)`
  - V : 정점의 집합 (`V = P∪R`)
    - `P = {p1, p2, ⋯, p_n}` : n개의 프로세스  
      ![image](https://user-images.githubusercontent.com/61646760/227473801-17b148ea-9b66-438a-96ef-da4fe7f87c97.png)
    - `R = {r1, r2, ⋯, r_m}` : m개의 자원  
      ![image](https://user-images.githubusercontent.com/61646760/227473902-8bc8dd8f-9b59-4da3-b32f-2af14aedfa07.png)
  - E : 방향 있는 간선의 집합 (`E = Q∪S`)
    - `Q = {(pi,rj): pi∈P, rj∈R}` : 프로세스 pi가 자원 rj를 요구  
      ![image](https://user-images.githubusercontent.com/61646760/227473456-a2b40379-34a7-4ac2-a97c-0524684852d6.png)
    - `S = {(rj,pi): rj∈R, pi∈P}` : 자원 rj가 프로세스 pi에 할당  
      ![image](https://user-images.githubusercontent.com/61646760/227473543-70186f45-f4c7-4aca-889c-259370743b8d.png)
- 자원할당 그래프 예
  - 정점의 집합 (`V = P∪R`)
    - 프로세스 집합 P = {p1, p2, p3}
    - 자원 집합 R = {r1, r2, r3}
  - 방향 있는 간선의 집합 (`E = Q∪S`)
    - 요구간선 집합 Q = {(p1,r2)}
    - 할당간선 집합 S = {(r1,p1), (r2,p2), (r3,p3)}  
      ![image](https://user-images.githubusercontent.com/61646760/227474593-265099ab-84f9-49e8-b661-e0a59957f1e1.png)
- 자원할당 그래프의 변화
  - p2가 r3를 요구하는 경우
    - 요구간선 (p2,r3) 추가
    - 가용한 단위자원 존재하면 할당간선 (r3,p2)로 바꿈  
      ![image](https://user-images.githubusercontent.com/61646760/227475608-253fd5f5-12b0-4a74-a12a-eb02a1674bab.png)
      - 즉 (p2,r3) 간선이 추가되었다가, r3의 단위자원 개수가 2라 할당이 가능하므로, (p2,r3)는 없어지고 (r3,p2) 간선이 생김 (상기 그림은 중복 표시)
- 교착상태의 필요조건 표현  
  ![image](https://user-images.githubusercontent.com/61646760/227476560-07d5b352-3dfc-44be-a0be-4e4deae05a32.png)
  - 상호배제 : 하나의 할당간선
    - r3는 단위자원 개수가 2이므로 문제 없음
  - 점유대기 : 한 프로세스에 할당간선과 요구간선 연결
    - p1, p2는 할당간선, 요구간선 동시에 연결됨
  - 비선점 : 요구간선
  - 환형대기 : 사이클(cycle)
    - p1, p2가 사이클을 형성함
    - 사이클 없음 → 교착상태 없음
    - 사이클 있음 → 교착상태 발생 가능
- 교착상태와 교착상태가 아닌 예
  - 교착상태  
    ![image](https://user-images.githubusercontent.com/61646760/227477211-8d657023-3491-4889-8b8b-b6ca2cdf2901.png)
  - 교착상태 아님  
    ![image](https://user-images.githubusercontent.com/61646760/227477329-598a718c-d0ed-4f2d-ad33-4932575b5efa.png)
    - r1의 단위자원 개수가 2이므로 두 개의 p에 할당해도 무방함
- 교착상태의 처리기법
  - 교착상태 예방
    - 교착상태의 네 가지 필요조건이 동시에 만족되는 것을 피하여 교착상태가 발생하지 않도록 하는 방법
  - 교착상태 회피
    - 프로세스에 필요한 자원의 최대량에 대한 정보를 이용하여 교착상태가 발생하지 않도록 하는 방법
  - 교착상태 탐지 및 복구
    - 교착상태의 발생 여부를 조사하여 발생한 경우에는 적절한 조치를 취해 정상상태로 복구하는 방법
### 교착상태 예방
- **상호배제 조건 제거**
  - 공유할 수 있는 자원 : 상호배제 필요 없음
    - `예) 읽기 전용 파일`
  - 공유할 수 없는 자원 : 반드시 상호배제 필요
    - `예) 프린터`
  - 상호배제 조건 제거로 **교착상태 예방은 불가능**
- **점유대기 조건 제거**
  - 자원을 점유했을 때 대기하지 않아야 함
    - 프로세스가 앞으로 필요한 모든 자원을 처음에 한꺼번에 요구하여 할당받음
    - 자원이용률 낮아짐, 기아상태 가능
  - 대기할 때 자원을 점유하고 있지 않아야 함
    - 새로운 자원을 요구할 때 할당받았던 자원을 모두 해제
    - 점유 도중 해제할 수 없는 자원에는 적용 불가
- **비선점 조건 제거**
  - 선점이 가능하도록 해야 함
    - 자원의 특성에 따라 불가능한 경우 존재
    - `예) 프린터`
  - 다른 프로세스가 대기할 가능성 줄이기
    - 점유대기 상황이 발생하면 할당받았던 자원을 모두 해제
    - 프린터 같은 자원에는 적용 불가
- **환형대기 조건 제거**
  - 모든 자원에 일련번호를 지정
    - 함수 f:R→N (R: 자원 집합, N: 자연수 집합)
      - ri≠rj이면 f(ri)≠f(rj)
  - 방법1
    - 프로세스는 자원을 요구할 때 **일련번호 기준으로 항상 오름차순이 되도록 요구**
    - 가장 최근에 할당받은 자원이 ri이면 다음에 요구할 자원 rj는 f(ri)<f(rj) 만족
  - 방법2
    - 프로세스가 자원을 요구할 때 **그보다 일련번호가 작은 자원만 점유**하도록 함
    - 자원 rj 요구하려면 **점유 중인 자원 중 f(rj)≤f(ri)인 자원 ri는 모두 해제**
  - 점유대기 중인 프로세스는 **점유 중인 자원의 일련번호보다 대기 중인 자원의 일련번호가 큼**
    - 환형대기 발생 불가능!
  - 프로세스마다 요구순서가 다를 수 있어 **자원의 일련번호 설정 어려움**
  - 요구순서가 일련번호 오름차순을 못 지키면 점유자원 해제 필요하나 **적용 불가한 자원 존재**

## 7강. 교착상태 II
### 교착상태 회피
- **교착상태 회피(Deadlock avoidance)**
  - 프로세스의 자원 사용에 대한 사전 정보를 활용하여 교착상태가 발생하지 않는 상태에 머물도록 하는 방법
  - 사전 정보
    - 현재 할당된 자원
    - 가용상태의 자원
    - 프로세스들의 최대 요구량
- **안전상태(safe state)**
  - 교착상태를 회피하면서 각 프로세스에 그들의 최대 요구량까지 빠짐없이 자원을 할당할 수 있는 상태
  - **안전순서열이 존재**하는 경우
    - **교착상태가 발생하지 않음**
- **불안전상태(unsafe state)**
  - **안전순서열이 존재하지 않는 경우**  
    ![image](https://user-images.githubusercontent.com/61646760/230623515-f2d5f4da-e3f2-46f0-b91f-85bdf0864bb6.png)
- **안전순서열(safe sequence)**
  - 순서 있는 프로세스의 집합 <p1, p2, ⋯, pn>
  - 각 p_{i}에 대해, p_{i}가 추가로 요구할 수 있는 자원의 양이 **현재 가용상태의 자원으로 충당**되거나, 혹은 여기에 **p_{j}(단, j<i)에 할당된 자원까지 포함하여 충당 가능**한 경우  
    ![image](https://user-images.githubusercontent.com/61646760/230624072-16378958-18b9-4b71-ae19-8970ca4f57bd.png)
    - 총 3개의 프로세스(p1, p2, p3)와 단위자원의 개수가 8인 1개의 자원(r1)
      - 사전 정보 : 프로세스 종료를 위해 필요한 총 자원 = 최대요구량
  - 시각 T1  
    ![image](https://user-images.githubusercontent.com/61646760/230624684-4e8c1929-fe6b-4603-8a3e-886aa097ea7a.png)
    - 단위자원 할당 상황을 보니 p2는 1개, p3는 5개의 단위자원을 할당받음
      - 가용자원은 8-6=2개
      - 종료되기까지 필요한 단위자원은 최대요구량이므로, p1(5개 더), p2(1개 더), p3(3개 더) 각각 추가적인 단위자원이 필요함
    - 안전순서열은 어떻게 구할까? (미래에 발생 가능한 요구 상황 고려한 것)
      - 현재 가용자원은 2개인데, p_{j}는 없는 상황
      - 따라서 2개의 가용자원으로 충당할 수 있는 프로세스를 찾아야 함
        - **p2**가 안전순서열의 **첫 번째** 프로세스!!
      - p2가 1개의 추가적인 단위자원을 받아 프로세스 처리 후 종료
      - p2가 종료되면 가용자원은 3(기존 가용자원 2 + p2가 할당받았던 단위자원 1)이 됨
      - p3는 단위자원 3만 있으면 처리가 가능함
        - **p3**가 안전순서열의 **두 번째** 프로세스!!
      - p3가 3개의 추가적인 단위자원을 받아 프로세스 처리 후 종료
      - p3가 종료되면 가용자원은 8이 됨
      - 남은 것은 p1뿐이므로, p1이 5개의 추가적인 단위자원을 받아 프로세스 처리 후 종료
        - **p1**이 안전순서열의 **세 번째** 프로세스!!
      - 안전순서열 : **<p2, p3, p1>**
        - 안전순서열이 존재함 ⇒ 안전상태
  - 시각 T2  
    ![image](https://user-images.githubusercontent.com/61646760/230626748-55de2b65-da5b-4a54-a371-72a224889338.png)
    - 시간이 흘러 T2 시점에 p1이 1개의 단위자원을 요구하는 상황이 발생
      - 가용자원이 2개이니 충분히 할당 가능함
    - **p1에 1개의 단위자원을 할당한 경우**  
      ![image](https://user-images.githubusercontent.com/61646760/230627094-cd463c4a-2089-41e1-a959-0806bd0fed33.png)
      - 가용자원은 1이고, 각각의 프로세스는 종료까지 p1(4개), p2(1개), p3(3개)만큼 단위자원이 더 필요함
      - 이 상황에서도 안전순서열이 존재할까?
        - 가용자원 1로 해결 가능한 프로세스는 p2
          - p2가 안전순서열의 첫 번째 프로세스!!
        - p2 처리 후 종료되면 가용자원은 2
        - p1은 4개, p3는 3개가 필요한 상황이므로 가용자원 2로 처리 가능한 프로세스가 없음
          - 안전순서열은 **<p2, X>로, 안전순서열을 만들 수 없음** = 불안전상태
      - p1에 가용자원 1개를 할당한 순간 교착상태에 빠질 가능성이 있음
        - 할당하지 않음으로써 교착상태 회피
    - **p1에 1개의 단위자원을 할당하지 않는 경우**  
      ![image](https://user-images.githubusercontent.com/61646760/230628008-d6ae4d95-07d5-42b7-a27e-8a9499b356be.png)
      - 안전순서열 : **<p2, p3, p1>** = 안전상태
    - 운영체제 입장에서는 **p1에 단위자원을 할당할 수도 있지만, 안전상태 유지를 위해 할당하지 않는 것(회피)을 택함**
- 교착상태와 안전상태
  - 교착상태는 불안전상태에서만 발생 가능
  - **항상 안전상태를 유지**해야 함
  - **프로세스가 가용상태의 자원을 요구하더라도 (운영체제는 자원을 할당하지 않고) 프로세스는 대기상태가 될 수 있음**
    - 자원 이용률은 다소 낮아질 수 있음
      - 실제 쓸 수 있는 자원임에도 이용 못 할 수가 있기 때문임
#### 교착상태 회피 알고리즘
- **교착상태 회피 알고리즘(Deadlock avoidance algorithm)**
  - 각 자원의 단위자원이 하나밖에 없는 경우
    - 변형된 자원할당 그래프 이용
  - 각 자원의 단위자원이 여러 개일 수 있는 경우
    - 은행원 알고리즘 이용
- 각 자원의 단위자원이 하나밖에 없는 경우
  - **변형된 자원할당 그래프(Resource-allocation graph)**
    - 자원 정점에 표시하던 단위자원의 개수 제거
    - **선언간선**=**예약간선(claim edge) (p_{i}, r_{j}) 추가**  
      ![image](https://user-images.githubusercontent.com/61646760/230630656-30c9c0c1-755e-4294-af3a-c891221cc036.png)
      - 앞으로 프로세스 pi가 자원 rj를 요구하게 될 것임(즉, 각각의 프로세스가 종료시까지 추가적으로 필요한 자원을 의미함)
      - 요구간선(request edge)과 구분을 위해 점선으로 표시  
        ![image](https://user-images.githubusercontent.com/61646760/230632063-def7c0a6-62e0-4e1d-862c-08514381340b.png)
        - p1, p2 2개의 프로세스와 r1, r2 2개의 자원이 있음
        - 단위자원이 하나뿐이므로 r 위의 개수 생략
        - r1에서 p1으로 할당간선, p2에서 r1으로 요구간선이 있음
        - p1이 나중에 r2를 요구할 수 있고, p2도 나중에 r2를 요구할 수 있다는 선언간선
    - 자원을 요구받으면 해당 선언간선을 요구간선으로 변경
    - 그 요구간선을 할당간선으로 변환해도 **사이클이 생기지 않는 경우에만 자원을 할당하고 할당간선으로 변환**  
      ![image](https://user-images.githubusercontent.com/61646760/230632437-8225fcae-720a-4ae3-ab45-769b31a30795.png)
      - p1이 r2를 요구하는 경우
        - 선언간선 (p1, r2)를 실선(요구간선)으로 변환 가능
        - r2는 할당된 곳이 없으므로 p1에게 할당 가능함
        - r2를 p1에 할당했다고 쳐도 사이클이 형성되지 않음
        - 안전상태가 유지되므로 r2를 p1에 할당
      - p2가 r2를 요구하는 경우
        - r2는 할당된 곳이 없으므로 p2에게 할당 가능함
        - r2를 p2에 할당하면 사이클이 형성됨(r1 → p1 → r2 → p2 → r1)
        - (현재는 아니지만) 불안전상태가 될 가능성이 있으므로(p1 → r2가 요구간선으로 바뀌는 경우) 할당하지 않음
- 각 자원의 단위자원이 여러 개일 수 있는 경우
  - **은행원 알고리즘(Banker's algorithm)**
    - 자원을 요구받으면 그 자원을 할당해 주고 난 후의 상태를 계산해서 그것이 안전상태인지 확인
    - 안전상태가 보장되는 경우에만 자원을 할당  
      ![image](https://user-images.githubusercontent.com/61646760/230634277-12fff932-89e7-47f0-bd80-1608ee945f47.png)
      - `MAX` : p의 최대요구 변수
      - `ALLOC` : p의 할당자원 변수
      - `NEED` : p의 추가요구 변수
      - `AVAIL` : 가용자원 변수
    - 시각 T0  
      ![image](https://user-images.githubusercontent.com/61646760/230635142-f9349b14-d865-4bbb-b36b-90f2a87f4364.png)
      - 은행원 알고리즘은 자원 요구가 있을 때, **요구를 들어줘도 안전상태가 유지되는지 체크하는 안전 알고리즘(safety algorithm)을 사용**함
      - 현 시점이 안전상태가 맞는지 안전 알고리즘을 돌려 보자면,
        - 가용자원(`AVAIL`)은 r1 3개, r2 3개로 (3,3)인데, 이를 `WORK`라는 새로운 변수에 옮겨 계산
        - 추가로 필요한 자원(`NEED`)을 체크해서, 종료 가능한 프로세스 파악
          - p2의 NEED가 (2,1)이므로 할당
          - p2가 종료되면 p2에 할당되어 있던 (1,5)의 자원(`ALLOC`)이 가용자원(`AVAIL`)에 더해져 (4,8)이 됨
          - p2의 FINISH(2)는 false에서 true가 됨
          - **p2**가 안전순서열의 **첫 번째** 프로세스!!
        - 가용자원 (4,8)로 처리 가능한 프로세스는 p3
          - 처리 후 `ALLOC`을 더하면 가용자원 `AVAIL`은 (8,9)가 됨
          - p3의 FINISH(3)는 false에서 true가 됨
          - **p3**가 안전순서열의 **두 번째** 프로세스!!
        - 마지막 p1 처리
          - p1의 FINISH(1)는 false에서 true가 됨
          - **p1**가 안전순서열의 **세 번째** 프로세스!!
        - `AVAIL`은 (8,11)이 됨
          - 안전순서열 : <p2, p3, p1>
    - 시각 T1  
      ![image](https://user-images.githubusercontent.com/61646760/230636766-03c86964-12c3-4a8e-9b14-c0de9c450e01.png)
      - 시각 T1에 p1이 (1,1)이라는 요구 REQ1를 하면,
        - 가용자원은 (3,3)이므로 할당은 가능함
          - 불안전상태가 되진 않은지 상태 계산(안전 알고리즘)이 필요함
        - 할당해 줬다고 가정하면 `ALLOC1`은 (1,3), `NEED1`은 (6,2), `AVAIL`은 (2,2)가 됨
          - 현재의 `AVAIL`인 (2,2)를 `WORK` 값으로 할당
        - (2,2)로 처리 가능한 프로세스는 p2뿐이므로 p2에 할당
          - p2가 처리되면 `WORK` (2,2)는 `ALLOC2`를 더해 (3,7)이 됨
        - (3,7)로 처리 가능한 프로세스???? 없음
          - 안전순서열이 존재하지 않는 불안전상태가 됨
        - REQ1은 할당하지 않아야 함!
      - 시각 T1에 p3가 (1,1)이라는 요구 REQ3를 하면,
        - 가용자원은 (3,3)이므로 할당은 가능함
          - 불안전상태가 되진 않은지 상태 계산(안전 알고리즘)이 필요함
        - 할당해 줬다고 가정하면 `ALLOC3`은 (5,2), `NEED3`은 (3,6), `AVAIL`은 (2,2)가 됨
          - 쭉 하면 안전순서열이 <p2, p3, p1>이 됨
        - REQ3는 할당!
### 교착상태 탐지 및 복구
- 사후에 처리하는 방법
  - 교착상태 탐지
    - 시스템의 교착상태 여부를 조사하기 위해 **주기적으로 상태 조사 알고리즘 수행**
  - 교착상태 복구
    - 교착상태가 탐지된 경우 적절한 조치를 취해 **정상상태로 복구**
- **교착상태 탐지(deadlock detection)**
  - **쇼샤니-코프만 알고리즘(Shoshani and Coffman algorithm)**
    - 안전 알고리즘과 유사한 방식으로 동작
      - 다만 안전 알고리즘이 미래 상황을 체크한다면, 쇼샤니-코프만 알고리즘은 현재 상태의 교착 여부를 판별
      - 현재 할당된 `ALLOC`과 요구 `REQ`, `AVAIL`만 알면 됨
    - 교착상태 아님  
      ![image](https://user-images.githubusercontent.com/61646760/230921488-6d562cba-64ee-46e9-9266-59951c34641d.png)
      - `AVAIL` 값을 `WORK` 변수에 대입
      - 자원을 할당받은 프로세스에 대해서만 `FINISH[1]=false`
        - 할당받은 게 없는 프로세스는 굳이 false를 세팅하지 않음
      - (3,3)으로 처리 가능한 프로세스 p2(`REQ=(0,3)`)를 먼저 처리
      - p2의 `ALLOC`인 (1,5)가 더해져 `WORK`는 (4,8)이 됨
      - `REQ1` 처리한 뒤 `ALLOC1`을 받아 `WORK`는 (4,10)이 됨
      - 마지막으로 `REQ3` 처리한 뒤 `ALLOC3`을 받아 `WORK`는 (8,11)이 됨
        - 교착상태 아님!!!
    - 교착상태 탐지  
      ![image](https://user-images.githubusercontent.com/61646760/230924710-f728bed1-fea1-4fe6-bf7d-f9a0be6e8289.png)
      - `REQ1`이 (5,6)이면? 알고리즘을 동작시켜 본다면
      - P2 처리 → `WORK`(4,8)
      - `REQ1`, `REQ3` 모두 해소 불가
        - p1과 p3는 false로 남아 있을 수밖에 없음
        - 교착상태!!!
    - 시간 복잡도 : 𝑶(𝒎𝒏²)
      - 자원의 종류 𝒎개
      - 시간이 오래 걸리는 알고리즘
    - 알고리즘 수행 시점
      - 즉시 받아들일 수 없는 자원 요구가 있을 때
      - 정해진 시간 간격
      - CPU 효율이 일정 수준 이하로 떨어질 때
        - 즉, 드문드문 돌림
- **교착상태 복구(deadlock recovery)**
  - 교착상태가 탐지되면 복구 조치
  - 복구의 주체
    - 오퍼레이터 : 수작업으로 복구
    - 운영체제 : 자동으로 복구
  - 복구 방법
    - 교착상태 프로세스를 종료
      - false인 프로세스
    - 교착상태 프로세스가 할당받은 자원을 해제
  - **교착상태 프로세스를 종료**
    - 모든 교착상태 프로세스를 종료
      - 단점 : 진행했던 내용에 대한 복원비용이 큼 (내용이 전부 사라지므로)
    - 사이클이 제거될 때까지 교착상태 프로세스를 하나씩 종료
      - 단점 : 종료 대상을 선택하기 위한 비용, 매 프로세스 종료 후 교착상태 재확인을 위한 비용
  - **교착상태 프로세스가 할당받은 자원을 해제**
    - 사이클이 제거될 때까지 할당된 자원을 단계적으로 선점하여 다른 프로세스들에 할당
    - 프로세스와 자원 선택 기준
      - 프로세스 진척도, 사용 중인 자원의 수 등
        - `예) 95% 진행된 프로세스보다 5% 진행된 프로세스를 선택해서 빼는 게 나음`
    - 프로세스의 복귀 시점도 제반 요소를 고려하여 결정
    - 기아상태에 빠지지 않도록 프로세스 선택 시 복구 횟수 고려
      - 특정 프로세스만 자꾸 선택돼서 처리되지 못하는 경우

## 8강. 메모리 관리
### 프로세스와 메모리
- 프로세스의 동작
  - 프로그램 카운터(PC)를 참조하여 수행될 명령을 메모리에서 읽어 CPU로 수행하는 것  
    ![image](https://user-images.githubusercontent.com/61646760/230817019-cb02c467-8e47-49ac-893a-09069b315479.png)
- 기억장치 계층구조
  - 적절한 비용으로 높은 성능을 냄  
    ![image](https://user-images.githubusercontent.com/61646760/230817168-353e3437-01f1-4d54-9407-722d36b2eac8.png)
    - 레지스터 → 캐시 메모리 → 메모리 → 보조 기억장치 순서
- 메모리 관리
  - **메모리 호출**
    - 언제 새로운 프로세스를 메모리에 둘 것인가?
  - **메모리 배치**
    - 다음에 실행될 프로세스를 메모리 내의 어느 곳에 둘 것인가?
  - **메모리 교체**
    - 메모리가 꽉 찬 상태에서 새로운 프로세스를 메모리에 적재해야 한다면 어떤 프로세스를 제거할 것인가?
  - 그 외
    - 고정/동적 분할
    - 고정/유동 적재영역 등
### 단일 프로그래밍 환경
- **단일 프로그래밍(Uniprogramming)**
  - 하나의 프로세스만 메모리를 전용으로 사용하는 것  
    ![image](https://user-images.githubusercontent.com/61646760/230817558-34b074bb-960f-4369-8ec2-602ec0c24813.png)
    - **연속 메모리 할당** : 프로세스는 하나의 연속된 블록으로 메모리에 할당
- 단일 프로그래밍의 문제점
  - 메모리의 용량을 초과하는 프로세스는 실행 못함
  - 메모리 낭비 심함
    - 지속적으로 사용되지 않는 프로세스도 메모리에 계속 적재
  - 주변장치 등 자원의 낭비 심함
    - 계산 위주의 사용자 프로세스  
      ![image](https://user-images.githubusercontent.com/61646760/230817858-347ace07-11d4-4888-be87-23855815dffe.png)
      - 연산하는 동안 I/O 놀게 됨
    - 입출력 위주의 사용자 프로세스  
      ![image](https://user-images.githubusercontent.com/61646760/230817929-5f2897cf-9262-430b-9f85-fd67cc8c5581.png)
### 다중 프로그래밍 환경
- **다중 프로그래밍(Multi-programming)**
  - 여러 개의 프로세스가 메모리에 동시에 적재되는 것  
    ![image](https://user-images.githubusercontent.com/61646760/230818081-cc6e9a08-1334-4df7-9946-f8e9c82f18d9.png)
    - **CPU 연산과 입출력을 동시**에 함으로써 CPU 이용도와 시스템 처리량 증가  
      ![image](https://user-images.githubusercontent.com/61646760/230818164-3b252ab1-8452-4629-8314-796fd01c069e.png)
- 메모리 분할
  - 여러 개의 프로세스를 메모리에 적재하기 위해 고안된 방법
  - 하나의 분할에 하나의 프로세스가 적재되는 방식
  - 종류 : 고정 분할, 동적 분할
- **고정 분할(Fixed partition)**
  - 고정 분할 다중 프로그래밍(FPM)
  - 메모리를 여러 개의 고정된 크기의 영역으로 분할
  - **프로세스 배치 방법1**  
    ![image](https://user-images.githubusercontent.com/61646760/230818613-409f2243-a77c-48ee-9725-7937951eed41.png)
    - 분할영역마다 큐를 두고 큐에 들어온 프로세스는 해당 분할영역에만 적재
    - 절대 번역 및 적재
      - 어느 분할영역에 적재할지 주소 등이 사전에 정해져 있음
    - 효율성 낮음
  - **프로세스 배치 방법2**  
    ![image](https://user-images.githubusercontent.com/61646760/230910949-d8bf70ea-e1fb-4a68-ab08-27b29935b3d7.png)
    - 하나의 큐만 두고 큐에 들어온 프로세스는 어느 분할영역에든 적재
    - 재배치 가능 번역 및 적재
      - 주소 값 변경 가능함
    - 복잡함
  - 문제점 : **내부 단편화(internal fragmentation)**  
    ![image](https://user-images.githubusercontent.com/61646760/230912187-9416baa9-c318-4c57-b214-f2de1c2f472d.png)
    - 프로세스의 크기가 적재된 분할영역의 크기보다 작아서 **분할영역 내에 남게 되는 메모리** 발생
    - 수행할 프로세스의 **크기를 미리 알고 그에 맞춰 고정 분할**을 해야 함
    - 현실적이지 못함
- **동적 분할(Dynamic partition)**
  - 메모리의 분할경계가 고정되지 않음
  - 각 프로세스에 필요한 만큼의 메모리만 할당  
    ![image](https://user-images.githubusercontent.com/61646760/230912751-caf598e5-4f18-48cb-9b08-3eb59ed6226d.png)
  - 문제점 : **외부 단편화(external fragmentation)**  
    ![image](https://user-images.githubusercontent.com/61646760/230912928-34496a68-4c35-426f-8a26-7c7c94c7963c.png)
    - 메모리의 할당과 반환이 반복됨에 따라 **작은 크기의 공백이 메모리 공간에 흩어져 생김**
    - 해결 방법 : 통합, 집약
  - **통합(coalescing)**
    - 인접된 공백을 더 큰 하나의 공백으로 만들어 외부 단편화 해결  
      ![image](https://user-images.githubusercontent.com/61646760/230913313-bb103031-8609-477a-a0e5-8c0392a85df8.png)
      - 서로 인접한 두 공백(프로세스 B, C 자리)을 합쳐서 7MB짜리 하나의 공백으로 만듦
  - **집약(compaction)**
    - 메모리 내의 모든 공백을 하나로 모아 외부 단편화 해결  
      ![image](https://user-images.githubusercontent.com/61646760/230913389-8dc41424-0557-4193-bb36-25a5d4a3e4a8.png)
      - 서로 떨어져 있는 공백들(프로세스 B, D 자리 등)을 합쳐서 32MB짜리 하나의 공백으로 만듦
- **메모리 보호(Memory protection)**
  - 프로세스가 다른 할당영역을 침범하지 않게 하는 것
  - **하한-상한** 또는 **하한-크기 레지스터 쌍**으로 제한
  - 이 제한 넘어 운영체제 호출하려면 **시스템 호출** 이용  
    ![image](https://user-images.githubusercontent.com/61646760/230914167-a8d79db8-c114-4f1b-9c6c-a5ba1b03cedf.png)
### 메모리 배치기법
- **메모리 배치기법(memory placement strategies)** = 기억장치 배치전략
  - 동적 분할 다중 프로그래밍에서 새로 반입된 프로그램이나 데이터를 **메모리의 어느 위치에 배치할 것인가**를 결정  
    ![image](https://user-images.githubusercontent.com/61646760/230918880-4f350004-8e4c-4ca2-a8b8-6e39a6e9ddc6.png)
  - 종류
    - 최초 적합
    - 후속 적합
    - 최적 적합
    - 최악 적합
- **최초 적합(first-fit)**
  - 프로세스가 적재될 수 있는 빈 공간 중에서 가장 먼저 발견되는 곳을 할당  
    ![image](https://user-images.githubusercontent.com/61646760/230919927-5d89781f-522d-425b-a65e-2d691e93187a.png)
- **후속 적합(next-fit)**
  - 최초 적합의 변형
  - 이전에 탐색이 끝난 그다음 부분부터 시작하여 사용 가능한 빈 공간 중에서 가장 먼저 발견되는 곳을 할당  
    ![image](https://user-images.githubusercontent.com/61646760/230920173-653c908b-bc00-4747-a7ae-6c31d2e99817.png)
- **최적 적합(best-fit)**
  - 필요한 공간을 제공할 수 있는 빈 공간 중 가장 작은 곳을 선택하여 할당
  - 큰 빈 공간을 최대한 많이 남겨 놓기 위한 방법  
    ![image](https://user-images.githubusercontent.com/61646760/230920322-0170df48-a0e1-49a5-bfdb-5d2e3fccd6ec.png)
- **최악 적합(worst-fit)**
  - 필요한 공간을 제공할 수 있는 빈 공간 중 가장 큰 곳을 선택하여 할당
  - 작은 자투리가 남아 사용되지 못하는 공간이 발생하는 것을 최소화하기 위한 방법  
    ![image](https://user-images.githubusercontent.com/61646760/230920494-33607e45-f2c9-4e64-8880-43a443c811d7.png)

## 9강. 가상 메모리
### 가상 메모리의 개념
- 연속 메모리 할당
  - 메모리 크기보다 더 큰 기억공간이 필요한 프로세스는 실행 불가
- **가상 메모리(virtual memory)**
  - 메모리 크기보다 더 큰 기억공간이 필요한 프로세스도 실행할 수 있게 하는 방법
  - 현재 필요한 일부만 메모리에 적재  
    ![image](https://github.com/Esantomi/knou/assets/61646760/d3827712-e643-4ca2-817d-dde6c657d75e)
- **사상(mapping)**
  - 프로세스 실행을 위해 가상주소를 실주소로 변환하는 과정
  - **동적 주소변환(DAT, Dynamic Address Translation)**
    - 프로세스가 실행되는 동안 사상
  - 인위적 연속성
    - 가상주소 공간에서 연속적인 주소가 실주소 공간에서도 연속적일 필요는 없음  
      ![image](https://github.com/Esantomi/knou/assets/61646760/b97811c3-89ef-4d1b-8444-2c69be9c6f40)
### 블록 단위 주소변환
- **주소변환(Address Translation)**
  - 동적 주소변환을 위한 정보를 가진 표인 **주소변환 사상표**를 이용
  - 주소변환이 바이트나 워드 단위로 이루어지면 변환에 필요한 정보량이 너무 많아 비효율적임  
    ![image](https://github.com/Esantomi/knou/assets/61646760/f6860875-8800-4db9-840a-d3c779a181e8)
- **블록 사상 시스템(Block mapping system)**
  - 블록 단위로 주소변환
  - 가상 메모리의 각 블록이 메모리의 어디에 위치하는지 관리
  - 가상주소 `𝒗 = (𝒃, 𝒅)`
    - `𝒃` : 블록 번호
    - `𝒅` : 블록의 시작점으로부터의 변위  
      ![image](https://github.com/Esantomi/knou/assets/61646760/587e401d-f12f-4ba8-91ab-1fa16da479a3)
  - 블록의 크기는 적절히 정해야 함
    - 크기가 커지면 사상표 크기 감소, 블록 전송 시간 증가, 동시 적재 프로세스 수 감소
    - 크기가 작아지면 사상표 크기 증가, 블록 전송 시간 감소, 동시 적재 프로세스 수 증가
#### 페이지, 세그먼트
- 블록 구성 방식
  - **페이지(page)** : 블록의 크기가 모두 동일
  - **세그먼트(segment)** : 블록의 크기가 다를 수 있음
- **페이징(paging) 기법**
  - 가상 메모리를 페이지 단위로 나누어 관리하는 기법
  - 메모리 영역도 페이지와 동일한 크기의 페이지 프레임으로 나눔
    - 페이지 프레임 : 페이지를 담을 수 있는 틀  
      ![image](https://github.com/Esantomi/knou/assets/61646760/21f2ce0c-b23c-48b8-a517-9583e4c8e006)
  - **페이지 사상표(page table)**
    - 가상주소를 실주소로 동적 변환할 수 있게 함
    - 페이지 번호에 대한 페이지 프레임 번호 저장  
      ![image](https://github.com/Esantomi/knou/assets/61646760/6cd7a980-ffde-49c7-a4f1-8735d48dc488)  
      ![image](https://github.com/Esantomi/knou/assets/61646760/32f9b2a2-1e5c-49f1-a854-82712199949c)
  - **직접 사상에 의한 동적 주소변환**
    - 페이지 사상표를 직접 이용  
      - ![image](https://github.com/Esantomi/knou/assets/61646760/c0540458-1f20-48f5-a483-5409e393d6ac)
  - **연관 사상에 의한 동적 주소변환**
    - 페이지 변환 정보를 연관 메모리에 저장한 연관 사상표를 이용  
      ![image](https://github.com/Esantomi/knou/assets/61646760/2dcf47f5-ca3d-4049-93c5-990a2a2f4169)
  - **연관/직접 사상에 의한 동적 주소변환**
    - 연관 사상표에는 가장 최근에 참조된 페이지만 보관
    - 연관 사상표에 없을 때만 직접사상 이용  
      ![image](https://github.com/Esantomi/knou/assets/61646760/3d6fbdb7-cceb-4aba-a1f6-e8e3b1c8401b)
- 페이징 기법의 특징
  - 논리적 의미와 무관한 동일 크기 페이지로 나눔
  - 메모리 보호는 페이지 단위로 이루어짐
  - 외부 단편화가 발생하지 않고, 내부 단편화는 발생 가능함
- **세그먼테이션(segmentation) 기법**
  - 가상 메모리를 세그먼트 단위로 나누어 관리하는 기법
    - 세그먼트 : 논리적 의미에 부합하는 다양한 크기의 블록
  - '**세그먼트 사상표(segement table)**'를 이용하여 동적 주소변환  
    ![image](https://github.com/Esantomi/knou/assets/61646760/b9b29ee9-791a-43d9-ba9e-7fcd153e6961)  
    ![image](https://github.com/Esantomi/knou/assets/61646760/5f85ad7f-299a-4a7d-8cd4-abb71dcf0bd2)
    - 세그먼트 번호에 대한 실주소에서의 시작 위치 저장
    - 세그먼트 길이는 오버플로 확인용
  - 동적 주소변환  
    ![image](https://github.com/Esantomi/knou/assets/61646760/ee7be4db-5dd7-4c6e-91a3-8a327b0f7929)
- **페이징-세그먼테이션 혼용기법**
  - 세그먼테이션 기법의 논리적 장점 + 페이징 기법의 메모리 관리 측면의 장점
  - 가상 메모리를 세그먼트 단위로 분할 후 각 세그먼트를 다시 페이지 단위로 부활
  - 메모리는 다시 페이지 단위로 분할
  - 메모리는 페이지 프레임으로 분할
  - 가상 주소 `𝒗 = (𝘀, 𝗽, 𝒅)`  
    ![image](https://github.com/Esantomi/knou/assets/61646760/ec1f460b-f1ba-4521-8db7-a86a394cce5a)
### 메모리 호출기법
- 메모리 호출기법
  - 어느 시점에 페이지 또는 세그먼트를 메모리에 적재할 것인가를 결정하는 기법
  - 페이징 기법에서의 호출기법 종류
    - 요구 페이지 호출기법
    - 예상 페이지 호출기법
- **요구 페이지(demanding page) 호출기법**
  - 프로세스의 페이지 요구가 있을 때 요구된 페이지를 메모리에 적재하는 방법
  - 특징
    - 옮길 페이지 결정에 대한 오버헤드 최소화
    - 적재된 페이지는 실제로 참조됨
    - 프로세스 시작 시점에는 연속적으로 페이지 부재 발생
- **예상 페이지(prepaging) 호출기법**
  - 곧 사용될 것으로 예상되는 페이지를 미리 메모리에 적재하는 방법
  - 특징
    - 예상이 잘못된 경우 시간과 메모리 공간 낭비
    - 프로세스 시작 시점에 적용하면 성능이 개선됨

## 10강. 페이지 교체 알고리즘
### 페이지 교체 알고리즘
- **페이징(paging) 기법**
  - 모든 페이지 프레임이 사용되고 있을 때 새로 적재되어야 할 페이지를 위해 적절한 교체 대상을 결정  
    ![image](https://github.com/Esantomi/knou/assets/61646760/1198f398-8dd2-47d8-bbf7-4b8e88371ef2)
    - `e'`은 정보가 약간 변경된 것을 의미함
- 교체 대상 선택
  - **최적화의 원칙**
    - 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체 대상으로 선택
    - 이론적으로 최적이나 미래를 예측할 수 없어 실현 불가능
  - 선택을 위한 기본 정책
    - 대체로 좋은 결론은 내리면서 선택을 위한 시간 및 공간 오버헤드가 적은 방법
  - 교체 제외 페이지
    - 페이징을 위한 커널 코드 영역
      - 페이징을 어떻게 처리할지에 관여하는 코드로, 교체하더라도 다음 순간 바로 다시 적재해야 함
    - 보조기억장치 드라이버 영역
    - 시간을 맞춰 동작해야 하는 코드 영역
    - 입출력장치를 위한 데이터 버퍼 영역 등
- **페이지 교체 알고리즘**
  - **FIFO 페이지 교체**
    - First-In FIrst-Out
    - 메모리 내에 가장 오래 있던 페이지를 선택하여 교체함
    - 구현 : FIFO 큐 이용  
      ![image](https://github.com/Esantomi/knou/assets/61646760/465a31b9-7c03-46ac-b438-7eeb822fae05)
    - 단점
      - 가장 많이 쓰이는 페이지를 교체시킬 가능성 있음
      - **Belady의 이상현상**
        - 프로세스에 더 많은 수의 페이지 프레임을 할당하면 오히려 페이지 부재가 더 많이 발생할 수 있는 현상  
          ![image](https://github.com/Esantomi/knou/assets/61646760/38de4f64-6124-450e-ba94-ef171aa78d0e)
  - **LRU 페이지 교체**
    - Least Recently Used
    - 메모리 내에서 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체함
    - 국부성 휴리스틱(locality heuristics)에 기반함
      - 최근의 상황이 가까운 미래에 대한 좋은 척도
      - 시간 국부성, 공간 국부성
        - `예) 반복문의 경우 코드가 거듭 반복되니 시간 국부성을, 반복문이 위치한 페이지가 거듭 반복되니 공간 국부성을 가짐`
    - 구현 : 참조시각 또는 리스트 이용
      - **참조시각을 이용한 구현**
        - 각 페이지가 참조될 때마다 그때의 시각을 테이블에 기록
        - 교체가 필요한 경우 참조시각이 가장 오래된 페이지를 선택하여 교체  
          ![image](https://github.com/Esantomi/knou/assets/61646760/663a8c48-63f5-4f65-83bb-733582ee7895)
      - **리스트를 이용한 구현**
        - 각 페이지가 참조될 때마다 리스트의 선두로 옮김
        - 교체가 필요한 경우 리스트의 끝에 있는 페이지를 선택하여 교체  
          ![image](https://github.com/Esantomi/knou/assets/61646760/a5f2170e-7449-433f-bdd0-9604efdc26a5)
    - 장점
      - Belady의 이상현상 발생하지 않음
      - 많은 경우 최적화 원칙에 근사한 선택 가능
    - 단점
      - 국부성이 맞지 않는 상황도 존재
      - 막대한 오버헤드
  - **LFU 페이지 교체**
    - Least Frequently Used
    - 메모리 내에서 참조된 횟수가 가장 적은 페이지를 선택하여 교체함
    - 구현 : 참조횟수 이용  
      ![image](https://github.com/Esantomi/knou/assets/61646760/a6ca31c2-edce-4079-a55d-82e0e19de136)
    - 단점
      - 가장 최근에 메모리로 옮겨진 페이지가 교체될 가능성 높음
      - 초기에 매우 많이 사용된 후 더 이상 사용되지 않는 페이지는 교체 가능성 낮음
      - 막대한 오버헤드
  - **2차 기회 페이지 교체**
    - 참조 비트가 0이면서 메모리 내에 가장 오래 있었던 페이지를 선택하여 교체함
    - 구현 : FIFO 큐와 참조 비트 이용
      - 각 페이지가 메모리에 적재될 때는 **참조 비트 0**
      - 적재된 상태에서 추가로 참조되면 **참조 비트 1**  
        ![image](https://github.com/Esantomi/knou/assets/61646760/34ba4c77-a080-4a00-bfbb-cc72468db454)
    - **참조할 페이지가 메모리에 없는 경우**
      - 빈 페이지 프레임이 있으면
        - 페이지 적재, 큐에 추가, 참조 비트는 0으로 설정
      - 빈 페이지 프레임이 없으면
        1. 큐의 선두 항목을 꺼내 참조 비트 조사
        2. 1이면 0으로 바꿔 큐의 뒤에 추가 후 1단계로 이동
        3. 0이면 교체 대상으로 선택하여 교체 
    - **참조할 페이지가 메모리에 있는 경우**
      - 큐 위치 변화 없이 참조 비트만 1로 설정
    - **큐를 이용한 구현**  
      ![image](https://github.com/Esantomi/knou/assets/61646760/05fdfe78-0e40-435b-8329-156c80cc3a1c)  
      ![image](https://github.com/Esantomi/knou/assets/61646760/e1ebf229-1106-4c28-b819-1852a0ce95d8)
    - 변형된 원형 큐를 이용한 구현 (**클럭 페이지 교체 알고리즘**)
      - 포인터는 마지막에 추가된 페이지의 다음 위치를 가리킴
        - 빈 페이지 프레임이 있는 경우 : 빈칸
        - 페이지 프레임이 꽉 찬 경우 : 큐의 선두  
          ![image](https://github.com/Esantomi/knou/assets/61646760/2dea0d53-5055-4502-86d6-9df9941cab4e)  
          ![image](https://github.com/Esantomi/knou/assets/61646760/3a8980b9-7951-4fb2-960d-8e5c1eb71906)
### 프로세스별 페이지 집합관리
- 프로세스별 페이지 집합
  - 프로세스마다 사용할 수 있는 페이지 프레임의 개수만큼 메모리에 유지되는 페이지 집합
  - 집합의 크기가 작을수록 시스템 처리량 증대
    - 각 프로세스별 페이지 부재는 자주 발생하여 성능 저하
  - 집합의 크기가 클수록 프로세스별 페이지 부재는 감소
    - 메모리에 적재될 수 있는 프로세스 수는 줄어듦
  - 각 프로세스가 사용할 수 있는 페이지 프레임 개수 관리
    - 워킹 세트 알고리즘, PFF 알고리즘
#### 워킹 세트 알고리즘
- **워킹 세트 모델(working set model)**
  - 페이지 부재 비율을 감소시키기 위해 Denning이 제안한 모델
- 프로세스의 워킹세트 𝑾(𝒕,𝜹)
  - 시각 𝒕에 𝒕를 포함한 직전 𝜹시간 동안 참조한 페이지의 집합  
    ![image](https://github.com/Esantomi/knou/assets/61646760/9bbdd22d-733e-49d7-8e06-5bcdfa539ca7)
- 프로세스가 수행됨에 따라 그 프로세스의 워킹 세트는 변할 수 있으며 워킹 세트의 크기도 달라질 수 있음
- 워킹 세트 알고리즘의 원칙
  - 프로세스의 워킹 세트를 메모리에 유지시키는 것
- 워킹 세트를 **메모리에 유지하지 않으면 쓰래싱 유발** 가능
  - **쓰래싱(thrashing)**
    - 페이지 부재가 비정상적으로 많이 발생하여 프로세스 처리보다 페이지 교체 처리에 너무 많은 시간을 소비하여 시스템의 처리량이 급감하는 현상
- 프로세스마다 워킹 세트 크기에 맞게 페이지 프레임 개수 조절
- 충분한 여분의 페이지 프레임이 존재하면?
  - 실행 프로세스 수 늘림
- 실행 중인 프로세스들의 워킹 세트 크기의 합이 총페이지 프레임 수를 넘어서면?
  - 우선순위가 낮은 프로세스를 일시 중지
- 문제점
  - 과거를 통해 미래를 예측하는 것이 정확하지 않음
    - 워킹 세트 알고리즘도 국부성을 활용하므로 항상 예측이 맞아떨어지지는 않음
  - 워킹 세트를 정확히 알아내고 계속 업데이트하는 것이 현실적으로 어려움
  - 워킹 세트 윈도 크기 𝜹의 최적값을 알기 어려우며 이 역시 변화할 수 있음
#### PFF 알고리즘
- 페이지 부재 빈도(PFF)를 이용하여 프로세스별 페이지 집합의 크기를 변화시키는 기법
- **PFF(Page Fault Frequency)**
  - 얼마나 자주 페이지 교체가 발생하는지를 나타내는 척도
  - 페이지 부재가 발생하면 직전 페이지 부재 이후로 경과된 시간의 역수
    - `예) 직전 부재가 3초 전이면 1/3을 PFF 값으로 가짐`
    - 자주 발생할수록 PFF 값은 커지고, 드물게 발생할수록 PFF 값은 작아짐
  - PFF의 상한과 하한을 정해 둠
    - PFF가 상한보다 높으면 페이지 프레임 개수를 1 증가
    - PFF가 하한보다 낮으면 그 사이에 참조되지 않았던 페이지를 모두 제거
  - 장점
    - 프로세스별 페이지 집합이 워킹 세트 알고리즘처럼 자주 바뀌지 않음

## 11강. 장치관리
### 장치의 개념
### 장치의 구성
### 입출력 처리 유형
### 입출력 관리
