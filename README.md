# 자료 구조

## 목차
- [1강. 자료 구조란 무엇인가?](#1강-자료-구조란-무엇인가)
- [2강. 배열](#2강-배열)
- [3강. 스택](#3강-스택)
- [4강. 큐](#4강-큐)
- [5강. 연결 리스트](#5강-연결-리스트)
- [6강. 연결 리스트의 응용](#6강-연결-리스트의-응용)
- [7강. 트리](#7강-트리)
- [8강. 스레드 트리](#8강-스레드-트리)
- [9강. 힢](#9강-힢)
- [10강. 선택 트리, 숲, 이진 트리 개수](#10강-선택-트리-숲-이진-트리-개수)
- [11강. BS, Splay, AVL, BB](#11강-BS-Splay-AVL-BB)
- [12강. 멀티웨이 탐색 트리 (I)](#12강-멀티웨이-탐색-트리-I)

## 1강. 자료 구조란 무엇인가?
- ‘**자료(data)**’는 현실 세계에서 관찰이나 측정을 통해서 수집된 값(value)이나 사실(fact)이다.
  - **자료형** : 자료가 기억될 기억 장소의 유형. 즉 정수형, 실수형 등
  - **추상 자료형** : 자료의 복잡한 논리적 성격을 정의하는 형식으로 자료 값의 집합과 연산 집합에 대한 명세의 집합

- ‘**정보(information)**’는 어떤 상황에 대해서 적절한 의사결정(decision)을 할 수 있게 하는 지식(knowledge)으로서 자료의 유효한 해설(interpretation)이나 자료 상호 간의 관계(relationship)를 표현하는 내용이라고 할 수 있다.
  - ‘정보’는 어떠한 상황에 적절한 결정이나 판단에 사용될 수 있는 형태로 가공되거나 분류되기 위해 ‘처리 과정’을 거쳐서 정리되고 정돈된 ‘자료’의 2차 처리 결과물이다.
  - 정보는 자료를 처리(process)해서 얻어진 유용한 결과(result)라고 할 수 있다.

- 자료 사이의 논리적 관계를 컴퓨터나 프로그램에 적용하기 위해서는 자료의 추상화가 필요하며 추상화를 통해 자료의 논리적 관계를 구조화한 것을 ‘**자료 구조(data structure)**’라고 한다.
  - ‘**미리 정의된 자료 구조**’는 프로그래밍 언어를 개발하는 개발자에 의해 정의되고 추상화되었고, 이를 컴퓨터 내부에서 프로그래밍 언어의 형태로 구현한 자료 구조를 의미한다.
  - ‘미리 정의된 자료 구조’는 프로그래밍 언어 개발자가 프로그램 개발자를 위해 미리 정의하지만, ‘**사용자 정의 자료 구조**’는 프로그램 개발자가 자신의 프로그램 개발 방향에 따라 프로그래밍 언어로 새롭게 정의하여 사용하는 자료 구조이다.

- ‘**알고리즘(algorithm)**’이란 컴퓨터에 의해 수행되기 위해 필요한 명령어들의 유한 집합이 사람의 머릿속에 추상화되어 존재하는 것이다.
  - 알고리즘이 가지고 있어야 할 조건은 ① 출력, ② 유효성, ③ 입력, ④ 명확성, ⑤ 유한성 등이 있다.
  - 알고리즘을 실행하는 데 필요한 시간과 공간을 추정하여 알고리즘의 성능을 분석(performance analysis)을 한다. 그리고 컴퓨터가 실제로 프로그램을 실행하는 데 걸리는 시간을 측정하여 알고리즘의 성능을 측정(performance measurement)한다.

- ‘**추상화(abstraction)**’란 공통적인 개념을 이용하여 같은 종류의 다양한 객체를 정의하는 것이다.
  - 자료의 추상화와 구조화가 적절히 이루어지지 못하면 소프트웨어는 비효율적으로 수행되거나 소프트웨어의 확장성에 문제가 생길 수 있다.
  - 자료 구조가 입력값의 추상화된 상태라면, 알고리즘은 컴퓨터가 수행해야 할 명령이 추상화된 것이다.

## 2강. 배열
- <strong>배열(Array)</strong>은 인덱스와 원소값(<index, value>)의 쌍으로 구성된 집합으로서, 정의된 각 인덱스는 그 인덱스와 관련된 값을 갖는다.
  - 배열의 순서는 메모리 공간에서 저장되는 ‘원소 값의 물리적 순서’를 의미한다.
  - 배열의 각 원소의 물리적인 위치(메모리 주소)의 순서가 배열의 인덱스의 순서(논리적인 순서)와 일치한다.
  - 배열의 인덱스 값을 이용해서 배열의 원소 값에 접근하기 때문에 직접 접근(direct access)에 해당된다.
  - 배열의 물리적인 저장 순서는 배열의 인덱스에 의해서 결정되며, 그 순서에 따라 메인 메모리에서의 저장 위치의 순서가 결정된다.
  
- **배열의 연산**
  - `create(n)`은 n개의 원소들을 저장할 수 있는 공백 배열(empty array)을 생성한다. 이는 배열을 생성할 때 n개의 원소들을 저장할 수 있는 공간은 만들어지지만 그 안에 채워진 원소 값들이 아직은 없다는 것을 의미한다.
  - `retrieve(a,i)`는 배열 a와 인덱스 i를 매개 변수로 전달받아 인덱스 i 위치에 대응되는 원소 값 e가 있다면 원소 값 e를 반환하고 그렇지 않은 경우 에러 메시지를 반환한다.
  - `store(a, i, e)`는 배열 a와 인덱스 i, 원소값 e를 매개 변수로 전달받아 Index를 검사하여 i 값이 유효할 경우 쌍이 되게 원소 값을 i번째 인덱스에 저장하고 배열 a를 반환한다.

- 가장 기본적인 배열은 1차원 배열이며, 한 줄짜리 배열을 의미하므로 인덱스는 하나이다. 한 줄짜리 배열은 메모리 영역도 한 줄로 할당받는다.
  - 2차원 배열의 <strong>행 우선 저장 방식(row major order)</strong>은 하나의 행이 모두 연속적으로 메모리 영역을 할당받고, 다음 행이 메모리 영역을 연속적으로 할당받는 방식이다.
  - 2차원 배열의 <strong>열 우선 저장 방식(column major order)</strong>은 하나의 열이 모두 연속적으로 메모리 영역을 할당받고, 다음 열이 메모리 영역을 연속적으로 할당받는 방식이다.

- 원소 값이 0인 원소가 그렇지 않은 원소보다 상대적으로 많은 행렬을 <strong>희소 행렬(sparse matrix)</strong>이라 한다.

## 3강. 스택
- <strong>스택(Stack)</strong>은 객체와 그 객체가 저장되는 순서를 기억하는 방법에 관한 추상 자료형이다.
  - 스택의 추상 자료형에서 정의된 연산은 시스템 개발자에 따라 다르게 정의되고 구현될 수도 있고, 컴파일러 설계자에 따라 프로그래밍 언어에서 다르게 제공될 수도 있다.
  - <strong>시스템 스택(system stack)</strong> : 변수에 대한 메모리의 할당과 수집을 위해 운영 체제가 관리하는 스택

- 스택을 생성하는 연산은 프로그래머가 지정한 크기의 새로운 스택을 생성하는 연산이며, 매개 변수인 `maxStack`은 스택이 저장할 수 있는 최대 개수의 element를 의미한다.
  - `IsFull(stack, maxStackSize)` 연산은 스택이 가득 찼는지를 확인한다.
    - 저장된 원소의 수가 maxStackSize와 같으면 `TRUE`(‘스택이 가득 찼다’)를 반환하고 아니면 `FALSE`(‘스택에 여유 저장 공간이 있다’)를 반환한다.
  - `Stack Push(stack, item)` 연산은 스택에 새로운 원소를 삽입한다.
    - 만일 스택이 가득 찼다(Full)면 더 이상의 원소를 스택에 삽입할 수 없으며, `stackFull` 메시지를 출력한다.
  - `Boolean IsEmpty(stack)` 연산은 스택 상태가 빈 상태인지를 확인한다.
    - 만일 스택이 빈 상태이면 `TRUE` 값을 반환하고, 스택에 하나 이상의 원소라도 있다면 `FALSE` 값을 반환한다.
  - `Element Pop(stack)` 연산은 스택이 빈 상태라면 삭제할 원소가 없으므로 `stackEmpty`를 출력한다.
    - 빈 상태가 아니라면 삭제할 원소가 있으므로, 스택의 top이 가리키는 원소를 삭제하고 그 원소를 반환한다.

- 연산 표기법
  - <strong>중위 표기법(infix notation)</strong>은 연산자를 피연산자의 사이에 표기하는 방법이며 일반적으로 가장 많이 사용되는 표기 방법(`A+B`)이다.
  - <strong>전위 표기법(prefix notation)</strong>은 연산자를 피연산자의 앞에 표기하는 방법(`+AB`)이다.
  - <strong>후위 표기법(postfix notation)</strong>은 연산자를 피연산자의 뒤에 표기하는 방법(`AB+`)이다.

## 4강. 큐
- <strong>큐(Queue)</strong>는 한쪽에서는 삽입이 발생하고 다른 한쪽에서는 삭제가 발생하도록 정의되었으며, 먼저 삽입된 원소가 먼저 삭제되므로 <strong>선입 선출(First-In-First-Out : FIFO)</strong> 또는 <strong>선착순 서브(First-Come-First-Serve : FCFS)</strong> 알고리즘을 갖는 순서 리스트라고도 한다.
  - 큐에서는 원소의 삭제 연산이 이루어지는 곳을 <strong>앞(front)</strong>이라 하고 삽입 연산이 이루어지는 곳을 <strong>뒤(rear)</strong>라고 한다.
  - 큐의 추상 자료형에서 정의된 연산은 시스템 개발자에 따라 다르게 정의되고 구현될 수도 있고, 컴파일러 설계자에 따라 프로그래밍 언어에서 다르게 제공될 수도 있다.
    - <strong>FCFS(First-Come First-Served) 스케줄링(또는 FIFO 스케줄링)</strong> : 작업(프로그램)이 준비 큐에 도착한 순서대로 CPU를 할당받도록 해 주는 기법
    - <strong>RR(Round Robin) 스케줄링 기법</strong> : 작업이 도착한 순서대로 CPU가 할당되지만, CPU의 시간 할당량 또는 시간 간격에 의해 제한을 받으며, 일정한 크기의 시간 할당량을 모든 작업에게 주고 그 시간동안 작업이 완료되지 못하면 준비 큐의 맨 뒤에 다시 배치되는 기법

- 큐 생성 함수(`Create_q(maxQueueSize)`)를 호출하기만 하면 프로그래머가 지정한 크기의 새로운 큐를 생성할 수 있다.
  - `Create_q(maxQueueSize)` 함수의 매개 변수인 `maxQueueSize`는 큐가 저장할 수 있는 최대 개수의 원소(element)를 의미한다.
  - `Boolean IsFull_q(queue, maxQueueSize)` 연산은 큐가 가득 찼는지를 확인한다.
    - 즉, 큐에 저장된 원소(element)의 개수가 `maxQueueSize`와 같다면, 그 큐는 가득 찼으며 큐에 자료(원소)를 더 이상 저장시킬 수 없다는 것을 의미한다.
  - `Queue Add_q(queue, item)` 연산은 큐에 새로운 원소를 삽입한다.
    - 만일 큐가 가득 찼다(Full)면 더 이상의 원소를 큐에 삽입할 수 없으며, `queueFull` 메시지를 출력한다.
  - `Boolean IsEmpty(queue)` 연산은 큐 상태가 빈 상태인지를 확인한다.
    - 만일 큐가 빈 상태이면 `TRUE` 값을 반환하고, 큐에 하나 이상의 원소라도 있다면 `FALSE` 값을 반환한다.
  - `Element Delete_q(queue)` 연산자는 큐가 빈 상태라면 삭제할 원소가 없으므로 `queueEmpty`를 출력한다.
    - 빈 상태가 아니라면 삭제할 원소가 있으므로, 큐의 front가 가리키는 원소를 삭제하고 그 원소를 반환한다.

- <strong>원형 큐(Circular Queue)</strong>는 파이프의 입구와 출구 부분을 연결시킨 형태로, 큐의 양 끝을 연결시켜서 원 형태로 만든 큐를 말한다.
  - 연결된 부분의 데이터 공간을 연속적으로 사용하기 위해 '나머지 연산자'를 사용한다.

## 5강. 연결 리스트
- <strong>리스트(List)</strong> : ‘원소들 간의 순서’가 지켜지며 유지되는 자료 구조
  - 리스트의 ‘순서’는 데이터가 저장되는 물리적인 위치와 상관없이 사람들의 머릿속에 인식되는 ‘논리적인 순서’, 혹은 리스트에 나타나는 원소들 간의 ‘의미적인 순서’를 의미한다.
  - 리스트의 노드(Node) : 원소 값과 다음 원소를 가리키는 위치의 주소 값으로 구성된 자료 단위
    - 즉, 데이터 요소(원소)와 리스트의 다음 원소를 지시하는 포인터(pointer, 주소)를 가지는 자료 단위

- <strong>포인터(Pointer)</strong> : 메모리에 저장되는 값(데이터)의 저장 위치에 대한 주소를 가리키는 데이터형
  - 포인터를 이용하는 방법은 원소의 자리에는 원소 값을 저장하고, 다음 원소를 가리키는 정보의 자리에는 다음 원소가 저장될 위치의 주소 값을 저장하는 것이다.
  - 조금 더 ‘프로그램’스럽게 설명하자면, 리스트의 원소의 자리와 다음 원소를 가리키는 정보의 자리를 합쳐서 노드(node)라고 할 때, 이 노드가 데이터 요소(원소)와 리스트의 다음 원소를 지시하는 포인터(pointer, 주소)를 가진다고 생각하면 된다.
    - 이 포인터는 링크(link)라고도 부른다.
  - 포인터의 '메모리 주소 값'이라는 것은 메모리에 저장되는 값의 위치라고 생각하면 된다.
    - 메모리에 저장되는 값(데이터)은 저장 위치에 대한 주소를 가지며, 이 저장 위치를 이용해서 리스트의 원소 값을 찾아갈 수 있습니다.

- 다양한 데이터형의 변수를 하나의 상자 안에 넣어서 선언하거나 사용하는 C 프로그래밍 문법이 <strong>구조체(struct)</strong>이다.

- 배열을 이용한 리스트의 구현은 실제 IT 서비스 환경에서는 자주 사용되지 않고 있다.
  - 자료의 삽입과 삭제가 빈번히 발생하는 상황에서, 리스트를 배열로 구현하는 것은 빈번한 자료 이동으로 인한 비효율적인 컴퓨팅 성능을 유발한다.

## 6강. 연결 리스트의 응용
- **단순 연결 리스트** : 링크 부분이 하나만 있고, 각각의 노드는 후행 노드만을 가리키는 구조
  - 특정 노드의 선행 노드에 대한 접근은 헤드 노드부터 재검색해야 하는 단점을 갖는다.

- **이중 연결 리스트** : 선행 노드를 가리키는 링크 부분과 후행 노드를 가리키는 링크 부분을 갖는 구조

- **원형 연결 리스트** : null 값을 갖는 마지막 노드의 링크 부분을 활용하면서도 프로그램 성능에 도움을 주기 위해 제안되었으며, 한 방향으로 모든 노드가 원형으로 계속 연결되어 있기 때문에 한 노드에서부터 다른 어떤 노드로도 접근이 가능한 구조

## 7강. 트리
- <strong>트리(Tree)</strong>는 논리적 계층이 있는 구조이다.
  - 트리는 데이터의 계층 관계, 포함 관계 등을 나타내는 자료 구조이다.
  - 트리를 구성하는 항목을 노드(node) 혹은 정점(vertex)이라고 한다.
    - 내부 노드 : 루트도 잎도 아닌 노드
    - 형제(sibling) : 같은 부모를 갖는 노드들
    - 루트(route) : 트리에서 부모를 갖지 않은 노드
    - 트리에서 각 노드의 레벨(level)은 루트로부터 그 노드까지 이어진 경로의 길이로 정합니다.
  - 트리의 차수(degree of a tree)는 트리 내의 각 노드의 차수 가운데 최대 차수로 정의한다.
    - 진입 차수 : 트리에 있는 어떤 노드에 대해 그 노드로 들어오는 선의 개수
    - 진출 차수 : 트리에 있는 어떤 노드에 대해 그 노드에서 나가는 선의 개수
      - 트리에서 각 노드의 차수(degree of a node)는 진출 차수로 정의한다.
  - 트리의 각 노드를 빠짐없이 한 번씩만 방문하는 것을 순회(traverse)라고 한다.
    - 루트를 방문하는 순서에 따라 각각 전위(preorder) 순회, 중위(inorder) 순회, 후위(postorder) 순회라고 구분하여 부른다.
  
- 트리에 속한 모든 노드의 차수가 2 이하인 트리를 <strong>이진 트리(Binary Tree)</strong>라 한다.
  - 이진 트리에서 각 레벨이 허용되는 최대 개수 노드를 가질 때 그 트리를 <strong>완전 이진 트리(Complete Binary Tree)</strong>라고 한다.
  - 높이가 k인 이진 트리를 레벨 0부터 k-2까지 다 채우고 마지막 k-1 레벨에서 왼쪽부터 오른쪽으로 노들들이 차례로 채워졌을 때 이를 <strong>포화 이진 트리(Perfect Binary Tree)</strong>라고 한다.

## 8강. 스레드 트리
- <strong>스레드 트리(Thread Tree)</strong> : 스레드라는 포인터를 갖는 이진 트리
  - <strong>스레드(Thread)</strong> : 정해진 순회 방법에 따른 방문 순서를 유지하는 포인터
    - 오른쪽 스레드 : 정해진 순회 순서에 따른 그 노드의 후속 노드를 가리킴
    - 왼쪽 스레드 : 정해진 순회 순서에 따른 그 노드의 선행 노드를 가리킴 

- 스레드 트리 구현 방법
  1. 스레드를 저장하는 포인터를 추가하는 방법
  2. 이진 트리를 위한 연결 리스트의 노드 구조를 그대로 사용하면서, 리프 노드에 있는 사용하지 않는 포인터를 활용하는 방법
      - 리프 노드에 있는 포인터를 활용하는 방법은, 각 노드에 대해 포인터가 스레드로 사용 중인지 아니면 서브 트리에 대한 포인터로 사용 중인지를 구분하기 위해 tag 필드를 사용하는 것이다.
      - 노드가 n개인 이진 트리의 null 포인터 개수 : `2n-(n-1) = n+1개`

## 9강. 힢
- <strong>힢(Heap)</strong> : 부모 노드와 자식 노드 사이의 대소 관계가 정의되어 구성되는 완전 이진 트리로 우선 순위 큐와 같은 결과를 제공함
  - 힢은 무엇인가를 쌓아 놓은 더미로, 항상 가장 위에 있는 것을 먼저 꺼내는 구조를 갖는다.
    - 힢은 우선 순위 큐의 한 종류이다.
  - **최대 힢** : 루트가 가장 큰 값을 갖고 부모는 자식보다 큰 값을 가지면 됨
    - 즉 트리의 모든 노드가 자식 노드보다 큰 값을 갖는다.
  - **최소 힢** : 루트가 가장 작은 값을 갖고 부모는 자식보다 작은 값을 가지면 됨
    - 즉 트리의 모든 노드가 자식 노드보다 작은 값을 갖는다.
- 힢에서 노드를 삭제한 후에도 완전 이진 트리의 모습을 유지해야 하며, 최대 힢 혹은 최소 힢의 조건을 만족해야 한다.

## 10강. 선택 트리, 숲, 이진 트리 개수
- <strong>합병 정렬(Merge Sort)</strong> : 차례로 정렬된 데이터 리스트 k가 있다고 가정할 때 그것들을 완전한 순서를 유지하는 하나의 리스트로 만드는 과정

- <strong>선택 트리(Selection Tree)</strong> : 합병 정렬에 사용하는 특수한 트리
  - <strong>승자 트리(Winner Tree)</strong> : 각 노드가 두 개의 자식 노드보다 더 작은 값(승자)을 갖는 완전 이진 트리(실제로는 포화 이진 트리)
    - 승자 트리 구축 과정은 작은 값이 승자로 올라가는 토너먼트 경기와 유사하다.
    - 즉 트리의 각 내부 노드는 두 자식 노드 값의 승자를 자신의 값으로 한다.
  - <strong>패자 트리(Loser Tree)</strong> : 각 노드가 두 개의 자식 노드보다 더 큰 값(패자)을 가지며 최종 승자는 루트 노드 위의 0번 노드에 저장하는 트리
    - 패자를 부모 노드에 저장하고 승자는 부모의 부모 노드로 올라가서 다시 경쟁한다.
    - 따라서 루트에는 마지막 토너먼트 패자를 저장하고 최종 승자는 루트 노드 위 최상위 0번 노드에 저장한다.

- <strong>숲(Forest)</strong> : 분리된 트리 모임, n(n≧0)개 이상의 분리된 트리 집합
  - 숲을 이진 트리로 바꾸려면 먼저 각 트리(![image](https://user-images.githubusercontent.com/61646760/144752580-6f86d892-80cd-4572-af1a-c4ca49e3a544.png))를 이진트리로 바꾼다(![image](https://user-images.githubusercontent.com/61646760/144752600-efb4538b-3dd4-4adb-bd2d-71ce58da71bb.png)). 이때 ![image](https://user-images.githubusercontent.com/61646760/144752609-10a10962-82a3-4ca6-b7f5-26a970042862.png)의 루트는 왼쪽 서브 트리만을 갖는다.
  - 다음은 ![image](https://user-images.githubusercontent.com/61646760/144752629-70a74c7b-bfdb-4a26-bb11-7ee83dedcadd.png)의 루트를 최상위 루트로 하고 왼쪽 자식은 그 왼쪽 서브 트리(오른쪽 서브 트리는 없음) 오른쪽 자식은 나머지들의 이진 트리(![image](https://user-images.githubusercontent.com/61646760/144752676-9005219f-c728-4c51-bfe4-9a78c0e30a5a.png))가 되도록 한다.
- 어떤 이진 트리에 대한 전위-중위 순회 방문 순서가 주어지면 트리 구조를 유일하게(한 개) 정할 수 있다.
- 1부터 n까지 수를 스택에 넣었다가 가능한 모든 방법으로 삭제하여 생성할 수 있는 경우의 수와 n개의 노드를 가진 상이한 이진 트리의 수가 같다.
  - 카탈란이라는 수학자가 노드 n개인 서로 다른 이진 트리의 개수가 `(2n)!/n!(n+1)!`과 같음을 증명했다.

## 11강. BS, Splay, AVL, BB

- <strong>이진 탐색 트리(binary search tree)</strong> : 빠르게 탐색할 수 있도록 구성한 이진 트리
  - 트리에 특정 데이터가 있는지를 검색하고, 노드를 자주 삽입, 삭제하는 응용 문제에 가장 효과적인 이진 트리
  - 이진 탐색 트리는 전위 순회, 중위 순회 및 후위 순회로 모든 정점을 차례로 순회할 수 있고 트리 내의 특정 정점을 탐색할 수도 있다.
  - 이진 탐색 트리에서 새 노드는 항상 잎으로 삽입한다.
    - 즉, 루트부터 키 값을 비교하며 자기가 삽입될 위치가 왼쪽이냐 오른쪽이냐를 정하며 내려간다.
  
- <strong>Splay 트리</strong> : 자주 탐색하는 키를 가진 노드를 루트에 가깝게 위치하도록 구성한 이진 탐색 트리
  - 키(Key) : 각 노드를 식별하기 위해 별도의 간단한 이름을 붙여 준 것으로, 곧 노드의 데이터를 가리킨다.
  - Splay 트리는 Splay 연산을 적용하여 최근에 사용하려고 접근한 노드 x를 루트에 위치시켜 트리를 재구성한다.

- <strong>AVL 트리</strong> : 노드의 왼쪽 서브 트리 높이와 오른쪽 서브 트리 높이가 최대 1만큼 차이가 난다는 조건을 만족하는 트리
  - 트리의 높이 : 노드가 가질 수 있는 가장 높은 레벨에 1을 더한 값으로, 루트로부터 잎까지 가장 긴 경로 길이
  - 트리의 무게 : 트리에 속한 잎 노드의 개수

- <strong>무게가 균형 잡힌 트리(weight-balanced tree)</strong> 또는 <strong>BB-트리(bound-balanced)</strong> : 각 노드의 양쪽 서브 트리 무게가 균형을 유지하는 트리
  - AVL 또는 BB 트리에 대하여, 각각 높이 또는 크기 제한 조건을 만족시키는 데 드는 비용은 트리를 완전히 균형 잡히게 유지하는 비용이나 노력보다 훨씬 적게 든다.
  - 삽입이나 삭제 후에 트리를 완전히 균형 잡히게 유지하기 위해서는 ![image](https://user-images.githubusercontent.com/61646760/144753408-eaa374f1-35b4-4f68-a96c-70ef1c2a6b14.png)개의 노드를 옮겨야 하는 반면에, AVL 또는 BB 트리는 ![image](https://user-images.githubusercontent.com/61646760/144753384-142f3274-782f-416a-a941-726460b084b0.png)개의 노드를 옮기면 되는 것으로 알려져 있다.

## 12강. 멀티웨이 탐색 트리 (I)
- **m원 탐색 트리** : 트리의 노드가 m개 이하의 가지를 가질 수 있는 탐색 트리
  - m원 탐색 트리는 이진 탐색 트리를 확장한 것으로 탐색 트리의 제한을 따르되 2개 이상(m개 이하)의 자식을 가질 수 있다.

- **B 트리** : 인덱스 구조를 구현하는데 가장 일반적으로 사용하는 방법으로 차수가 m인 트리
  - 루트와 잎 노드를 제외한 B 트리의 각 노드는 최소 ⌈m/2⌉개의 서브 트리를 갖는다.
  - B 트리의 루트는 최소한 2개의 서브 트리를 갖는다.
  - B 트리의 모든 잎 노드는 같은 레벨에 있다.
  - B 트리의 삽입 연산에서 노드가 꽉 차 있는 경우는 분리해서 키 값과 포인터를 재분배해야 한다.
  - B 트리 삭제 연산에서 삭제 결과 개수가 부족하면 그 노드를 다른 노드와 묶어야 한다. 
- <strong>B* 트리</strong> : 노드의 약 2/3 이상이 차야 하는 B 트리
  - B* 트리는 노드가 꽉 차면 분리하지 않고, 키와 포인터를 재배치하여 다른 형제 노드로 옮긴다.
- **B+ 트리** : 모든 키 값이 잎 노드에 있고 그 키 값에 대응하는 실제 데이터에 대한 주소를 잎 노드만이 가지고 있어서 인덱스된 순차 파일을 구성하는 데 사용하는 트리
  - 인덱스된 순차 파일은 데이터를 차례로 처리하는 순차 처리와 특정 데이터를 직접 찾아 처리하는 두 가지를 모두 효율적으로 할 수 있는 구조이다.
  - B+ 트리는 잎 노드의 마지막 포인터는 다음 키값을 갖는 노드를 가리킨다.
    - 따라서 순차 처리를 할 때는 이 포인터를 이용해서 차례로 다음 데이터에 접근해서 처리할 수 있다.
  - 앞서 말한 것처럼, B+ 트리에서는 모든 키 값이 잎 노드에 있고 그 키 값에 대응하는 실제 데이터에 대한 주소를 잎 노드만이 가지고 있다.
