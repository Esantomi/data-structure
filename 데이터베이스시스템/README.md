# 데이터베이스시스템

### 목차
- [1강. 데이터베이스의 이해](#1강-데이터베이스의-이해)
  - [데이터 관리와 파일 처리 시스템](#데이터-관리와-파일-처리-시스템)
  - [데이터베이스와 DBMS](#데이터베이스와-DBMS)
  - [데이터베이스 언어와 아키텍처](#데이터베이스-언어와-아키텍처)
- [2강. 데이터베이스 모델링](#2강-데이터베이스-모델링)
  - [데이터베이스 모델링의 이해](#데이터베이스-모델링의-이해)
  - [사용자 요구사항 분석](#사용자-요구사항-분석)
  - [ER 모델](#ER-모델)
- [3강. 관계형 모델](#3강-관계형-모델)
  - [관계형 모델](#관계형-모델)
  - [ERD의 변환](#ERD의-변환)
  - [데이터 연산](#데이터-연산)
- [4강. SQL (1)](#4강-SQL-1)
  - [데이터베이스 언어](#데이터베이스-언어)
  - [데이터 정의 언어](#데이터-정의-언어)
- [5강. SQL (2)](#5강-SQL-2)
  - [데이터 삽입, 수정, 삭제](#데이터-삽입-수정-삭제)
  - [데이터 검색 (1)](#데이터-검색-1)
- [6강. SQL (3)](#6강-SQL-3)
  - [데이터 검색 (2)](#데이터-검색-2)
  - [뷰의 사용](#뷰의-사용)
- [7강. 정규화](#7강-정규화)
  - [좋은 릴레이션과 나쁜 릴레이션](#좋은-릴레이션과-나쁜-릴레이션)
  - [함수적 종속성](#함수적-종속성)
  - [정규화](#정규화)
- [8강. 연습문제 풀이 (1)](#8강-연습문제-풀이-1)
- [9강. 데이터 저장과 파일](#9강-데이터-저장과-파일)
  - [물리적 저장 장치](#물리적-저장-장치)
  - [파일](#파일)
  - [저장 장치 관리](#저장-장치-관리)
- [10강. 인덱싱](#10강-인덱싱)
  - [인덱스의 이해](#인덱스의-이해)
  - [순서 인덱스](#순서-인덱스)
  - [B+ 트리 인덱스](#B-트리-인덱스)

## 1강. 데이터베이스의 이해
### 데이터 관리와 파일 처리 시스템
- **데이터(Data)**
  - 어떠한 사실에 대한 정량적, 정성적 특징을 나타낼 수 있는 값과 값에 대한 설명
    - [Data Storage Units](https://user-images.githubusercontent.com/61646760/149938472-559d71d6-1ac0-49ea-9ca0-397e2f942d76.png)
    - 빅데이터 처리
      - [IoT > Big Data > AI](https://user-images.githubusercontent.com/61646760/149781586-ae918fdf-8552-4098-83c0-5f9c017a1463.png)
  - 데이터 관리의 필요성
    - 대량의 데이터를 저장 및 관리하고 필요한 데이터를 신속히 검색할 수 있도록 보조하는 장치
      - `예) 파일 처리 시스템, SQL, 데이터 웨어하우스 등`
- **파일 처리 시스템(File Processing System)**
  - 파일을 사용하여 업무에 사용되는 데이터를 관리하는 방식
    - 데이터베이스가 개발되기 전에 데이터 관리에 사용
    - 업무별 애플리케이션이 개별 데이터를 데이터 파일에 저장·관리하는 시스템
  - 발생 가능한 문제
    1. 데이터 종속의 문제
        - 저장된 데이터가 특정 H/W에서 또는 사용자 및 S/W만 사용될 있도록 제한되는 문제
        - 물리적 데이터 종속, 논리적 데이터 종속
    2. 데이터 중복의 문제
        - 동일한 사항에 대한 중복 데이터는 일관성, 보안성, 경제성 측면에서 문제 발생
          - 일관성 : 한 사실에 대해 한 개의 데이터 값을 유지
          - 보안성 : 같은 데이터에 같은 수준의 보안 유지
          - 경제성 : 데이터에 대해 최소한의 저장 공간만을 점유
    3. 데이터 무결성 훼손의 문제
        - 실세계의 데이터는 데이터가 가질 수 있는 가능 범위(제약 조건)를 포함
          - `예) 1학기 최대 수강 과목은 18학점`
        - **데이터 무결성(Data Integrity)**
          - 데이터의 값과 값에 대한 제약 조건을 동시에 만족함으로써 데이터의 정확성 보장
        - 파일 시스템은 데이터 무결성을 보장하기 위한 기능을 제공하지 않음
    4. 데이터 동시 접근의 문제
        - 동일 데이터에 다수 사용자의 접근 허용 시 일관성이 훼손

### 데이터베이스와 DBMS
- **데이터베이스 시스템(Database System)**
  - 정보를 데이터베이스에 저장·관리하여 사용자에게 요구된 형태의 정보로 제공하는 컴퓨터 기반 시스템
    - 즉, `데이터베이스 시스템 = 데이터베이스 + 데이터베이스 관리 시스템(DBMS)`
  - 데이터베이스 시스템의 구성
    ![image](https://user-images.githubusercontent.com/61646760/149782623-b6906d5a-c3cf-4cb3-b3f2-3876e2d50873.png)
    - **메타데이터(Metadata)**
      - 데이터에 대한 데이터
- **데이터베이스(Database)**
  - 특정 기관의 애플리케이션 시스템에서 사용되는 데이터의 집합
  - 데이터베이스의 특징
    - 데이터베이스는 자기 기술성, 추상화, 다중 뷰, 동시성 제어 등의 기능을 통해 파일 처리 시스템의 문제점을 극복한다.
      1. 데이터베이스 시스템의 자기 기술성
          - 데이터와 데이터의 정의 및 설명(메타데이터)을 포함
      2. 프로그램과 데이터의 격리 및 추상화
          - 사용자에게 데이터에 대한 개념적인 표현을 제공하여 접근성을 향상
      3. 다중 뷰 제공
          - 각 사용자가 관심을 갖는 데이터베이스의 일부만을 표현할 수 있는 기능 제공
      4. 데이터 공유와 다수 사용자 트랜잭션 처리
          - 다수의 데이터 조작 요청을 동시성 제어 기능을 통해 데이터의 일관성을 보장하면서 동시에 작업을 수행
- **데이터베이스 관리 시스템(Database Management System: DBMS)**
  - 데이터베이스에 저장된 데이터의 구성, 저장, 관리, 사용을 위한 소프트웨어 패키지
    ![image](https://user-images.githubusercontent.com/61646760/150522013-193db0de-06dd-4a55-8038-69cdbd4f099b.png)
    - 데이터 사용과 데이터 관리 측면을 분리
  - **DBMS 3단계 구조(DBMS Three Level Architecture)**
    - 데이터 추상화와 데이터 독립성을 확보하기 위한 개념적-논리적-물리적 3단계 구조
      ![image](https://user-images.githubusercontent.com/61646760/149783043-713498db-ca00-4c0c-904d-be33c01f6933.png)
      - **외부 단계(External Level)**
        - 사용자 뷰
        - **외부 스키마(External Schema)**
          - 외부 단계에서 사용자에게 필요한 데이터베이스를 정의한 것
          - 각 사용자가 생각하는 데이터베이스의 모습, 논리적 구조로 사용자마다 다른 모습
          - 데이터베이스 하나에 외부 스키마 여러 개 존재
      - **개념 단계(Conceptual Level)**
        - 데이터베이스의 논리적인 전체 구조
        - **개념 스키마(Conceptual Schema)**
          - 개념 단계에서 데이터베이스 전체의 논리적 구조를 정의한 것
          - 조직 전체의 관점에서 생각하는 데이터베이스의 모습
          - 데이터베이스 하나에 개념 스키마 하나만 존재
      - **내부 단계(Internal Level)**
        - 데이터가 기억장소에 저장되기 위한 물리적 구조
        - **내부 스키마(Internal Schema)**
          - 전체 데이터베이스가 저장 장치에 실제로 저장되는 방법을 정의한 것
          - 레코드 구조, 필드 크기, 레코드 접근 경로 등 물리적인 저장 구조를 정의
          - 데이터베이스 하나에 내부 스키마 하나만 존재
      - **외부-개념 사상(external-conceptual mapping)**
        - 특정 외부 스키마와 개념 스키마 간의 대응 관계를 정의
      - **개념-내부 사상(conceptual-internal mapping)**
        - 개념 스키마와 내부 스키마 간의 대응 관계를 정의
- **트랜잭션(Transaction)**
  - 하나의 논리적 작업을 처리하기 위한 일련의 데이터베이스 명령의 집합
    - [`예) 트랜잭션 1, 트랜잭션 2`](https://user-images.githubusercontent.com/61646760/149785989-7e8d4a9a-5dc0-41c7-a282-2faf22583b41.png)
      - 트랜잭션 1은 `Read(A)`와 `Write(A)`로 구성돼 있으며, 트랜잭션 1이 끝난 뒤에야 트랜잭션 2를 수행할 수 있다.

### 데이터베이스 언어와 아키텍처
- **데이터베이스 언어(Database Language)**
  - DBMS는 사용자가 데이터베이스를 쉽게 사용하고 다룰 수 있도록 언어 형태의 인터페이스를 제공
  - 역할에 따라 두 종류의 언어로 구분
    - **데이터 정의 언어(Data Definition Language: DDL)**
      - 데이터베이스 객체를 생성, 수정, 삭제하기 위한 언어
      - DDL의 요구 기능
        - 데이터 모델에 따라 애플리케이션 프로그램이 요구하는 데이터의 논리적 구성이나 특징을 규정
        - 데이터가 기억장치에 저장되도록 데이터의 물리적 구성을 규정
        - 물리적 구성을 논리적 구성으로 변환이 가능하도록 데이터의 물리적 구성과 논리적 구성 간의 사상(mapping)을 규정
    - **데이터 조작 언어(Data Manipulation Language: DML)**
      - 구조화된 데이터에 사용자가 접근 및 조작할 수 있도록 지원하는 언어 (검색, 삽입, 삭제, 수정)
      - DML의 요구 조건
        - 데이터 조작이 쉽고 간편
        - 데이터 조작 기능이 정확하고 완전
        - 사용자의 요청을 시스템 내부에서 효율적으로 처리 가능
  - 현대 데이터베이스 언어는 자연어와 유사한 형태의 **SQL**로 표준화
- **데이터베이스 시스템 아키텍처(Database System Architecture)**
  - DBMS는 전체 시스템을 구성하는 방식에 따라 두 방식으로 아키텍처를 구성할 수 있다.
    - **중앙집중식 방식(Centralized Database System)**
      - 단일 서버가 다수의 클라이언트 장치를 대신하여 작동
      - 중앙 컴퓨터의 과부하로 전체적인 성능 저하
    - **분산 시스템 방식(Distributed Database System)**
      - 클라이언트 장치의 성능 향상으로 자체적인 처리 능력 보유
      - **클라이언트-서버 데이터베이스 시스템(Client-Server Database System)**
        - 애플리케이션 프로그램의 부하를 분산
        - 소프트웨어의 유지 보수 비용을 절감 및 이식성 증가
        - 2계층 구조(2 Tier Architecture)와 3계층 구조(3 Tier Architecture)
          ![image](https://user-images.githubusercontent.com/61646760/149785804-75c02032-065f-4290-b22e-88d3b15f9622.png)
          - [다층 구조 문서 참고하기](https://ko.wikipedia.org/wiki/%EB%8B%A4%EC%B8%B5_%EA%B5%AC%EC%A1%B0)

## 2강. 데이터베이스 모델링
### 데이터베이스 모델링의 이해
- **데이터베이스 모델링(Database Modeling)**
  - 데이터의 의미를 파악하고 데이터와 관여하는 업무 프로세스를 개념적으로 정의하고 분석하는 작업
    - 데이터베이스 모델링의 필요성
      - 비즈니스적 관점 : 어떤 데이터를 저장해야 하는가
      - 컴퓨터 프로그래머 관점 : 어떻게 데이터를 저장해야 하는가 
    - 데이터베이스 모델링의 단계
      ![image](https://user-images.githubusercontent.com/61646760/149943771-2b232079-98fe-4914-8240-17a3cbd9d0c5.png)
      1. **개념적 데이터 모델링(Conceptual Data Modeling)**
          - 요구 사항의 해석 오류를 방지
          - 실세계의 데이터를 개념적으로 일반화시켜 데이터 구조 데이터 타입, 속성, 관계, 제약 조건 등을 이끌어 내는 과정
            - 즉, 사람에게 필요한 작업
          - [`예) 개념적 데이터 모델링의 결과 : 학생-학과-과목-계좌-교수 개체 집합 간 ERD`](https://user-images.githubusercontent.com/61646760/150093315-fc825a4e-695d-4be4-b319-aa7cea914e5a.png)
      2. **논리적 데이터 모델링(Logical Data Modeling)**
          - 특정 DBMS의 구현 모델에 맞춰 데이터를 표현하는 과정
          - 데이터 정의 언어(DDL)로 기술된 개념 스키마 생성
            - 즉, 개념적 데이터 모델링한 것을 DBMS에 어떻게 저장할 것인지 고민하는 단계
          - [관계형 모델(Relational Model)](#관계형-모델)
            - [ERD를 관계형 모델에 맞는 구조, 즉 릴레이션으로 변환 필요](#ERD의-변환)
      3. **물리적 데이터 모델링(Physical Data Modeling)**
          - 데이터베이스 파일의 내부 저장 구조, 파일 구성, 인덱스, 접근 경로 등을 결정하는 과정
  - [데이터베이스 시스템 구현 과정](https://user-images.githubusercontent.com/61646760/149942182-fdd24d22-7de8-42db-bf2a-8ecf9826e205.png)
    - 좌측은 애플리케이션 구현 과정(소프트웨어 공학), 우측은 데이터베이스 시스템 구현 과정
    - 전체적인 데이터 구조를 가진 개념 스키마가 애플리케이션 설계 과정에 반영되면 보다 구체적인 아키텍처를 구축할 수 있다. 
- **데이터 모델링(Data Modeling)**
  - 실세계의 일부분을 DBMS가 지원하는 데이터 모델의 형태로 나타내는 과정
    - 사용할 데이터를 선별하여 데이터베이스에 체계적으로 구조화하여 저장·사용할 방법
- **데이터 모델(Data Model)**
  - 의미, 데이터 타입, 연산 등을 명시하기 위해 사용할 수 있는 개념들의 집합

### 사용자 요구사항 분석
- **사용자 요구사항 분석(Requirements analysis)**
  - 사용자가 원하는 애플리케이션 프로그램의 요구 사항을 만족하는 데이터베이스를 모델링하기 위해 실제 업무에서 사용되는 데이터의 종류와 특징을 폭넓게 파악하는 과정
    - 시스템의 대상이 되는 업무를 분석
      - 정보 시스템의 데이터베이스가 신속하고 효과적으로 업무 처리를 지원
      - 필요한 데이터를 저장 및 운용할 수 있는 구조 개발
    - 도출, 분석, 기록의 3단계로 수행
      - 국제 표준화 : [IEEE-Std-830](https://standards.ieee.org/standard/830-1998.html)
  - 사용자 요구사항 분석의 필요성
    1. 데이터에 대한 충분한 사전 분석없이 적절한 설계가 불가능 
        - 데이터베이스의 활용 범위가 확대됨에 데이터베이스의 효율적 운용에 초점
        - 데이터베이스의 구조가 점차 복잡해지고 수명 주기가 단축되고 때문에 신속, 정확성이 요구
    2. 사용자의 요구를 명세하지 않고 데이터베이스 설계 및 개발을 진행하는 경우
        - 결과물의 완성도 저하 및 사용자 신뢰도 추락
        - 개발 후 발생하는 에러 수정에 많은 추가 비용 지출
  - 사용자 요구사항 분석의 과정  
    ![image](https://user-images.githubusercontent.com/61646760/149949955-b2fe2a33-65fe-4667-bcda-332cd17a6ba6.png)
    1. 요구사항 도출
        - 구축 대상, 프로젝트 목표, 범위를 기준으로 조사 범위를 결정
        - 업무 관계자 인터뷰
        - 외부 자료 수집 및 분석
    2. 요구사항 기록
        - 요구 사항 목록 정리 및 관리자의 승인
        - 정리된 요구 사항을 형식에 맞춰 문서화
        - 프로젝트 종료 때까지 반영 여부 지속적 관리
    3. 요구사항 분석
        - 도출된 요구사항의 명확성, 완전성, 모호성 검증
        - 불완전한 부분이 존재할 경우 요구 사항 도출 단계 재수행
        - 요구 사항을 분류하여 통합 또는 분리
    - **제안 요청서(Request for Proposal: RFP)**
      - 발주자가 특정 과제의 수행에 필요한 요구 사항을 체계적으로 정리하여 제시함으로써 제안자가 제안서를 작성하는 데 도움을 주기 위한 문서
    - **요구사항 명세서(Software Requirement Specification: SRS)**
      - 서비스를 구현하기 위한 다양한 요구 사항을 분석하여, 명확하고 완전하게 정리 기록한 문서
    - **요구사항 정의서(Requirements Definition)**
      - 요구 사항이 모호하거나 정확하지 않을 때는 이전 단계로 회귀하여 요구 사항을 교정

### ER 모델
- **ER 모델(Entity-relationship model)**
  - 실세계의 속성들로 이루어진 개체(entity)와 개체 사이의 관계(relationship)를 정형화시킨 모델
    - 개념적 모델링 단계에서 사용되는 데이터 모델
      - 1976년 카네기 멜론 대학의 Peter Chen 박사에 의하여 제안
      - 데이터 구조와 관계를 ER 다이어그램(ERD)으로 표현
      - 사실상 현재 표준으로 사용되는 데이터 모델
    - 구성 요소
      - 개체 집합
      - 관계 집합
      - 속성
- **개체(Entity)**
  - 실세계에 존재하는 다른 객체와 구별되는 유무형의 사물
  - 개체를 설명하는 여러 속성들로 구성
- **개체 집합(Entity Set)**
  - 같은 속성을 공유하는 개체들의 모임
  - [`예) 학생 개체 집합`](https://user-images.githubusercontent.com/61646760/149961141-98444302-3bc1-4ce1-a46d-4ff38066b6f5.png)
- **관계(Relationship)**
  - 개체와 개체 사이의 연관성
- **관계 집합(Relationship Set)**
  - 개체 집합 간의 전체적 연결 관계
  - [`예) 전공 관계 집합`](https://user-images.githubusercontent.com/61646760/149965080-80acf164-f587-49d1-bfa4-b7fa261e6338.png)
- **속성(Attribute)**
  - 개체를 구체적으로 설명하는 특성
  - 속성에 포함될 수 있는 값의 특성에 따라 여러 종류로 구분
    - 속성의 종류
      - 단순 속성과 복합 속성
        - **단순 속성(Simple Attribute)**
          - 더 이상 작은 구성 요소로 나눌 수 없는 속성
          - `예) 학생 이름, 성별, 나이`
        - **복합 속성(Composite Attribute)**
          - 더 작은 구성 요소로 나눌 수 있는 속성
          - `예) 생년월일` (년월일로 구분 가능)
      - 단일값 속성과 다중값 속성
        - **단일값 속성(Single-Valued Attribute)**
          - 하나의 개체에 대해 단 하나의 값만을 갖는 속성
          - `예) 학생 이름, 성별, 나이`
        - **다중값 속성(Multi-Valued Attribute)**
          - 하나의 개체에 대해 여러 개의 값을 갖는 속성
          - `예) {전화번호}`
            - `{}`로 표기
      - 유도 속성과 저장 속성
        - **유도 속성(Derived Attribute)**
          - 다른 속성의 값으로부터 값이 유추될 수 있는 속성
          - `예) 나이()`
            - 생년월일로부터 나이 유추 가능
            - `()`로 표기 
        - **저장 속성(Stored Attribute)**
          - 유도 속성을 위해 사용될 수 있는 속성
          - `예) 생년월일`
            - 유추할 수 없으며, 저장이 필수적인 속성
      - **널(Null) 속성**
        - 일부 속성값을 가지지 못해 널(null) 값을 갖는 속성
        - 즉, 입력되지 않아 값을 모르는 경우
- **제약 조건(Constraints)**
  - 데이터 모델은 데이터, 의미, 구조, 연관성 및 데이터의 조건을 표현하기 위한 도구
  - ER 모델은 개체와 관계에 대한 표현의 정확성을 위해 데이터가 항상 준수해야 하는 제약 조건을 정의할 수 있는 방법을 제공
    - 제약 조건(Constraints)의 종류
      - **사상수(Mapping Cardinality)**
        - 관계 집합에 참가한 개체 집합들에 대해 각각의 개체가 얼마만큼의 관계를 맺을 수 있는지 명시한 수
        - `예)` [`일대일(1:1)`](https://user-images.githubusercontent.com/61646760/149970202-a8891941-90e4-4c42-9399-5ffa0ce2847c.png), [`일대다(1:N)`](https://user-images.githubusercontent.com/61646760/149970476-df8b256a-efe9-49b1-8e9d-24a8377ba0ee.png), `다대일(N:1)`, [`다대다(M:N)`](https://user-images.githubusercontent.com/61646760/149970621-24b0baa5-923e-457d-a642-cfccd10f8b15.png)
      - **참가 제약 조건(Participation Constraints)**
        - 전체적 참가 : 어떤 개체 집합의 모든 개체가 관계 집합에 참여하는 조건  
          ![image](https://user-images.githubusercontent.com/61646760/149971097-f7958b1e-8f58-4822-a602-10583148ca3d.png)
          - 이중 선을 통해 전체 참가 표시 (모든 과목은 교수와 관계를 가져야 함)
        - 부분적 참가 : 어떤 개체 집합의 일부 개체가 관계 집합에 참여하는 조건
          - '교수'는 부분적 참가를 하는 집합이며, 단일 선으로 표시 (강의를 맡지 않는 교수도 있음)
      - **키 속성(Key Attribute)**
        - 키(key)는 각 개체를 구별하는 데 사용되는 유일한 값을 가지는 속성의 집합
          - 개체를 고유하게 구분하는 역할
          - 관계 집합의 특정 관계를 찾는 역할
        - `예) 학번`
          - 밑줄로 표기
- 특수 속성과 특수 관계
  - **관계 집합의 속성**
    - 두 개체 집합의 관계에서 생성되는 값을 저장하는 속성
    - [`예) 수강 신청 일시 (신청 전에는 없던 속성)`](https://user-images.githubusercontent.com/61646760/149973143-a3068924-2510-48a8-85b3-f6cec90c4601.png)
  - **재귀적 관계(Recursive Relationship)**
    - 한 개체 집합이 자기 자신과 관계 집합을 형성하는 관계
    - [`예) 선수과목코드는 같은 집합 내 과목코드와 관계를 가짐`](https://user-images.githubusercontent.com/61646760/149973496-b209f9f3-3e40-4a4f-814b-119f1fa565b7.png)
  - 특수 관계  
    - **약한 개체 집합(Weak Entity Set)**  
      ![image](https://user-images.githubusercontent.com/61646760/149974696-0ca3e774-5d91-40e1-9a9d-7c201806a53c.png) 
      - 개체의 존재 유무가 관계를 맺고 있는 개체의 존재에 종속되는 개체 집합
      - `예) 계좌 개체는 학생 개체에 종속되어, 학생이 자퇴를 하면 계좌도 사라짐`
        - 이중 선은 참가 제약 조건의 전체적 참가 표시!!
    - **강한 개체 집합(Strong Entity Set)**
      - 약한 개체 집합과 연결되는 일반 개체 집합
      - `예) 계좌 개체에 대비되는 학생 개체`

## 3강. 관계형 모델
### 관계형 모델
- **관계형 모델(Relational Model)**
  - 1969년 에드가 F. 코드에 의해 제안
  - 관계(Relation)로 데이터를 표현하는 모델
  - 데이터 표현이 단순하고 직관적인 구조화 모델
  - 현재 대다수 DBMS의 기초
    - 관계형 모델을 사용하는 관계형 DBMS(RDBMS)
    - Oracle, DB2, PostgreSQL, MySQL, MSSQL 등
- **릴레이션(Relation)**
  - 표와 매우 유사한 구조이지만 일반 표와는 달리, 레코드의 유일성, 레코드의 무순서성, 컬럼의 무순서성, 컬럼 값의 유일성이라는 특징을 갖는다.
  - 릴레이션의 구성
    ![image](https://user-images.githubusercontent.com/61646760/150096225-ea4ce392-3c10-45b9-8533-ed30d795a991.png)
    - **스키마(Schema)**
      - 열에 대한 의미를 갖는 표 머리
      - `예) 학과이름, 단과대학, 주소, 전화번호, 졸업학점`
    - **레코드(Record), 튜플(Tuple)**
      - 행
      - `예) 컴퓨터과학과 | 자연과학대학 | ... | 02-3668-4650 | 130`
    - **컬럼(Column), 속성(Attribute), 필드(Field)**
      - 열
      - `예)`
        ```
        전화번호
        02-3668-4550
        02-3668-4590
        02-3668-4640
        ...
        ```
    - **컬럼 값**
      - 하나의 값에 두 개의 메타데이터가 붙은 것
      - 즉, 레코드와 컬럼 간 관계를 통한 데이터
      - `예) 컴퓨터과학과의 전화번호 02-3668-4650`
    - **인스턴스(Instance)**
      - 특정 시점에서 어떤 릴레이션 스키마에 맞춰서 레코드가 들어가 있는 상태
  - 릴레이션의 특징
    - 레코드의 유일성 : 중복된 레코드의 존재가 불가능
    - 레코드의 무순서성 : 레코드의 순서는 의미가 없음
    - 컬럼의 무순서성 : 컬럼의 순서가 없고, 이름과 값의 쌍으로 구성
    - 컬럼 값의 원자성 : 모든 값들은 나눌 수 없는, 단 하나의 의미로 구성
- **키(Key)**
  - 키의 역할
    - 릴레이션의 레코드를 유일하게 식별하는 값
  - 키의 속성
    - **유일성(Uniqueness)**
    - **최소성(Irreducibility)**
  - 키의 종류
    - **수퍼키(super key)**
      - 유일성 만족
      - `예) 학과이름, {학과이름, 단과대학}, 주소, 전화번호, {전화번호, 졸업학점} 등`
        - `{학과이름, 단과대학}`은 유일성은 만족시키나, 최소성은 만족시키지 못함
    - **후보키(candidate key)**
      - 유일성, 최소성 만족
      - `예) 학과이름, 주소, 전화번호`
    - **기본키(primary key: PK)**
      - 레코드의 구분을 위해 선택된 후보키
      - `예) 학과이름`
    - **외래키(foreign key: FK)**
      - 참조된 다른 릴레이션의 기본키
      - 키의 참조는 두 릴레이션에 포함된 레코드 간 연관성을 표현
      - [`예) 학과 개체 집합과 교수 개체 집합 간 외래키(FK) : 소속학과`](https://user-images.githubusercontent.com/61646760/150117396-c2c13cb4-57a0-416d-afb7-a8a3f24aa2bd.png)
- 관계형 모델의 제약 조건(constraints)
  - 영역 제약 조건
    - 컬럼에 정의된 영역(domain)에 속한 값으로만 컬럼 값이 결정
  - 키 제약 조건
    - 키는 레코드를 고유하게 구별하는 값으로 구성
  - 개체 무결성 제약 조건
    - 어떠한 기본키 값도 널(null)이 될 수 없음 (키는 구분에 필요한 고유값이므로 null이면 안 됨)
  - 참조 무결성 제약 조건
    - 반드시 존재하는 레코드의 기본키만 참조 가능 (즉 없는 걸 참조하는 것은 불가능)
- **널(Null)**
  - '없음' 또는 '0'이 아닌 미지의 값에 대한 표현
    - 입력된 적이 없는 값
    - 적용 불가능한 값

### ERD의 변환
- **논리적 데이터 모델링**
  - 관계형 DBMS(RDBMS)의 구현 모델에 맞춰 데이터의 구조와 관계를 표현
    - 작성된 ERD를 RDBMS가 수용 가능한 구조, 즉 릴레이션으로 변환
  - ER 모델링의 결과를 토대로 실제 상용 DBMS상의 데이터베이스를 만들기 위해서는 각 DBMS에 맞는 구현 데이터 모델로의 변환이 필요한데, 이러한 변환 과정을 **논리적 데이터 모델링**이라고 한다.
- ERD의 관계형 모델로의 변환 방법
  1. 개체 집합 : 개체 집합은 릴레이션으로 변환
  2. 약한 개체 집합 : 강한 개체 집합의 키 속성을 약한 개체 집합의 릴레이션에 포함
  3. 일대일 관계 : 두 릴레이션 중에서 한 릴레이션의 기본키를 다른 릴레이션에서 외래키로 참조
  4. 일대다 혹은 다대일 관계 : '일'쪽의 기본키를 '다'쪽 릴레이션에서 외래키로 참조
  5. 다대다 관계 : **관계 릴레이션을 생성하고, 두 릴레이션의 기본키를 각각 참조하는 외래키를 복합키 형태의 컬럼**으로 구성
  6. 다중값 속성 : 릴레이션의 기본키를 참조하는 외래키와 다중값 속성으로 별도의 릴레이션으로 구성
  7. 관계 집합의 속성 : 외래키가 위치한 릴레이션의 컬럼으로 삽입
- ER 다이어그램의 예시1
  ![image](https://user-images.githubusercontent.com/61646760/150123124-2f18e487-bbf9-4183-b7cc-e13e6e1c8d32.png) 
  - 교수 개체 집합은 `교수번호, 교수이름, 직위, 연봉`의 4개 속성으로 구성되어 있다.
  - 교수 개체 집합의 키 속성은 `교수번호`이다. (밑줄)
  - 교수 개체 집합과 과목 개체 집합은 `강의` 관계 집합을 갖는다. (어떤 교수가 어떤 과목을 가르침)
  - 교수 개체 집합과 과목 개체 집합은 `1:N` 관계이다. (1이 화살표, N은 그냥 직선)
    - 즉, 한 명의 교수는 여러 과목을 가르칠 수 있고, 하나의 과목은 반드시 한 명의 교수에 의해서 강의된다.
  - 교수 개체 집합은 부분적 참가, 과목 개체 집합은 전체적 참가이다. (부분적 참가는 그냥 직선, 전체적 참가는 이중 선)
    - 즉, 어떤 교수는 강의를 안 할 수도 있지만(관계 집합에 미참여), 모든 과목은 특정 교수에게 할당되어야 한다.(관계 집합에 무조건 참여)
- ER 다이어그램의 변환 예시1
  ![image](https://user-images.githubusercontent.com/61646760/150121658-0a8ab507-3283-473b-bc6e-afc677cbb4b6.png)
  - RDBMS에서 사용하기 위해 릴레이션으로 변환
    - 하나의 개체 집합은 하나의 릴레이션으로 변환된다.
      - 교수 개체 집합은 교수 릴레이션이 됨
    - 각각의 속성은 각각의 컬럼으로 변환된다.
      - 교수번호, 교수이름, 직위, 연봉 등이 스키마가 됨
    - 키 속성은 기본키 컬럼으로 변환된다.
      - 밑줄 친 교수번호가 교수번호(PK)로 릴레이션에 들어가게 됨
    - 관계 집합은 외래키로 표현되며, `1:N` 구조에서는 `N` 쪽에 외래키를 위치한다.
      - 교수 릴레이션의 교수번호 기본키가 과목 릴레이션에 외래키로 참조된다. 
- ER 다이어그램의 변환 예시2  
  [학생-과목 관계](https://user-images.githubusercontent.com/61646760/150124064-21df98bf-b804-4635-9e61-da20c1c34988.png)
  - `N:M` 즉 다대다 관계 (그냥 직선)
    - 학생은 여러 과목을 수강할 수 있고, 하나의 과목은 여러 학생들이 수강할 수 있음
  - 수강 관계는 어떤 학생이 어떤 과목을 수강 신청하면 그때 `신청시각`이라는 '관계 집합의 속성'이 만들어진다.
    - 다대다 관계는 한쪽이 다른 한쪽의 외래키로 들어갈 수 없으므로, **관계 집합 자체를 하나의 릴레이션**으로 만들어 준다. (다대다 관계에서만)
    - 관계 집합 릴레이션에는 양쪽 릴레이션의 기본키들이 참조되어 외래키로 들어가게 된다. (기본키 역할도 수행)
    - 관계 집합의 속성은 외래키가 위한 릴레이션에 따라 붙는다.
- ER 다이어그램의 변환 예시3  
  [학생-계좌 관계](https://user-images.githubusercontent.com/61646760/150125065-df403600-43fd-4e62-a92d-e9013f533712.png) 
  - `1:1` 관계이므로 각각의 개체 집합을 각각의 릴레이션으로 변환
  - `1:1` 관계에서는 어느 쪽으로든 외래키를 참조 가능하지만, 되도록이면 개수가 적은 쪽으로 외래키를 넣는다.
  - `보유` 관계 집합이 이중 마름모이므로 약한 개체와의 관계를 나타낸다.
    - 약한 관계이므로, 학생이 학생 릴레이션에서 사라지면 그 학생의 계좌번호도 사라진다.
      - 이때 계좌 릴레이션의 외래키인 `학생번호`는 단순히 FK일 뿐 아니라, 계좌 릴레이션의 기본키(PK)인 `계좌번호`와 같이 복합키로서 기본키를 이루게 된다.
      - 이는 참조 무결성 제약 조건에 의해 계좌 릴레이션의 기본키(PK)인 `학생번호`가 Null이 될 수 없어서, 해당 학생의 계좌를 삭제할 수밖에 없게끔 하기 위해서이다.
        - 따라서, 약한 개체 집합에 대해서는, 참조되는 외래키가 그 릴레이션의 기본키가 되게끔 해야 한다.
- [기타 ERD 참고용 링크](https://developer0809.tistory.com/103)

### 데이터 연산
- **관계 연산(Relational Data Operation)**
  - 관계형 모델을 기반으로 구성된 릴레이션을 사용하여 새로운 릴레이션을 생성하는 표현
    - 즉, 기존의 많은 양의 데이터를 가진 릴레이션에서 사용자가 필요로 하는 데이터만 포함한 새로운 릴레이션을 생성
  - 사용자의 관점에서 필요한 데이터를 릴레이션에서 추출하는 방법을 제공하는 도구
    - **관계 대수(Relational Algebra)**
      - 관계 연산을 정의하는 방법
      - 주어진 릴레이션에서 필요한 릴레이션을 만드는 연산자(`∪, ∩, -, σ, π, x, ⋈, ÷, 집계함수` 등)로 구성
      - 관계 대수 연산자는 새로운 임시 릴레이션을 생성
      - 연산자를 중첩하여 연산 처리 절차를 표현
- **셀렉트 연산(SELECT operation)**
  - 주어진 릴레이션에서 조건을 만족하는 레코드를 갖는 릴레이션을 생성  
    σ<sub>조건</sub>(R)
    - `σ` : 셀렉트
    - `(R)` : 대상 릴레이션
    - <sub>조건</sub> : 아래 첨자로, 원하는 조건 입력
      - `aΘb` 또는 `aΘv`
        - `a, b` : 속성 이름
        - `Θ` : 비교자 {`＝, ≠, ＜, ＞, ≤, ≥`}
        - `v` : 상수 값
        - `R` : 릴레이션
      - 조건의 결합 : `∧`(and), `∨`(or)
  - [`셀렉트 연산의 예`](https://user-images.githubusercontent.com/61646760/150130084-e14890a4-3db9-4351-b518-abf86db18474.png)
    - 교수 릴레이션에서 소속학과가 컴퓨터과학과인 레코드만 추출하여 임시 릴레이션 생성
- **프로젝트 연산(PROJECT Operation)**
  - 기술된 컬럼만 갖는 릴레이션으로 재구성  
    π<컬럼리스트>(R)
    - <컬럼리스트> : A1, A2, …, An와 같이 R에 존재하는 컬럼을 ,(콤마)로 분리하여 기술
      - 아래 첨자로 표기
  - [`프로젝트 연산의 예`](https://user-images.githubusercontent.com/61646760/150133368-01705af5-5e1d-4e91-aafa-39c85d0b37c5.png)
    - 교수이름, 소속학과만 있는 릴레이션 생성
- 관계 대수 연산식의 활용
  - [`예) 단계1`](https://user-images.githubusercontent.com/61646760/150133664-ce3bf736-a643-4d56-a69b-6db969b9957f.png), [`예) 단계2`](https://user-images.githubusercontent.com/61646760/150133801-5c4f0f8e-4916-446f-8daf-2652176ad8e8.png)
    - 직위가 부교수인 교수의 교수이름을 출력하기
    - **SELECT**를 통해 부교수 레코드만 뽑아 낸 뒤, **PROJECT**를 통해 교수이름 컬럼만 출력
- **집합 연산자(SET operator)**
  - 릴레이션은 집합, 레코드는 집합에 포함된 원소
    - 합집합
    - 교집합
    - 차집합
  - 집합 연산자 사용 조건
    - 릴레이션 R과 S의 차수가 동일 (즉, 두 릴레이션의 차수가 동일)
      - 차수 : 한 릴레이션에 포함된 컬럼의 개수
    - 모든 i에 대해 R의 i번째 컬럼의 도메인과 S의 i번째 컬럼의 도메인이 반드시 동일 (문자에 대한 컬럼인지 숫자에 대한 컬럼인지 도메인이 동일)
- **카테시안 프로덕트 연산(Cartesian Product Operation)**
  ![image](https://user-images.githubusercontent.com/61646760/150135441-48461b14-d821-4ed0-b44f-94766b0576a3.png)
  - 두 릴레이션에 포함된 레코드 간의 모든 조합을 생성하는 이항 연산자  
    `R × S`
  - [`예) 카테시안 프로덕트 연산`](https://user-images.githubusercontent.com/61646760/150135722-600f22ba-25d4-403a-b90c-3d1023d14654.png), [`예) 카테시안 프로덕트 연산 결과`](https://user-images.githubusercontent.com/61646760/150135803-d9bc166e-65a5-49b0-b933-8f3a5ffc4a70.png)
  - 자주 사용하는 중요한 연산
- **조인 연산(JOIN operation)**
  - 두 릴레이션에서 조건을 만족하는 레코드를 결합한 레코드로 구성된 릴레이션을 생성  
    R⋈<sub>AθB</sub>S
    - JOIN 연산은 카테시안 프로덕트 연산과 SELECT 연산의 결합  
      σ<sub>AθB</sub>(R × S)
  - '컴퓨터과학과' 소속의 교수가 강의하는 과목의 과목명과 과목코드는?
    - 교수 릴레이션과 과목 릴레이션이라는 서로 다른 두 개의 릴레이션에서 추출할 필요가 있다.
    - 아래 조인 연산의 예에서 한 단계만 더 수행하면 됨
  - [`조인 연산의 예`](https://user-images.githubusercontent.com/61646760/150163298-865ff02c-4f35-433d-9761-8356083d21bb.png)
    - 과목 릴레이션의 교수번호와 교수 릴레이션의 교수번호가 같은 레코드만 생성
    - 카테시안 프로덕트 & SELECT 연산과 동일 : [`카테시안`](https://user-images.githubusercontent.com/61646760/150162393-be1b6ba2-99e0-4d65-9a2b-8979c0a9148e.png), [`카테시안 결과`](https://user-images.githubusercontent.com/61646760/150162808-61ee9b1c-7a55-493b-892d-9fdfd16cbffa.png), [`SELECT 결과`](https://user-images.githubusercontent.com/61646760/150162946-605b5871-5823-4f48-b334-3210f88acada.png)
- **집계 함수 연산(Aggregate Function Operation)**
  - 집계 함수를 값들의 집합 또는 레코드의 집합에 적용하는 연산  
    ![image](https://user-images.githubusercontent.com/61646760/150164696-98094b6d-b548-4bb4-9650-2b2fe9af0552.png)
    - `x()` : AVG, SUM, MIN, MAX, COUNT 등의 집계 함수
    - `A` : 집계 연산을 적용할 컬럼
  - 레코드 그룹화를 위해 집계 함수 연산자 앞에 그룹화 속성을 기술  
    ![image](https://user-images.githubusercontent.com/61646760/150165684-090f8d57-bb42-42d9-bf1b-dff194a05e76.png)
    - `B` : 그룹의 기준이 되는 컬럼
    - `x()` : 집계 함수
    - `A` : 집계 연산을 적용할 컬럼
    - `R` : 릴레이션
  - [`집계 함수의 예 : count 연산`](https://user-images.githubusercontent.com/61646760/150165061-9a7c9726-00f7-4089-811c-89a316cc18e8.png)
  - [`집계 함수의 예 : 소속학과별 교수 count`](https://user-images.githubusercontent.com/61646760/150166134-83c2b3a6-5cfc-4063-acb8-a5fe0abe9f4e.png)
    - 즉, 그룹별로 수행하는 집계 함수 연산

## 4강. SQL (1)
### 데이터베이스 언어
- **SQL(Structured Query Language)**
  - 관계 대수에 기초하여 RDBMS의 데이터 관리를 위해 설계된 언어
  - 1986년 ANSI, 1987년 ISO에서 표준으로 제정
    - `SQL 86, SQL 89, SQL 92, SQL:1999, SQL:2003, SQL:2008`
    - 상용 DBMS의 특성에 맞게 국제표준을 확장한 독자적 버전이 존재
  - 특징
    - 비절차적(선언형) 언어, 필요한 데이터만 기술
    - 자연어와 매우 유사하고 간단, 명료함
  - 구성
    - **데이터 정의 언어(DDL: Data Definition Language)**
      - 데이터베이스 내의 객체를 생성 및 삭제하고 그 구조를 수정하는 명령어의 집합
      - 데이터가 준수해야 하는 제약 조건을 기술
      - `CREATE`, `ALTER`, `DROP`문 등
    - **데이터 조작 언어 (DML: Data Manipulation Language)**
      - DDL에 의해 정의된 테이블에 데이터를 조작하는 명령어의 집합
      - 데이터에 대한 CRUD(생성, 검색, 삭제, 수정) 명령을 포함
      - `INSERT`, `UPDATE`, `DELETE`, `SELECT`문 등
### 데이터 정의 언어
- **데이터 정의 언어(DDL: Data Definition Language)**
  - 데이터베이스 객체를 생성, 삭제 또는 구조를 수정하는 명령어의 집합
  - 데이터베이스 객체의 종류
    - 데이터 저장 : 테이블(Table), 인덱스(Index), 뷰(View)
    - 데이터 조작 : 트리거(Trigger), 프로시저(Procedure), 함수(function) 등
  - DDL 명령어 종류
    - `CREATE` : 객체 생성
    - `ALTER` : 객체 수정
    - `DROP` : 객체 삭제
  - [DDL의 구문 형식](https://user-images.githubusercontent.com/61646760/150523924-eb4f0662-7006-4010-8477-dbf0786d13f5.png)
    - 테이블 정의 구문 형식
      - 새로운2 차원 형태의 테이블을 생성
        ```
        CREATE TABLE 테이블이름 (
          <컬럼1> <데이터 타입1> [제약조건1]
          <컬럼2> <데이터 타입2> [제약조건2]
          ...
          <컬럼n> <데이터 타입n> [제약조건n]
         [PRIMARY KEY 컬럼명]
         [UNIQUE 컬럼명]
         [FOREIGN KEY 컬럼 REFERENCES 테이블이름(컬럼)]
        )
        ```
      - [`테이블 생성의 예`](https://user-images.githubusercontent.com/61646760/150525505-924d05f9-ea10-427f-839b-eaca190e3d32.png)
    - 테이블 수정 구문 형식
      - 생성된 테이블에 새로운 컬럼을 추가, 수정(이름, 데이터 타입, 제약 조건) 또는 삭제하는 명령
        ```
        ALTER TABLE 테이블이름
          [ADD COLUMN 컬럼 데이터타입 [제약조건]]
          [DROP COLUMN 컬럼이름]
          [CHANGE COLUMN 수정전컬럼 수정후컬럼]
          [MODIFY COLUMN 컬럼 데이터타입]
        ```
      - 위에서부터 컬럼 추가, 컬럼 삭제, 컬럼명 변경, 컬럼 데이터 타입 변경
      - [`테이블 수정의 예) 교수 테이블에 데이터 타입이 INT인 나이 컬럼을 추가하시오`](https://user-images.githubusercontent.com/61646760/150538679-71981ea1-8558-49b0-9269-904e81d87302.png)
        ```
        ALTER TABLE 교수
          ADD COLUMN 나이 INT
        ```
    - 테이블 삭제 구문 형식
      - 존재하는 테이블을 스키마에서 삭제
      - 삭제할 테이블의 모든 데이터가 소실되어 복구가 불가능한 연산이므로 각별한 주의를 요구
        ```
        DROP TABLE 테이블이름
        ```
      - `테이블 삭제의 예) 교수 테이블을 삭제하시오.`
        - `DROP TABLE 교수`
- **스키마(Schema)**
  - 한 조직의 데이터베이스 시스템 운영에 필요한 테이블, 인덱스, 뷰 등의 데이터베이스 객체의 집합
    - 즉, `스키마 = 데이터베이스`
  - 스키마 관리 방법
    - Forward Engineer
    - SQL 에디터
    - 내비게이터 패널
  - 스키마 관리 구문 형식
    - 스키마 생성 : `CREATE SCHEMA 스키마 이름`
    - 스키마 삭제 : `DROP SCHEMA 스키마 이름`
- **데이터 타입(Data Type)**
  - 컬럼이 가질 수 있는 값의 범위, 즉 도메인을 결정
    - 프로그래밍 언어에서 변수를 생성하는 데이터 타입의 사용 목적 및 방법과 매우 유사
  - 기본 데이터 타입
    - 문자 : `CHAR(n)`, `VARCHAR(n)`, `TEXT`
    - 숫자 : `INT`, `FLOAT`, `DOUBLE`, `DECIMAL(m, n)`
    - 날짜/시간 : `DATE`, `TIME`, `DATETIME`, `TIMESTAMP`
  - 정수 데이터 타입
    - `TINYINT`
      - 1바이트 정수, -128~127
      - 나이, 학년 등의 크기가 작은 정수
    - `SMALLINT`
      - 2바이트 정수, -32768~32767
      - 물품 번호, 인원 등 중간 크기의 정수
    - `INT`
      - 4바이트 정수, 약 -20억~20억
      - 물품의 금액, 전화번호 등의 일반 크기의 정수
    - `BIGINT`
      - 8바이트 정수
      - 계좌의 잔고, 천문학적인 크기의 정수
  - 실수 데이터 타입
    - 고정 소수형
      - `DECIMAL(M, N)` : 전체 M자리, 소수점 이하 N자리의 숫자
        - `예)` `DECIMAL(5, 2)`는 -999.99~999.99
      - `NUMERIC` : `DECIMAL`과 동일
    - 부동 소수형
      - `FLOAT` : 4바이트 크기 부동 소수
      - `FLOAT(P)` : 소수점 이하 P개 자리의 부동 소수
      - `DOUBLE` : 8바이트 크기 부동 소수형
  - 날짜/시간 데이터 타입
    - 날짜 데이터 타입
      - `DATE` : `YYYY MM DD` 형식의 시간
      - `YEAR` : `YYYY` 형식의 연도
    - 시간 데이터 타입
      - `TIME` : `HH:MI:SS` 형식의 시간
    - 날짜/시간 데이터 타입
      - `DATETIME` : `YYYY MM DD HH:MI:SS` 형식의 날짜 및 시간
      - `TIMESTAMP` : `DATETIME`과 거의 동일
  - 문자 데이터 타입
    - `CHAR(N)` : 최대 길이가 N인 고정 길이 문자열
    - `VARCHAR(N)` : 최대 길이가 N인 가변 길이 문자열
      - 'DATABASE' 문자열 입력 시, 두 타입의 차이
        ![image](https://user-images.githubusercontent.com/61646760/150534788-3888868c-b519-46b7-9f19-140a96cad294.png)
        - 10칸이 고정이냐, 가변이냐의 차이
          - `VARCHAR`가 유연해서 더 좋다고 생각할 수 있으나, 입력된 값이 변경되면 그 길이에 맞춰 뒤의 값들도 당겨지거나 밀리게 되므로, 자주 수정되는 값의 타입을 `VARCHAR`로 설정하면 악수가 될 수 있다.
        - [CHAR와 VARCHAR](https://user-images.githubusercontent.com/61646760/150535257-35813192-3b1c-4110-a784-bb1ab6aacdbc.png)
    - `TEXT`, `CLOB` : 길이가 최대 2~4GB인 가변 길이 문자열
    - `ENUM` : 유한 개의 문자열 집합 중 하나의 값을 선택
      - 성별 : `ENUM('남', '여')`
      - 혈액형 : `ENUM('A', 'B', 'O', 'AB')`
- **제약 조건(Constraint)**
  - 테이블과 테이블에 존재하는 데이터를 보다 무결하게 관리하기 위한 목적으로 사용
    - DBMS는 테이블 조작 시 테이블에 정의된 제약 조건을 만족시키는지 지속적으로 검사
      - 즉, 제약 조건을 만족하지 않는 데이터를 DBMS에서 거절함
    - DBMS는 적용하려는 제약의 유형에 따라 다양한 제약 조건을 지원
  - 제약 조건의 종류
    - `PRIMARY KEY` : 기본키 지정, `UNIQUE`와 `NOT NULL`특성을 모두 가짐
    - `FOREIGN KEY` : 외래키 지정, 참조 컬럼 정의
    - `NOT NULL` : NULL이 될 수 없는 컬럼에 지정
    - `UNIQUE` : 동일한 컬럼 값을 가질 수 없음을 지정
    - `AUTO_INCREMENT` : 레코드가 추가될 때 자동적으로 속성 값이 1부터 1씩 증가되어 입력
    - `CHECK` : 컬럼 값이 특정 조건 준수 여부 지정
  - [제약 조건 사용의 예1](https://user-images.githubusercontent.com/61646760/150542488-b5e7cc42-09d7-43e0-9882-cb16a1f68470.png)
  - [제약 조건 응용해 보기](https://user-images.githubusercontent.com/61646760/150542672-532c3f48-dde8-4b9e-9678-8941095f0324.png)
    - [제약 조건 응용해 보기 답안](https://user-images.githubusercontent.com/61646760/150542745-27ff76d5-2c6c-4f6a-b7b9-eb1f359a6aa7.png)

## 5강. SQL (2)
### 데이터 삽입, 수정, 삭제
- **데이터 조작 언어(Data Manipulation Language: DML)**
  - 정의된 테이블에 레코드를 삽입·수정·삭제 및 검색하는 데 사용되는 명령어의 집합
  - DML 명령어의 종류
    - `INSERT` : 테이블 스키마에 적합한 새로운 레코드를 삽입
      - 구문 형식1
        ```
        INSERT INTO 테이블 이름
          VALUES(값1, 값2, … 값n)
        ```
      - 구문 형식2
        ```
        INSERT INTO 테이블이름(컬럼1, 컬럼2, … 컬럼m)
          VALUES(값1, 값2, … 값m)
        ```
      - [`예) 학과이름 '영어영문학과', 단과대학 '인문과학대학', 주소 'http://eng.knou.ac.kr', 전화번호 '02-3668-4510', 졸업학점 135인 레코드를 학과 테이블에 삽입하시오.`](https://user-images.githubusercontent.com/61646760/150636388-fa491475-a3d4-4ca9-90b0-3da959a62fbb.png)
        - [정답 보기](https://user-images.githubusercontent.com/61646760/150636403-b2afec50-58b1-4449-a91e-bb6f6ed3a3b3.png)
      - [`예) 단과대학 '자연과학대학', 학과이름 '농학과', 졸업학점 140, 전화번호 '02-3668-4600'인 레코드를 학과 테이블에 삽입하시오.`](https://user-images.githubusercontent.com/61646760/150730035-7c440c08-e96a-4b69-8f97-51215a484dde.png)
        - [정답 보기](https://user-images.githubusercontent.com/61646760/150730115-6f884898-20fa-490b-81f2-1921fae3213d.png) (학과 이름 오기)
    - `UPDATE` : 테이블에서 조건을 만족하는 특정 레코드의 컬럼 값을 수정
      - 구문 형식1
        ```
        UPDATE 테이블이름
          SET 컬럼1=값1 [, 컬럼2=값2, …, 컬럼n=값n]
          [WHERE 조건]
        ```
      - 구문 형식2
        ```
        UPDATE 테이블이름
          SET 컬럼1=수식1 [, 컬럼2=수식2, …, 컬럼n=수식n]
          [WHERE 조건]
        ```
      - [`예) 학과이름이 '농학과'인 레코드의 주소 컬럼 값을 'http://agri.knou.ac.kr'로 수정하시오.`](https://user-images.githubusercontent.com/61646760/150730416-040970da-debb-47c7-a1ca-e2e8762edce9.png)
        - [정답 보기](https://user-images.githubusercontent.com/61646760/150730517-6322e911-7f35-4076-8a92-9dec0ab9785d.png) (학과 이름 오기)
      - [`예) 잔액이 500,000원 이상인 학생 계좌에 2% 이자를 지급하시오.`](https://user-images.githubusercontent.com/61646760/150730609-123b0da8-6ddc-4c58-aaeb-4461ee37620e.png)
        - [정답 보기](https://user-images.githubusercontent.com/61646760/150730681-ba214585-c6fa-4920-aae3-84c7e31f2989.png)
    - `DELETE` : 테이블에 조건을 만족하는 특정 레코드를 삭제
      - 구문 형식
        ```
        DELETE FROM 테이블이름
          [WHERE 조건]
        ```
      - [`예) 소속학과가 '행정학과'인 교수의 레코드를 삭제하라.`](https://user-images.githubusercontent.com/61646760/150730821-1d4c8683-1dee-40ee-b151-4bdbac5286ec.png)
        - [정답 보기](https://user-images.githubusercontent.com/61646760/150730944-9d256df7-dfbf-43c5-b423-98fefb4e941a.png)
      - [`예) 모든 강의 레코드를 삭제하시오.`](https://user-images.githubusercontent.com/61646760/150731013-da9503f4-4288-4a64-b763-1091aad60a9c.png)
        - [정답 보기](https://user-images.githubusercontent.com/61646760/150731151-09933eec-dc84-4ff0-8fbb-42e73f1f86d9.png)
      - **SAFE UPDATES 모드**  
        `SET SQL_SAFE_UPDATES = 0 또는 1`
        - WHERE절이 없는 UPDATE/DELETE문은 테이블의 전체 레코드를 변경/삭제함
        - 이때 의도하지 않은 데이터 변경/삭제 방지를 위해 MySQL은 **SAFE UPDATES 모드**를 지원
        - 기본키가 아닌 컬럼을 대상으로 수정/삭제 조건을 명시할 경우 실행 여부를 결정
    - `SELECT` : 조건을 만족하는 레코드를 테이블에서 검색
      - 자세한 것은 아래 상술
### 데이터 검색 (1)
- **SELECT문**
  - 한 개 이상의 테이블에서 주어진 조건에 만족하는 레코드를 출력하는 명령문
    - 관계 대수의 셀렉션, 프로젝션, 조인, 카티션 프로덕트 연산자의 기능을 모두 포함하는 명령문
    - 필수적 절인 SELECT절과 부가적인 목적으로 사용할 수 있는 여러 절을 혼합하여 검색 기능을 구체화
  - SELECT문의 구문 형식
    ```
    SELECT [DISTICT] 컬럼1, 컬럼2, ..., 컬럼n
      FROM 테이블1 INNER JOIN | OUTER JOIN 테이블2 INNER JOIN | OUTER JOIN
           ON 조인 조건1
      [WHERE 조건식 [중첩질의]]
      [GROUP BY 컬럼1, 컬럼2, ..., 컬럼y
        [HAVING 조건]]
      [ORDER BY 컬럼1 [ASC | DESC], ... 컬럼z [ASC | DESC]]
    ```
    - 보다 단순한 구문 형식
      ```
      SELECT 열 이름
        FROM 테이블 이름
        WHERE 조건
      ```
  - SELECT문의 각 절의 기능
    - `SELECT` 절 : 결과에 포함되는 컬럼을 지정
    - `FROM` 절 : 질의를 적용할 테이블을 지정
    - `ON/WHERE` 절 : 조인 조건/검색할 레코드 조건을 지정
    - `GROUP BY` 절 : 레코드를 그룹화하기 위한 그룹 조건을 지정
    - `HAVING` 절 : `GROUP BY` 절이 적용된 결과에 대한 조건을 지정
    - `ORDER BY` 절 : 검색 결과의 정렬 기준을 지정
- **단순 질의문(Simple Query)**
  - 레코드를 제한하지 않고 전체 테이블을 검색하는 SELECT 문으로 WHERE 절이 없는 질의문
  - 구문 형식1
    ```
    SELECT 컬럼1, 컬럼2 …, 컬럼n
      FROM 테이블
    ```
  - 구문 형식2
    ```
    SELECT *
      FROM 테이블
    ```
  - [`예) 교수 테이블에서 '소속학과' 컬럼을 선택하여 출력하시오.`](https://user-images.githubusercontent.com/61646760/150732640-e5f71dbf-6712-48b3-b88a-f89b43445a41.png)
    - [정답 보기 : 중복 허용](https://user-images.githubusercontent.com/61646760/150732696-84e37641-96df-4f73-9314-533f0ab3b51f.png)
    - [정답 보기 : 중복 비허용](https://user-images.githubusercontent.com/61646760/150733005-eec22931-04b7-46c1-b3de-708b86e9b002.png)
      - `DISTINCT` : 중복 제거 키워드
  - [`예) SELECT *`](https://user-images.githubusercontent.com/61646760/150733161-9f7277bd-45ef-4a32-bf1f-7c06b2f5fd29.png)
- **조건 질의문(Conditional Query)**
  - 산술연산식, 함수 등을 사용하여 표현한 조건을 `WHERE` 절에 기술하여 조건을 만족하는 레코드만 검색하는 `SELECT` 문
    - 산술 연산자
      - `SELECT` 절 또는 `WHERE` 절에 사용되어 컬럼 값 또는 상수와의 산술 계산을 나타내는 연산자
        ![image](https://user-images.githubusercontent.com/61646760/150733578-fe15e389-0755-4d7e-b453-3467471ff169.png)
    - 비교 연산자
      - 컬럼 값과 상수 또는 컬럼 값과 다른 컬럼 값과의 크기를 비교하는 연산자
        ![image](https://user-images.githubusercontent.com/61646760/150733614-fc127a54-2ca9-4292-b4be-2d9f2de54a50.png)
    - 논리 연산자
      - 두 개 이상의 조건이 기술되는 질의문에서 조건식 간의 관계를 정의하는 연산자
        ![image](https://user-images.githubusercontent.com/61646760/150733660-5ae905d7-e324-4f44-b49f-7a51dad83e81.png)
  - `WHERE` 절은 `UPDATE`, `DELETE` 문에서도 동일하게 적용
  - [`예) 이수구분 전공필수인 과목의 과목명, 학점, 선수과목을 출력하시오.`](https://user-images.githubusercontent.com/61646760/150733777-bba004d0-808b-4d0b-b7ba-d5e36c93f702.png)
    - [정답 보기](https://user-images.githubusercontent.com/61646760/150733850-95bd1eee-0acc-445b-8a54-8fc63b69254f.png)
  - [`예) 남학생 중 2000년 이전에 태어난 학생의 학생번호, 학생이름, 전화번호, 나이를 출력하시오.`](https://user-images.githubusercontent.com/61646760/150733900-7e002513-5e07-49bf-a012-5d6a44662ddc.png)
    - [정답 보기](https://user-images.githubusercontent.com/61646760/150733966-deddbbca-f1f2-4d59-853d-b549e35b393e.png)
- **데이터 정렬**
  - `ORDER BY` 절을 사용
  - 검색 결과를 특정 컬럼에 대해 오름차순 또는 내림차순으로 정렬
    - 오름차순 : `ASC`
    - 내림차순 : `DESC`
  - 구문 형식
    ```
    SELECT 문 형식
      ORDER BY 컬럼1 [ASC|DESC], 
                …,
               컬럼n [ASC|DESC]
    ```
  - [`예) 학생의 계좌정보를 '잔액' 기준으로 각각 오름차순, 내림차순으로 정렬하시오.`](https://user-images.githubusercontent.com/61646760/150734297-cecce600-e26a-4bf8-aae6-ddae8e345fc1.png)
    - [정답 보기 : 오름차순](https://user-images.githubusercontent.com/61646760/150734381-67dedb1a-f7d2-4ef2-8310-ceca1236b588.png)
    - [정답 보기 : 내림차순](https://user-images.githubusercontent.com/61646760/150734485-f3261b56-da9a-41a8-b877-f5708885e46c.png)
- **특수 연산자**
  - 범위 포함 여부, 부분 일치 여부, 포함 여부 등 **관계형 데이터베이스에서만 사용**되도록 고안된 연산자
    ![image](https://user-images.githubusercontent.com/61646760/150734603-61947611-901e-4e1e-b498-1803f2536308.png)
  - [`예) 잔액이 20만원 이상 40만원 이하인 계좌의 계좌번호, 잔액, 학생번호를 출력하시오.`](https://user-images.githubusercontent.com/61646760/150734692-6ae8d8f9-cd1c-4967-87d8-9e8041a20656.png)
    - [정답 보기 : 비교 연산자 사용](https://user-images.githubusercontent.com/61646760/150734783-e6d167da-7cd3-452c-8209-081ebc1832bc.png)
    - [정답 보기 : 특수 연산자 `BETWEEN` 사용](https://user-images.githubusercontent.com/61646760/150734872-3aa3d8e1-4d6e-448f-96c9-629f28bd18b1.png)
  - [`예) 소속학과가 '컴퓨터과학과', '행정학과', '법학과'인 교수의 교수이름, 직위, 소속학과를 출력하시오.`](https://user-images.githubusercontent.com/61646760/150734997-a8f37bc3-ad70-461d-a472-cffddd865d91.png)
    - [정답 보기 : 비교 연산자 사용](https://user-images.githubusercontent.com/61646760/150735065-7ef58f8a-a777-44bb-b7de-22cc334662df.png)
    - [정답 보기 : 특수 연산자 `IN` 사용](https://user-images.githubusercontent.com/61646760/150735115-65f7f48e-5578-4b4a-8133-77aece79785f.png)
  - [`예) 과목코드가 'COM'으로 시작하는 과목의 과목코드, 과목명, 이수구분을 출력하시오.`](https://user-images.githubusercontent.com/61646760/150735179-e3f71d36-2728-49b9-8b27-30bcbd6b5d6d.png)
    - [잘못된 답안](https://user-images.githubusercontent.com/61646760/150735283-f32a9068-56b5-4d2e-b1be-680161d09679.png)
    - [정답 보기 : 특수 연산자 `LIKE` 사용](https://user-images.githubusercontent.com/61646760/150735320-ed3ff589-6964-450f-acb3-286154a01cb2.png)
- **함수(Function)**
  - 특정 목적을 수행하도록 사전에 정의된 연산 및 기능을 수행한 후 결괏값을 반환하는 명령어 집합
  - 상용 DBMS는 검색 결과가 사용자에게 여러 형태로 사용될 수 있도록 여러 데이터 타입에 대한 다양한 함수를 제공 (MySQL 기준)
    - 문자 함수
      - 문자열 조작 및 문자 형식 변환 등의 문자와 관련된 다양한 연산을 지원하는 함수
        ![image](https://user-images.githubusercontent.com/61646760/150735649-f3813363-9f52-45ad-a8dd-2d1c94783516.png)
    - 숫자 함수
      - 삼각 함수, 상수, 올림과 버림, 난수 등의 숫자 데이터 타입에 적용할 수 있는 계산을 위한 함수
        ![image](https://user-images.githubusercontent.com/61646760/150735598-2871772f-b76a-4e35-9e1a-07aa8379e403.png)
    - 날짜 및 시간 함수
      - 날짜 및 시간 데이터 타입에 적용되어 산술 연산 및 시간 형 변환 등의 조작을 위한 함수
        ![image](https://user-images.githubusercontent.com/61646760/150735734-abc9e7c6-8ad0-43cd-bd26-f151a94baa14.png)
  - [`예) 학생의 학생번호, 학생이름, 성별, 생년월일을 출력하시오. 단 학생번호는 앞 6자리만 출력하고 성별 뒤에는 '성'을 붙이시오.`](https://user-images.githubusercontent.com/61646760/150735778-ffc4f124-2e07-4b9b-91aa-5cd61ebc14c5.png)
    - [정답 보기](https://user-images.githubusercontent.com/61646760/150735861-d4abd8ed-0a4c-4212-b44b-756f35886e30.png)

## 6강. SQL (3)
### 데이터 검색 (2)
- **집계 함수(Aggregate function)**
  - 특정 컬럼에 집계 함수를 통해 다양한 통계 연산을 수행할 수 있는 기능
    - `SELECT` 절 또는 `HAVING` 절에 기술
  - 집계 함수의 종류
    - `COUNT` : 컬럼에 있는 값들의 개수
    - `SUM` : 컬럼에 있는 값들의 합
    - `AVG` : 컬럼에 있는 값들의 평균
    - `MAX` : 컬럼에서 가장 큰 값
    - `MIN` : 컬럼에서 가장 작은 값
  - [`예) 단과대학의 개수를 출력하시오.`](https://user-images.githubusercontent.com/61646760/150988882-cc327fab-6ba5-4570-b1b0-c25df5cd2072.png)
    - [정답 보기 : 단과대학 전체 개수](https://user-images.githubusercontent.com/61646760/150988784-89a13463-5f5f-46ad-b029-9024b62bd79a.png)
    - [정답 보기 : `DISTINCT`를 통한 중복 제거 개수](https://user-images.githubusercontent.com/61646760/150989026-fa696cef-ceaa-4538-8491-2e0aeae5bc8b.png)
      - `COUNT` 함수 내부에 `DISTINCT` 사용
    - [정답 보기 : `AS`를 통한 임시 컬럼명 변경](https://user-images.githubusercontent.com/61646760/150989197-cfcaa8e3-5020-4936-a865-9062ec2f9af1.png)
      - `COUNT` 함수 뒤에 `AS 컬럼명` 사용
- **그룹 질의(Group Query)**
  - 특정 기준으로 레코드를 그룹화하고 각 레코드 그룹에 대해 집계 함수를 적용하는 질의
    - **주의 : SELECT 절에 그룹의 기준과 집계 함수 이외의 컬럼은 포함될 수 없음**
      - [`예) 잘못된 예시`](https://user-images.githubusercontent.com/61646760/150990166-e2d7c85c-826a-492d-82d8-568fc8bcd392.png)
        - 그룹의 기준은 `GROUP BY` 뒤의 컬럼(소속학과), 집계 함수의 컬럼은 `SELECT` 뒤의 컬럼(소속학과)
  - 구문 형식
    ```
    SELECT 질의
      GROUP BY 컬럼
    ```
  - [`예) 소속학과별 교수의 수를 출력하시오.`](https://user-images.githubusercontent.com/61646760/150989937-0636c94d-bf4d-4dc4-9407-a7cd7e600ec2.png)
    - [정답 보기](https://user-images.githubusercontent.com/61646760/150990102-fdea6eb0-8741-456a-a388-2fb9be5d9599.png)
  - **HAVING절**
    - 그룹 질의의 결과 레코드에 대해 출력 조건을 기술하기 위한 절
    - 구문 형식
      ```
      SELECT 질의
        GROUP BY 컬럼
        HAVING 조건
      ```
    - 조건 기술 절
      - `WHERE` : 레코드에 대한 조건을 기술
      - `HAVING` : 집계 결과 레코드에 대한 조건을 기술
  - [`예) 2개 이상의 전공을 신청한 학생의 학생번호와 신청 전공수를 출력하시오.`](https://user-images.githubusercontent.com/61646760/150990930-1108b87a-3fca-402f-86b5-290cfe0a00b2.png)
    - [학생번호별 신청 전공수 `COUNT`](https://user-images.githubusercontent.com/61646760/150991282-6e1111e2-cd08-42ec-b03d-9f5fc795cef6.png)
    - [정답 보기 : 신청 전공수 2 이상 `COUNT`](https://user-images.githubusercontent.com/61646760/150991694-4460e5b4-b64c-47e6-8a90-b7a96520a3c6.png)
- **중첩 질의(Nested Query)**
  - `SELECT` 문 내부에서 독립적으로 실행 가능한 또 다른 `SELECT` 문이 내포되어 있는 질의
    - 일반적으로 내부 질의의 처리 결과를 외부 질의에서 재사용
  - 중첩 질의의 종류
    - `FROM` 절에서의 중첩 질의 활용
      - `FROM` 절에서의 결과 집합을 `SELECT`에서 재검색
    - `WHERE` 절에서의 중첩 질의 활용
      - `WHERE` 절에서의 결과 집합을 활용하여 외부 질의에서 레코드의 출력 여부를 결정
      - `IN`, `NOT IN`, `EXISTS`, `NOT EXSISTS` 사용
        - `EXISTS`, `NOT EXISTS` : 데이터를 하나씩 뽑아서 확인할 때 사용
  - 중첩 질의의 형식
    - 구문 형식1
      ```
      SELECT 컬럼1, 컬럼2, ..., 컬럼n
        FROM (SELECT 컬럼1, 컬럼2, ..., 컬럼m
                     FROM 테이블
                     WHERE 조건)
        WHERE 조건
      ```
      - 내부 `SELECT` 문의 처리 결과가 릴레이션으로 나오므로, 그것을 테이블 삼아 외부 `SELECT` 문 처리
    - 구문 형식2
      ```
      SELECT 컬럼1, 컬럼2, ..., 컬럼n
        FROM 테이블1
        WHERE 컬럼i 연산자 (SELECT 컬럼j
                                  FROM 테이블
                                  WHERE 조건)
      ```
  - [`예) FROM 절에서의 중첩 질의 활용 : 학과별 교수의 평균 연봉이 70,000,000 미만인 학과 중 가장 높은 평균 연봉을 출력하시오.`](https://user-images.githubusercontent.com/61646760/151350283-75ddef42-529d-4c1c-9d16-92b208b0de5c.png)
    - [정답 보기1 : 먼저 그룹 질의를 통해 학과별 평균 연봉 구하기](https://user-images.githubusercontent.com/61646760/151351216-7647d21e-cfcb-4f49-afce-b15a75e3cf13.png)
    - [정답 보기2 : 위의 테이블에서 평균 연봉이 7천만 미만인 학과 중 `MAX(평균연봉)`을 구해 평균연봉 컬럼으로 출력하기](https://user-images.githubusercontent.com/61646760/151351822-f0f34996-6228-4d2d-a3ac-1df4d2b6576d.png)
  - [`예) WHERE절에서의 중첩 질의 활용 : '생활과학과' 소속 학생 중 수강 신청을 하지 않은 학생의 학생번호를 출력하시오.`](https://user-images.githubusercontent.com/61646760/151352496-69a15646-4230-4753-84b4-d2630c096265.png)
    - [정답 보기1 : 전공 테이블에서 생활과학과 학생 번호만 추출하기](https://user-images.githubusercontent.com/61646760/151353724-65df317a-59c0-4bdd-826d-b23c67cf86e0.png)
    - [정답 보기2 : '수강 테이블의 학생 번호 = 전공 테이블에서 추출한 학생 번호' 확인 후 일치하면 수강 신청한 것이므로 `False` 처리](https://user-images.githubusercontent.com/61646760/151353769-d5f446b0-9b79-42ba-8200-b04ecce71cc3.png)
- **조인 질의(Join Query)**
  - 테이블 간의 관련성을 이용하여 두 개 이상의 테이블에서 데이터를 검색하는 질의 기법
    - 즉, 두 개의 테이블 나눠져 있는 데이터를 하나로 결합시켜 출력하는 질의
    - SQL의 백미라고 할 정도로 자주 사용되는 질의 기법
    - ER 모델링 및 정규화 기법으로 여러 테이블로 분리된 정보를 통합하여 검색 시 유용
  - 조인 질의의 종류  
    ![image](https://user-images.githubusercontent.com/61646760/151369292-e8ae27e6-54b5-466d-8ff9-ad3c540c6dd0.png)
    - **내부 조인(Inner Join)**
      - 두 개 이상의 테이블에서 **조인 조건을 만족하는 레코드만 결합하여 출력** 결과에 포함시키는 연산
        - 조인 조건은 `WHERE` 절이 아닌 **`ON` 절**에 기록
        - ANSI SQL 표준과 사실상의 표준인 Oracle사가 제안한 조인 형식이 사용
        - 외부 조인보다 많이 사용되는 편
      - 구문 형식
        ```
        SELECT 컬럼1, 컬럼2, …, 컬럼m
          FROM 테이블1 INNER JOIN 테이블2
          ON 조인 조건1
          [WHERE 조건]
        ```
        - 두 테이블 사이에 `INNER JOIN`이라고 명시해 줌으로써 결합
        - 이때 결합 조건을 `ON`에 명시
      - `예) 나이가 30세 이상인 학생의 학생이름과 나이, 그리고 그 학생이 소유한 계좌의 계좌번호, 잔액을 출력하시오.`
        - [정답 보기1 : 학생 테이블에서 30세 이상 학생이름, 나이, 학생번호 출력](https://user-images.githubusercontent.com/61646760/151363754-fb5edc1a-0a9a-435e-b000-f38da7520359.png)
          - 계좌 테이블에 학생번호 컬럼이 있으므로 결합을 위해 학생번호까지 출력
          - 계좌 테이블에 없는 학생은 계좌가 없는 것이므로 join 결합에 포함이 안 됨
        - [정답 보기(ANSI 표준)](https://user-images.githubusercontent.com/61646760/151366772-a7c3960d-ea47-4f2e-abe2-50ea37514a0f.png)
          - `ON`에서 `계좌.계좌번호`가 아니라 `계좌.학생번호`임 (오류)
        - [정답 보기(Oracle)](https://user-images.githubusercontent.com/61646760/151366854-c673cec5-81cc-437a-a90a-21497a4f1d26.png)
          - 외부 조인, 내부 조인 구분 없이 `,`로 Cross join하여 FROM 절에 넣어 줌
          - `WHERE` 절에 join에 대한 조건(`ON`)과 레코드에 대한 조건을 통합하여 기술
      - **자연 조인(Natural Join)**
        - 두 테이블의 **동일한 이름의 컬럼**에 대해 값이 같은 레코드를 결합하는 내부 조인
          - 두 개 이상의 테이블을 하나의 테이블로 결합하는 내부 조인과 매우 유사한 기능
          - 내부 조인의 파생 형태
        - 구문 형식
          ```
          SELECT 컬럼1, 컬럼2, …, 컬럼m
          FROM 테이블1 NATURAL JOIN 테이블2
          [WHERE 조건]
          ```
          - join에 대한 조건인 `ON` 부분이 없음
            - 동일 이름 컬럼의 같은 값 레코드를 join한다는 자동 join 조건을 갖고 있기 때문
    - **외부 조인(Outer Join)**
      - 외부 조인은 조인 조건에 맞지 않는 레코드도 질의의 결과에 포함시키는 질의
        - 내부 조인(inner join)은 조인 조건에 일치하는 레코드만 결합하여 결과를 생성
          - 조인 결과에 정보의 손실이 발생 (join 조건을 만족하지 않는 양쪽 레코드는 출력 결과에서 배제되므로)
        - 없는 컬럼 값들은 Null로 대체
        - 내부 조인만큼 자주 사용되지는 않는 질의
      - 외부 조인의 종류
        - **왼쪽 외부 조인(left outer join)**
          - 공통되는 부분, A(왼쪽) 부분 결과에 포함
        - **오른쪽 외부 조인(right outer)**
          - 공통되는 부분, B(오른쪽) 부분 결과에 포함
        - **완전 외부 조인(full outer join)**
          - 공통되는 부분, 양쪽 테이블 모두 결과에 포함
      - 구문 형식
        ```
        SELECT 별칭1.컬럼1, 별칭1.컬럼2, ..., 별칭1.컬럼m,
               별칭2.컬럼1, 별칭2.컬럼2, ..., 별칭2.컬럼n,
          FROM 테이블1 AS 별칭1
               LEFT|RIGHT [OUTER] JOIN
               테이블2 AS 별칭2
          ON 별칭1.컬럼i = 별칭2.컬럼j
          [WHERE 절]
        ```
      - [`예) 학생의 학생번호, 학생이름과 그 학생이 수강신청한 과목의 과목코드, 신청시각을 출력하시오. 단, 수강신청을 하지 않은 학생도 결과에 포함시키고 과목코드를 기준으로 오름차순 정렬한다.`](https://user-images.githubusercontent.com/61646760/151370278-79af4ed0-7dfa-49f2-961f-14e7ed9a91ba.png)
        - 학생번호와 학생이름은 학생 테이블에, 과목코드와 신청시각은 수강 테이블에 있음
        - [정답 과정 보기](https://user-images.githubusercontent.com/61646760/151371015-82b7eff1-ed7b-408a-a12b-a60cc177ce96.png)
          - 조중대 학생은 수강신청 하지 않았지만, 왼쪽 외부 조인이므로 학생 테이블의 데이터는 가져오고, 수강 테이블 부분은 NULL로 채움
          - 내부 조인이었다면 조중대 레코드는 미포함되었을 것임
            - 왼쪽 외부 조인이므로, 왼쪽 모든 레코드는 다 한번씩 나오고, 오른쪽 레코드는 조건에 맞는 것은 가져오고, 안 맞는 것은 NULL로 채움
        - [정답 결과 보기](https://user-images.githubusercontent.com/61646760/151372011-a36862f9-17c4-45db-8309-2ef4990ed87c.png)
    - **셀프 조인(Self Join)**
      - 한 테이블이 자기 자신과 조인되는 형태
        - 동일 테이블 내의 컬럼 값을 외래키로 갖는 경우 사용
        - 동일한 이름의 테이블에 대한 조인이므로 반드시 테이블 이름에 대한 **별칭이 의무적으로 사용**
      - 구문 형식
        ```
        SELECT 별칭1.컬럼1, 별칭1.컬럼2, ..., 별칭1.컬럼m,
               별칭2.컬럼1, 별칭2.컬럼2, ..., 별칭2.컬럼n,
          FROM 테이블1 AS 별칭1
               INNER|OUTER JOIN 테이블2 AS 별칭2
          ON 조인 조건
          [WHERE 절]
        ```
      - [`예) 과목의 과목코드, 과목명 그리고 그 과목의 선수과목의 과목코드, 과목명을 모두 출력하시오. 단, 선수과목이 없는 과목도 결과에 포함시킨다.`](https://user-images.githubusercontent.com/61646760/151373357-87345031-7e04-43d6-b7d3-8d0f356a3ba6.png)
        - [정답 보기](https://user-images.githubusercontent.com/61646760/151373626-fa0a505e-87b0-463f-9fe3-7d81a487a7e1.png)
          - 과목 B가 현재 과목, 과목 A가 선수 과목 (Right outer join이므로, 즉 선수과목이 없는 과목도 나와야 하므로)
### 뷰의 사용
- **뷰(View)**
  - 데이터를 저장하고 있는 하나 이상의 테이블을 유도하여 생성하는 가상의 테이블 (virtual table)
    - 테이블과 동일하게 사용이 가능한 데이터베이스 객체
  - 뷰의 장점
    - 데이터 독립성 : 원본 테이블의 구조가 바뀌어도 뷰를 이용한 작업은 정의만 변경되어 응용 프로그램에 영향이 없음
    - 데이터 보안 : 사용자에게 원본 테이블의 일부 컬럼에 대한 접근을 허용하여 보안 효과를 향상
    - 다양한 구조의 테이블 사용 : 사용자의 요구 사항에 맞는 테이블의 구조를 제공
    - 작업의 단순화 : 복합한 질의문을 뷰로 단순화
    - 데이터 무결성 : WITH CHECK OPTION을 이용하여 뷰 생성에 위배되는 수정 작업을 거부
  - 뷰의 생성
    - 생성되는 뷰의 구조는 SELECT 문의 결과로 결정
      - `CREATE TABLE` 구문과 다소 유사
    - 구문 형식
      ```
      CREATE VIEW 뷰이름 AS
        (SELECT 컬럼1, 컬럼2, ..., 컬럼n
          FROM 테이블
          [WHERE 조건])
      [WITH CHECK OPTION]
      ```
  - 뷰의 수정 및 삭제
    - 뷰의 수정은 생성과 동일하게 새로운 SELECT 문의 결과로 변경
    - 구문 형식
      - 수정
        ```
        ALTER VIEW 뷰이름(컬럼1, 컬럼2, ..., 컬럼n) AS
          (SELECT 컬럼1, 컬럼2, ..., 컬럼n
            FROM 테이블
            [WHERE 조건])
        ```
      - 삭제
        ```
        DROP VIEW 뷰이름
        ```
  - [`예) 뷰 생성 : 컴퓨터과학과 소속의 학생정보와 학과이름 및 이수학점을 출력하는 '컴퓨터과학과_학생' 뷰를 생성하시오.`](https://user-images.githubusercontent.com/61646760/151376299-1bb574a4-4503-40fe-a3c1-18e762edcd96.png)
    - 동일한 이름의 컬럼이 학생번호 하나밖에 없으므로 `ON` 절을 통해 조건을 명시할 필요 없이 `NATURAL JOIN`으로 join하면 됨
    - [정답 보기 : SELECT한 것을 바탕으로 뷰 생성하기](https://user-images.githubusercontent.com/61646760/151377863-2319b2d2-03c1-42f3-8765-2f8c2fd59acb.png)
  - 뷰를 이용한 데이터 검색
    - 뷰는 가상의 테이블이므로 데이터 조작은 테이블 조작과 동일하게 수행
    - 구문 형식
      ```
      SELECT 컬럼1, …, 컬럼2
        FROM 뷰 이름
        WHERE 조건
      ```
    - 실행 형식
      ```
      SELECT 컬럼1, …, 컬럼2
        FROM 뷰 이름
        WHERE 조건 AND 뷰 정의조건
      ```
  - 뷰를 이용한 데이터 삽입
    - 뷰에 대한 `INSERT` 문은 원본 테이블에서 실행
    - 주의 사항
      - PRIMARY KEY, NOT NULL 등의 제약 사항이 위배되는 경우 삽입이 불가능
      - 원본 테이블에 존재하는 컬럼이지만 뷰에는 없는 컬럼에 삽입하는 경우 실행 불가능
      - 조인 질의 또는 그룹 질의가 적용된 뷰는 데이터 삽입 및 수정이 불가능
      - `WITH CHECK OPTION`이 적용된 뷰는 위배되는 사항은 없지만 뷰에 맞지 않는 조건일 경우 실행 불가능

## 7강. 정규화
### 주요 용어
- 정규화
  - 이상 현상이 발생할 가능성을 차단하기 위해 원칙을 기반으로 효과적으로 스키마를 모델링하는 데 이용되는 기법
- 함수적 종속성
  - 특정 시점의 릴레이션 인스턴스에서 한 속성의 값이 다른 속성의 값을 결정하는 속성 간의 연관관계
- 클로저
  - 함수적 종속성 집합에서 추론 규칙을 사용하여 감춰진 함수적 종속성을 찾아낸 확장된 함수적 종속성 집합
- 카노니컬 커버
  - 함수적 종속성 집합에서 의미적인 자명성과 중복성을 제거한 최소화된 함수적 종속성 집합
- 정규형
  - 삽입, 수정, 삭제 등의 이상 발생을 방지하기 위해 릴레이션과 속성을 조건에 따라 재구성한 형식
### 좋은 릴레이션과 나쁜 릴레이션
- 잘못된 데이터베이스 모델링
  - **데이터의 중복**
    - 일관성 유지의 어려움
      - [`예) GOLD 등급인데 혼자만 할인율 8%인 경우`](https://user-images.githubusercontent.com/61646760/151969511-0ebf10a5-91fd-4b11-af6d-ac4eef996782.png)
    - 저장 공간 낭비
      - `예) 등급별 할인률이 고정일 때, 둘 다 일일이 적는 것은 공간의 낭비가 될 수 있음`
  - **갱신 이상**
    - 삽입 이상
      - 레코드 추가 시 불필요한 컬럼의 값이 없이는 추가하지 못하는 경우
      - [`예) NEW라는 새로운 등급을 추가하고 싶을 때`](https://user-images.githubusercontent.com/61646760/151969748-e0618ffa-112f-4a8b-984b-580cf471dcca.png)
    - 삭제 이상
      - 삭제 시 의도하지 않았던 다른 데이터가 삭제되는 경우
      - [`예) 추가한 NEW라는 등급을 삭제하고 싶은 경우`](https://user-images.githubusercontent.com/61646760/151969834-004ac158-0837-487b-a9f4-75f761fb56ba.png)
    - 수정 이상
      - 중복 저장된 레코드를 수정 시 모두 반영이 안 되어 데이터베이스의 일관성이 깨지는 경우
      - [`예) VIP 할인율을 8%로 변경하는데 하나의 레코드만 변경이 안 된 경우`](https://user-images.githubusercontent.com/61646760/151969907-38f9e071-c1c3-4867-bff2-f32591cb39c8.png)
- 좋은 릴레이션의 개념
  1. 컴퓨터 프로그래머적 관점에서의 모델링
      - 어떻게 데이터를 저장해야 하는가?
  2. 릴레이션의 스키마가 얼마나 효율적으로 실세계를 반영하고 있는지 평가
  3. 고려 사항
      - 한 릴레이션 내의 컬럼 간의 관계 분석
      - 원하지 않는 데이터의 종속과 중복 제거
      - 새로운 컬럼들이 데이터베이스에 추가될 때, 기존 컬럼과의 관계 수정을 최소화
  - `예) 좋은 릴레이션`  
    ![image](https://user-images.githubusercontent.com/61646760/151970981-664b4e30-3c52-4c0e-bac0-622d1275f5a8.png)
    - 할인율을 별도의 릴레이션으로 분리함으로써 데이터의 중복을 최소화함
    - 할인율을 변경하고 싶을 경우, 우측 릴레이션의 할인율만 변경하면 되므로 일관성 유지에 도움이 됨
### 함수적 종속성
- **함수적 종속성(Functional Dependency)**
  - 릴레이션 인스턴스를 분석하여 속성들 간의 연관 관계를 표현한 것
    - 릴레이션의 효율성을 향상시켜 좋은 릴레이션으로 변환하는 데 이용되는 중요한 개념
  - 함수적 종속성의 수학적 정의
    - 임의의 릴레이션 스키마 R의 인스턴스 r(R)에 포함되는 서로 다른 두 레코드 r<sub>1</sub>, r<sub>2</sub>와 컬럼 집합 X와 Y에 대해 𝑟<sub>1</sub>[𝑋] = r<sub>2</sub>[𝑋]일 때, 𝑟<sub>1</sub>[𝑦] = 𝑟<sub>2</sub>[𝑦]이면 함수적 종속성 𝑋 → 𝑌가 성립한다.
  - 함수적 종속성의 판별  
    ![image](https://user-images.githubusercontent.com/61646760/152459861-ed35b545-e488-4298-98b8-19f67a2afe6f.png)
    - 등급이 할인율을 종속한다.
      - GOLD면 무조건 할인율 5%, VIP면 할인율 10%, NEW면 할인율 3% (등급이 할인율을 결정)
      - 즉, 특정 컬럼의 값이 다른 컬럼의 값을 결정하면 함수적 종속성이 성립함
    - `{등급} → {할인율}`
      - 결정자
      - 종속자
- 함수적 종속성의 확장
  - 함수적 종속성은 릴레이션의 효율성 여부에 중요한 판단 기준
  - 그러나 릴레이션의 인스턴스만으로 내재된 모든 함수적 종속성을 찾아내기 어려움
    - 보다 논리적인 규칙, 수학적 접근 방법을 이용해서 찾아내야 하며, 이것이 곧 아래 '확장'에 해당
  - 판별되지 않은 모든 함수적 종속성을 찾기 위해 추론 규칙을 사용하여 함수적 종속성을 확장
  - **클로저(Closure)**
    - 판별된 함수적 종속성 집합으로부터 유추할 수 있는 **모든 함수적 종속성 집합**
      - `예) 하나의 릴레이션에서 5개의 함수적 종속성을 찾아냈는데, 추론 규칙을 통해 12개를 더 찾아냈다면, 전체 17개의 함수적 종속성 집합을 '클로저'라고 함`
    - **F<sup>+</sup>**
      - 눈으로 찾아낸 것은 **F**로 표기
      - F<sup>+</sup>은 F의 클로저
- 함수적 종속성 추론 규칙
  - **암스트롱 공리(Armstrong’s axiom)**
    1. 재귀성 규칙 : 𝑋⊇𝑌이면, 𝑋 → 𝑌이다.
        - 𝑌가 𝑋의 부분집합이면, 𝑋는 𝑌를 종속한다.
        - `예) {등급, 할인율} → {할인율}`
    2. 부가성 규칙: 𝑋 → 𝑌이면, 𝑋𝑍 → 𝑌𝑍이다.
    3. 이행성 규칙: 𝑋 → 𝑌이고, 𝑌 → 𝑍이면, 𝑋 → 𝑍이다.
    4. 분해 규칙: 𝑋 → 𝑌𝑍이면, 𝑋 → 𝑌이다.
    5. 합집합 규칙: 𝑋 → 𝑌이고, 𝑋 → 𝑍이면, 𝑋 → 𝑌𝑍이다.
    6. 의사 이행성 규칙 : 𝑋 → 𝑌이고, 𝑊𝑌 → 𝑍이면, 𝑊𝑋 → 𝑍이다.
        - 3번까지가 암스트롱 공리, 4번부터는 암스트롱 공리의 확장
  - 함수적 종속성 판별 및 클로저 도출 연습  
    ![image](https://user-images.githubusercontent.com/61646760/152645416-2d99114e-0ac4-4285-a25a-ba908a180a51.png)
    - `예) 고객번호 → 고객명` : True (C1이면 무조건 유관순)
    - `예) 고객명 → 등급` : True (전체 인스턴스 중 유관순은 무조건 GOLD)
    - `예) {고객번호, 고객명} → 할인율` : True
    - 암스트롱 공리를 통해 다음의 추론(= 클로저)이 가능함
      - `고객번호 → {고객명, 등급, 할인율}`
        - `고객번호 → 고객명 → 등급`이므로 `고객번호 → {고객명, 등급}` (이행성 규칙, 합집합 규칙)
  - **카노니컬 커버(Canonical Cover)**
    - 불필요한 함수적 종속성을 제거한 표준형으로 변환 후 정규화를 수행
      - F<sup>C</sup>
      - 함수적 종속성 추론 규칙으로 확장된 클로저는 **자명한 종속성**과 **중복된 종속성**을 포함
        - 자명한 종속성
          - `A → A`
          - 의미적으로 당연한 종속
        - 중복된 종속성
          - `X → AB, X → B`
          - 의미가 여러 번 존재함
          - 암스트롱 공리의 분해 규칙으로 설명이 가능
      - 표준형 조건
        - 𝐹의 모든 함수적 종속성의 오른 편 속성(= 종속자)은 반드시 1개
          - `예) {x, y} → {z}`
          - `표준형이 아닌 예) {x} → {a, b}`
        - 𝐹에서 𝑋 → 𝐴를 𝑋의 진부분집합 𝑌에 대하여 𝑌 → 𝐴로 교체했을 때, 그 집합이 𝐹와 동등한 집합이 불가능
          - 의미적 중복 배제
            - 전체집합의 일부만으로도 똑같이 종속할 수 있으면 중복된 종속성이 있는 것
          - 진부분집합(Proper Subset) : 전체집합의 부분집합 중, 자기 자신의 집합을 제외한 나머지 부분집합
            - `예) 집합 A = {3,4,6}의 진부분집합은 ø, {3}, {4}, {6}, {3,4}, {3,6}, {4,6} 총 7개이다.`
        - 𝐹에서 어떤 함수적 종속성을 제거했을 때, 그 집합이 𝐹와 동등한 집합이 불가능
          - 특정 종속성을 배제했는데도 의미적으로 같다면 불필요한 종속성이 남아 있는 것
- 정리 : 즉, 함수적 종속성을 모두 판별해 내고, 추론을 통해 클로저로 확장하고, 불필요한 것을 모두 잘라 내어 카노니컬 커버라고 하는, 순수한 형태의 함수적 종속성 집합만을 가지고 릴레이션을 효율적으로 개선함
### 정규화
- **정규형(Normal Form: NF)**
  - 이상 현상을 최소화하도록 특정 조건을 갖춘 릴레이션의 형식
  - 정규형의 분류  
    ![image](https://user-images.githubusercontent.com/61646760/152673066-60648bbd-68cf-48e0-854b-abd7eb2dfff3.png)
    - **제1정규형(First Normal Form: 1NF)**
      - 릴레이션 스키마에서 정의된 모든 속성의 도메인이 원자값을 갖는 상태
        - 가장 조건이 단순한 정규형
        - 관계형 모델의 조건에 따라 자동 적용되는 정규형
      - 제1정규화가 필요한 릴레이션  
        ![제1정규화 적용 전 릴레이션](https://user-images.githubusercontent.com/61646760/152687015-ae733ac8-6bae-443e-8bdd-9af73c942c9f.png)
        - `,`, `|` 등의 구분자를 사용하여 하나의 컬럼 값에 여러 의미를 갖는 값을 집어넣는 경우가 있음
          - `예) 입항시간, 목적`
        - 선박이 항구에 정박하기 위해 정밀한 작업이 요구
          - 풍향과 풍속, 파도와 안개 상황 등을 고려
          - 단순히 수신호뿐만 아니라 소형 배들로 정박하려는 대형 배를 밀어 안전하게 위치시키는 작업을 고려
            - 도선사 : 배를 도크에 안전하게 접안시키고 항로로 인도하는 일을 하는 사람
            - 도크 : 선박의 건조, 수리, 계선, 하역 작업 등을 위해 축조된 설비 및 시설의 총칭
      - [제1정규화 적용 후 릴레이션](https://user-images.githubusercontent.com/61646760/152688342-4e534d7b-77f9-4c41-8892-eca80ad1e4c7.png)
        - 각 컬럼의 레코드에 한 컬럼 값만 들어가 있음
          - 따라서 제1정규형의 조건을 만족하는 릴레이션
        - 함수적 종속성 판별
          - 도크 번호 → 도크 관리자
          - 목적 → 담당도선자
          - 목적 → 도크번호
          - 등등
        - **함수적 종속성 다이어그램(Functional Dependency Diagram: FDD)**
          - 릴레이션 내의 속성간의 종속 관계를 직관적이고 이해하기 쉽게 도식화한 표현 방식
            - 직사각형 : 속성 또는 속성 집합
            - 화살표 : 함수적 종속성  
            ![image](https://user-images.githubusercontent.com/61646760/152690942-9f19a9b0-572f-4904-9e69-7416be673959.png)
              - 목적이 담당도선사를 종속한다.
        - [도크 릴레이션의 함수적 종속성 다이어그램](https://user-images.githubusercontent.com/61646760/152691019-72578727-13c1-4435-89a8-525b0b9ae340.png)
          - `{도크번호, 입항시간}` : Key로, 출항시간, 목적, 담당도선사를 모두 종속함
          - 종속 관계 이해가 훨씬 쉬움
    - **제2정규형(Second Normal Form: 2NF)**
      - 릴레이션이 제1정규형을 만족하고 기본키의 부분집합이 특정 속성을 종속하고 있지 않은 상태
        - 주어진 릴레이션의 인스턴스가 **기본키가 아닌 속성들이 기본키에 완전히 종속**되어 있는 상태
        - 즉 모든 키가 아닌 속성(컬럼)들이 기본키에 완전 종속되어 있는 상태
      - 제2정규형의 적용  
        ![image](https://user-images.githubusercontent.com/61646760/152761191-6545bbe4-a8dd-43b6-a900-aaa7ede8f62b.png)
        - '출항시간', '목적', '담당도선사'는 상기 릴레이션의 키인 `{도크번호, 입항시간}`에 종속됨
          - 즉, '출항시간', '목적', '담당도선사'는 키에 완전히 종속되어 있음
        - 반면 '도크관리자'는 키의 일부분인 `도크번호`에 의해 종속됨
          - 즉, '도크관리자'는 키에 부분적으로 종속되어 있음
          - 부분 종속은 완전 종속과 달리 중복을 야기시키므로, 중복을 야기시키는 컬럼을 따로 빼내어 조치해야 함
        - 기본키에 완전히 종속되도록 릴레이션을 분해해야 함
          - 그런데 릴레이션은 잘못 분해하면 손실 분해(lossy decomposition)가 발생함
          - 손실 분해된 릴레이션은 Join하더라도 이전의 릴레이션으로 돌아가지 못함
        - **무손실 분해(Lossless Decomposition)**
          - 스키마 𝑅에 함수적 종속성 𝑋 → 𝑌가 존재하고 𝑋 ∩ 𝑌 = ∅이면 , 𝑅을 𝑅-𝑌와 𝑋𝑌로 분해
          - `예) 도크관리 릴레이션 무손실 분해`
            - `{도크번호} → {도크관리자}`
            - `{도크번호} ∩ {도크관리자} = ∅`
              - `도크관리-{도크관리자}, {도크번호, 도크관리자}`
                - 즉, 도크관리 릴레이션(𝑅)에서 도크관리자 컬럼만 뺀 릴레이션과 `{도크번호, 도크관리자}`의 두 컬럼으로 구성된 릴레이션으로 분해가 가능함
        - [제2정규화 적용 전 릴레이션](https://user-images.githubusercontent.com/61646760/152794034-9311d136-a587-416c-b603-38e45fe0f187.png)
          - 제1정규화 적용을 마친 상태 (상기 제1정규화를 적용한 릴레이션 부분 참고)
        - [제2정규화 적용 후 릴레이션](https://user-images.githubusercontent.com/61646760/152794249-1d3b8732-185b-4cd7-9aef-9ff8f0d7cc55.png)
          - 기존의 도크 릴레이션이 '도크관리 릴레이션'과 '관리자 릴레이션'으로 나뉨
            - 부분적으로 중복된 컬럼 제거
        - [제2정규화의 함수적 종속성 다이어그램](https://user-images.githubusercontent.com/61646760/152794754-b8d36e1a-8bc5-4d16-b284-b7c773546ae5.png)
          - 제1정규형의 함수적 종속성 다이어그램을 제2정규화시킨 것
          - `도크번호`, `도크관리자` 열이 따로 떨어져 나와 `{도크번호} → {도크관리자}`의 종속 관계 형성
    - **제3정규형(Third Normal Form: 3NF)**
      - 릴레이션이 제2정규형을 만족하고 기본키가 아닌 속성들이 어떤 키에도 이행적으로 종속되지 않은 상태
        - 이행적 종속성
          - `𝑋 → 𝑌이고 𝑌 → Z이면 𝑋 → Z이다.`
          - 암스트롱 공리의 3번 규칙 참고
          - 이행적 종속성은 부분적 중복을 만드므로 배제해야 함  
            ![image](https://user-images.githubusercontent.com/61646760/152798068-ab63de6f-64ac-43e7-874c-e4e49ead9814.png)
            - 키(`{도크번호, 입항시간}`), 목적, 담당도선사 사이에 이행적 종속성이 존재함
            - 제3정규화에서는 이러한 이행적 종속성을 제거해 내야 함
      - [제3정규화 적용 전 함수적 종속성 다이어그램](https://user-images.githubusercontent.com/61646760/152798415-0a65b390-45c6-4542-8ef0-3c39c927178e.png)
        - 목적이 담당도선사를 종속하므로 이행적 종속성이 발생함
      - [제3정규화 적용 후 함수적 종속성 다이어그램](https://user-images.githubusercontent.com/61646760/152798474-2b8122b7-5c14-4469-a40d-e33d212993f9.png)
        - 결정자(`목적`)가 키가 되고, 종속자(`담당도선사`)가 거기에 종속됨으로써 이행적 종속성을 제거함
        - 따라서 이 다이어그램은 제3정규형을 따른다고 할 수 있음
      - [제3정규화 적용 전 릴레이션](https://user-images.githubusercontent.com/61646760/152799145-a15957d0-139b-46aa-aa64-a32ff166011b.png)
      - [제3정규화 적용 후 릴레이션](https://user-images.githubusercontent.com/61646760/152799391-cbe90b22-5874-4933-b476-af7e80ac5838.png)
    - **BC정규형(Boyce-Codd Normal Form: BCNF)**
      - 릴레이션이 제3정규형을 만족하고, 릴레이션에 성립하는 𝑋 → 𝑌 형태의 모든 함수적 종속성에 대하여 𝑋가 수퍼키인 상태
        - 즉, 수퍼키 중 하나만 결정자가 될 수 있음
      - 도크 릴레이션의 함수적 종속성
        - `{도크번호, 입항시간} → {목적}`
        - `{도크번호, 입항시간} → {출항시간}`
        - `{목적} → {도크번호}`
          - 그러나 목적은 기본키도, 후보키도, 수퍼키도 아닌 일반 속성
          - 그런 일반 컬럼이 도크번호를 종속한다는 것은 BC정규형의 정의에 위배됨
      - [BC정규화 적용 전 함수적 종속성 다이어그램](https://user-images.githubusercontent.com/61646760/152800832-5e6f23f8-8d44-480c-9579-685c7f9c2329.png)
      - [BC정규화 적용 후 함수적 종속성 다이어그램](https://user-images.githubusercontent.com/61646760/152800919-2ca28618-9c7e-49fe-8423-55a6be5011ed.png)
        - 결정자인 목적이 기본키의 도크번호를 대체하고, 목적이 도크번호를 가지고 별도 릴레이션으로 나오게 됨
          - 목적이 결정자고, 도크번호가 종속자이기 때문에, 도크번호를 기본키에 남겨 둘 수가 없기 때문
          - 따라서 기본키에 있던 도크번호를 목적이 대체하게 됨
          - BC정규화 적용 후, 총 4개의 릴레이션으로 나뉘게 됨
      - [BC정규화 적용 전 릴레이션](https://user-images.githubusercontent.com/61646760/152801803-2638fb87-05fa-4542-b151-476ed006d511.png)
      - [BC정규화 적용 후 릴레이션](https://user-images.githubusercontent.com/61646760/152801905-6438e923-fec1-4715-b52d-3ff6b04dbe15.png)
    - 제4정규형(4NF)
      - 일반적으로 제4, 제5정규형까지는 사용하지 않음
    - 제5정규형(5NF)
- **정규화(Normalization)**
  - 특정 정규형의 조건을 만족하도록 릴레이션과 속성을 재구성하는 과정
    - 릴레이션 분할을 통해 데이터의 중복성을 최소화하는 과정
    - 사용 과정에서 많은 Join 연산을 유발 (사용자에게 전달이 느려짐)
  - 정규화의 기능
    - 데이터베이스 내에 모든 **릴레이션을 효과적으로 표현**
    - 보다 간단한 관계 연산에 기초하여 **검색 알고리즘을 효과적으로 작성**할 수 있도록 지원
    - 바람직하지 않은 삽입, 수정, 삭제 등의 **이상 발생 방지**
    - 새로운 형태의 데이터가 삽입될 때 **릴레이션 재구성의 필요성을 축소**
  - 데이터베이스 모델링 즉 사용자 요구 분석, 개념적 데이터 모델링, 논리적 데이터 모델링을 모두 수행한 다음 정규화를 맨 마지막에 수행
    - 이후 물리적 모델을 구현하면, 효율적인 릴레이션 스키마 생성 가능
- **역정규화(Denormalization)**
  - 정규화를 통해 분리되었던 릴레이션을 통합하는 재조정을 수행하고 정보의 부분적 중복을 허용하는 기법
    - 즉, 정규화의 반대 과정
  - 데이터 접근 성능 개선 목적
    - 정보 중복성을 조금 유발하더라도 join 연산을 줄이고 빠르게 데이터를 검색할 수 있는 구조 구축
    - 퍼포먼스 관점에서 성능이 중요할 수 있음
  - 정규화되지 않은 스키마와 역정규화 스키마는 구별
    - 역정규화는 정규화를 한 뒤, 다시 통합 및 재조정한 것
    - 정규화를 아예 하지도 않은 스키마와 정규화 후 역정규화한 스키마는 효율성, 구조 측면에서 다름

## 8강. 연습문제 풀이 (1)
[08강_강의록.pdf](https://github.com/Esantomi/knou/files/8022821/08._.pdf)
<details>
  <summary>Q01. DBMS 사용 이전의 데이터 관리 방식으로 운영체제의 지원으로 여러 파일에 나누어 데이터를 영구 저장하고 운영하는 시스템을 무엇이라고 하는가?</summary>

  파일 처리 시스템
</details>

<details>
  <summary>Q02. 다음 중 파일 처리 방식의 데이터 관리가 갖는 문제점으로 볼 수 없는 것은? <blockquote>①데이터의 독립 ②데이터의 확장 ③데이터의 무결성 훼손 ④동시 접근 이상</blockquote></summary>

  ①데이터의 독립
</details>

<details>
  <summary>Q03. DBMS가 데이터베이스 자체 뿐만 아니라 데이터에 대한 정의나 설명에 대한 것까지 포함하고 있는 특성을 무엇이라 하는가?</summary>

  자기 기술성
</details>

<details>
  <summary>Q04. 데이터베이스 언어의 한 영역으로 데이터베이스에 의해 구조화된 데이터에 사용자가 접근 및 사용할 수 있도록 지원하는 언어를 무엇이라고 하는가?</summary>

  데이터 조작 언어
</details>

<details>
  <summary>Q05. DBMS를 외부, 개념, 내부 스키마로 분리하고 각 단계 간 사상을 통해 구조화하는 방식을 무엇이라고 하는가?</summary>

  3단계 구조
</details>

![image](https://user-images.githubusercontent.com/61646760/152957736-97855794-43d3-48ae-adff-6b48c558154a.png)

<details>
  <summary>Q06. 클라이언트와 서버 사이에 데이터에 접근하는 데 사용되는 비즈니스 규칙을 저장한 중간 계층을 삽입하여 운용하는 데이터베이스 시스템 아키텍처는?</summary>

  3계층 클라이언트 서버 구조
</details>

<details>
  <summary>Q07. 다음 중 데이터베이스 모델링 단계가 순서대로 나열된 것은? <blockquote>①개념-요구분석-논리-물리 ②개념-논리-물리-요구분석 ③요구분석-개념-논리-물리 ④요구분석-물리-논리-개념</blockquote></summary>

  ③요구분석-개념-논리-물리
</details>

<details>
  <summary>Q08. 사용자 요구사항 분석 과정에서 데이터베이스를 구축하기 위한 목표와 조사 범위를 결정하고 필요한 자료를 수집하는 등을 수행하는 세부 단계는?</summary>

  사용자 요구사항 도출
</details>

<details>
  <summary>Q09. ER 모델의 구성요소 중 실세계에 존재하는 다른 모든 객체와 구별되는 유·무형의 대상의 모임을 무엇이라고 하는가?</summary>

  개체 집합
</details>

<details>
  <summary>Q10. 다음은 무엇에 대한 설명인가?<blockquote>개체 집합의 각 개체마다 서로 다른 값을 갖는 속성을 뜻한다. 즉, 어떤 개체의 이 값은 각각의 개체들을 서로 구별하는 데 사용되는 개체 집합에서 유일한 값이다.</blockquote></summary>

  키 속성
</details>

<details>
  <summary>Q11. 다음 요구 사항에 대해 ER 모델링한 결과로 올바르게 표현된 학생 개체는?<blockquote>학생은 이름, 학번, 학과명, 주소로 구성된다. 학번은 입학년도, 학과코드 및 일련번호로 이루어지고, 학과명은 학과 코드를 통해 알 수 있다.</blockquote></summary>

  ![image](https://user-images.githubusercontent.com/61646760/152959394-f5e0bf3c-372f-4010-8ec4-9ecbbcd3a6b4.png)
</details>

<details>
  <summary>Q12. 다음 요구사항을 참조하여 물음에 답하시오.<blockquote> 전산화 시스템을 도입하는 A 은행에서는 고객은 이름, 고객번호, 주소, 전화번호, 신용도 값으로 구성된다. 각각의 고객은 고객번호로 구분되며, 한 고객에 대해 여러 전화번호를 기록할 수 있다. 고객이 소유하는 계좌는 계좌번호와 잔액으로 구성된다. 한 고객은 여러 개의 계좌를 소유할 수 있으며, 반면 한 계좌는 단 한 명의 고객에만 소유된다. 계좌를 소유하지 않는 고객은 있지만, 모든 계좌는 반드시 고객에게 소유된다.</blockquote>위 요구 사항에 대한 ER 모델링 결과 고객 개체 집합을 올바르게 표현한 것은?<br>그리고 고객과 계좌 개체 집합 사이의 소유 관계 집합에 대해 사상수를 올바르게 표현한 것은? (단, 개체 집합은 개체 집합 이름만 표현한다.)</summary>

  ![image](https://user-images.githubusercontent.com/61646760/152960466-49fa2a50-3b2b-4d4b-8f7c-2b8caa1c2b23.png)  
  ![image](https://user-images.githubusercontent.com/61646760/152960524-299b73a5-4bb9-43b2-870c-871285c3745b.png)
</details>

<details>
  <summary>Q13. 아래의 릴레이션에서 빈칸에 들어가야 하는 용어로 올바르지 않는 것은?<blockquote>①스키마 ②차수 ③레코드 ④인스턴스</blockquote></summary>

  ②차수
</details>

![image](https://user-images.githubusercontent.com/61646760/152962247-1ddd77c5-2620-4da5-904f-f9a78c60c228.png)

<details>
  <summary>Q14. 다음은 릴레이션의 어떤 특징에 대한 설명인가?<blockquote>한 릴레이션을 구성하는 컬럼 사이에는 순서가 없고 이름과 값의 쌍으로 구성된다.</blockquote></summary>

  컬럼의 무순서성
</details>

<details>
  <summary>Q15. 다음은 무엇에 대한 설명인가?<blockquote>두 개의 릴레이션 사이에 명시되는 제약조건으로 한 릴레이션에 있는 레코드가 다른 릴레이션에 있는 레코드를 참조하려면 반드시 존재하는 릴레이션만 참조해야 하는 제약조건을 명시한다.</blockquote></summary>

  참조 무결성 제약조건
</details>

<details>
  <summary>Q16. 다음의 ER 다이어그램을 관계형 모델로 올바르게 변환한 것은?</summary>

  ![image](https://user-images.githubusercontent.com/61646760/152963182-c13f14f2-7237-4de9-bd60-d54ce7430be5.png)
</details>

![image](https://user-images.githubusercontent.com/61646760/152963093-b6bc7bfb-ed97-4ebd-9382-c894e96b2be9.png)

<details>
  <summary>Q17. 아래의 스키마를 참조하여 다음 물음에 답하시오.<blockquote>"강좌명이 '요가'인 강좌의 강좌번호, 강좌명, 강사번호를 출력하시오."에 대한 관계 대수 연산식으로 올바른 것은?<br>"'홍길동' 강사의 종목을 출력하시오."에 대한 관계 대수 연산식은?</blockquote></summary>

  ![image](https://user-images.githubusercontent.com/61646760/152963672-5a69a96b-2131-4eb7-aac5-ea8eb81380de.png)  
  ![image](https://user-images.githubusercontent.com/61646760/152963905-7a7d3253-9a1d-4bff-8d33-075132d57f74.png)
</details>

![image](https://user-images.githubusercontent.com/61646760/152963408-f0cb542f-2e1a-45f5-9b40-637e121b90f0.png)

<details>
  <summary>Q18. 테이블 스키마 정의, 테이블 삭제, 테이블 스키마 변경 및 제약조건을 명시하는 기능을 하는 SQL 언어 영역을 무엇이라고 하는가?</summary>

  데이터 정의 언어
</details>

<details>
  <summary>Q19. 다음 중 데이터베이스 언어의 영역이 나머지 셋과 다른 SQL 명령어는 무엇인가?<blockquote>①SELECT ②UPDATE ③INSERT ④DROP</blockquote></summary>

  ④DROP
</details>

<details>
  <summary>Q20. 다음 중 테이블의 컬럼을 삭제하는 데 사용하는 SQL 명령어는?<blockquote>①ALTER ②UPDATE ③DROP ④DELETE</blockquote></summary>

  ①ALTER
</details>

<details>
  <summary>Q21. "교수의 교수번호, 소속학과, 교수이름, 입사일을 입사일의 내림차순으로 정렬하여 출력하시오."를 수행하기 위한 SQL 문은?</summary>

  SELECT 교수번호, 소속학과, 교수이름, 입사일<br>
    FROM 교수 ORDER BY 입사일 DESC
</details>

<details>
  <summary>Q22. 다음 중 정규화에 대한 설명으로 올바르지 않은 것은?<blockquote>①데이터가 삽입될 떄 릴레이션 재구성의 필요성을 줄인다.<br>②데이터의 중복을 제거하여 릴레이션의 효율성을 향상시킨다.<br>③삽입, 갱신, 삭제 이상(anomaly) 현상을 제거한다.<br>④릴레이션 간 공통 부분을 도출하고 유사 릴레이션을 통합하여 스키마의 구조를 간략화한다.</blockquote></summary>

  ④릴레이션 간 공통 부분을 도출하고 유사 릴레이션을 통합하여 스키마의 구조를 간략화한다.
</details>

<details>
  <summary>Q23. 다음은 무엇에 대한 설명인가?<blockquote>이것은 릴레이션 인스턴스를 분석하여 속성들 간의 연관관계를 표현한 것으로, 주어진 릴레이션 인스턴스에서 서로 다른 두 레코드와 속성 집합 X와 Y에 대해, 두 레코드의 X 속성값이 같을 때, Y의 속성값이 같으면 성립하는 특성을 말한다.</blockquote></summary>

  함수적 종속성
</details>

<details>
  <summary>Q24. 아래의 도크관리 릴레이션에 포함된 함수적 종속성이라고 할 수 없는 것은?<blockquote>①목적 → 담당도선사<br>②{도크번호, 입항시간} → 목적<br>③{도크번호, 입항시간} → 출항시간<br>④출항시간 → 목적</blockquote></summary>

  ④출항시간 → 목적
</details>

![image](https://user-images.githubusercontent.com/61646760/152965657-c0dd7708-750b-447d-8790-66af58ab5344.png)

<details>
  <summary>Q25. 제약조건이 강한 순으로 정규형 간의 관계가 올바른 것은?</summary>

  제1정규형 < 제2정규형 < 제3정규형 < 제4정규형 < 제5정규형
</details>

<details>
  <summary>Q26. 다음 릴레이션의 정규형은 무엇인가?</summary>

  제2정규형
</details>

![image](https://user-images.githubusercontent.com/61646760/152966715-8bed8c61-bd29-4772-8bae-46b6673ef578.png)

## 9강. 데이터 저장과 파일
### 물리적 저장 장치
- 물리적 저장 장치의 구성
  - 물리적 저장 장치는 데이터 접근 속도 용량을 기준으로 다양한 장치로 구성  
    ![image](https://user-images.githubusercontent.com/61646760/152972211-3bb586ec-2415-45da-9d35-8c37d4b37adf.png)
    - 물리적 저장 장치의 계층이라고 함
- 물리적 저장 장치별 특성
  - 휘발성
    - 캐시 : 고비용 저장 장치로 빠른 접근 속도를 보장
    - 메인 메모리 : 실제 프로그램과 데이터 적재 공간
  - 비휘발성
    - 플래쉬 메모리 : 메인 메모리와 유사하나 비휘발성
    - 자기 디스크 : 데이터베이스 전체를 안정적으로 저장
    - 광학 디스크 드라이브 : CD, DVD, Blue-ray 등
    - 테이프 장치 : 용량이 크고 저렴하나 순차 접근 방식으로 접근 속도가 매우 느림
### 파일
![image](https://user-images.githubusercontent.com/61646760/153006246-c090b929-cfd7-4ebb-86cd-bd3443ce7857.png)
- 데이터베이스를 자기 디스크에 저장하기 위해서는 물리적 구조로 변환해야 함
  - 운영체제 위에 동작하는 DBMS가, 운영체제가 관리하는 파일 시스템에 맞게끔, 데이터를 여러 개의 파일 단위로 나누어 관리
  - 나뉘어진 파일이 실제 자기 디스크 등에 저장되려면, 더 작은 데이터 단위인 '블럭'으로 분리되어야 함
    - 블럭 단위부터는 물리적 단위
    - 즉, 하나의 파일은 디스크에 저장될 때 여러 개의 블럭으로 분리가 되어서 저장됨
  - 하나의 블럭에는 여러 개의 레코드가 들어가는데, 이러한 구조가 하나의 데이터베이스가 디스크에 저장되는 구조
- **파일(File)**
  - 데이터를 영구적으로 저장하기 위해 사용되는 가장 기초적인 논리적 구조
- **블럭(Block)**
  - 파일을 고정적인 길이로 분할하여 생기는 균등한 크기의 데이터 묶음
    - 보통 4kb 정도의 4,000자 단위로 구분
    - 디스크에서 메모리로 데이터를 주고받을 때, 즉 페이지 단위로 구성할 때, 페이지가 블럭과 동일한 사이즈
  - 일반적으로 메모리와 디스크 간 데이터 전송 단위로 결정
- **레코드(Record)**
  - 블럭을 구성하는 요소
    - 더 이상 분리될 수 없는 최소 데이터 저장 단위
  - **고정 길이 레코드(Fixed-length Records)**
    - 고정적인 바이트 수를 갖는 레코드를 저장하는 기법
    - [`예) 사원 릴레이션`](https://user-images.githubusercontent.com/61646760/153025227-caca46cd-8143-4a70-9ff5-4240bcd3b023.png)
      - 사번 8Byte, 이름 20Byte, 부서명 10Byte, 연봉 4Byte
        - 즉, 모든 컬럼이 고정적 길이를 가짐
        - 사원 릴레이션의 모든 레코드는 `8+20+10+4`, 즉 42Byte의 길이를 가짐
        - INT는 일반적으로 4Byte의 고정적 길이를 가짐
    - 데이터 접근
      - 모든 레코드는 42Byte 크기로 구성  
        ![고정 길이 레코드](https://user-images.githubusercontent.com/61646760/153026233-89721729-1da2-4b55-959a-61cb0c5f8c2f.png)
      - i번째 레코드 접근?
        - `(i - 1) * 42 + 1`번째 Byte부터 42개의 Byte를 읽어 접근
        - `예) 2번째 레코드에 접근하려면, (2 - 1) * 42 + 1 = 43부터 42개의 Byte를 읽음`
    - **잔여 고정 길이 레코드 할당**
      - 블럭의 길이가 레코드 길이로 정확히 나눠지지 않아 잔여 공간을 비워 두는 방법  
        ![image](https://user-images.githubusercontent.com/61646760/153028799-94caff3c-7597-4c51-b9e1-09254293611b.png)
        - 블럭1 하단의 붉은 공간은 42Byte보다 작아서 레코드를 집어 넣을 수 없으므로 비워 둠
      - 즉, 블럭 내의 남은 공간이 낭비됨
        - 장점은 간편하므로 저장 속도가 빨라진다는 것, 단점은 공간 낭비가 지속적으로 이루어진다는 것
    - **고정 길이 레코드 할당**
      - 블럭의 길이가 레코드 길이로 정확히 나눠지지 않아 한 레코드를 두 블럭에 나누어 저장하는 방법  
        ![image](https://user-images.githubusercontent.com/61646760/153030942-848499f1-fdb2-4272-b532-ef501c21a894.png)
        - 남은 공간이 레코드 크기(여기서는 42Byte)보다 작더라도, 저장할 수 있는 만큼 저장하고, 나머지는 다음 블럭에 이어서 저장
      - 즉, 레코드 접근 시 두 블럭을 접근
        - 장점은 저장 공간의 효율적 사용이 가능하다는 것, 단점은 하나의 레코드를 가지고 오는데 디스크에서 2개의 블럭을 읽어 가져와야 함
        - k+1번째 레코드를 가져오려면 연산이 2번 일어나야 하므로, 속도가 느려질 수 있음
      - 고정 길이 레코드 할당의 문제
        - 레코드 삭제 시
          - 해당 레코드가 저장되었던 위치에 빈 공간이 생성
            - 즉 블럭 중간중간에 구멍이 뚫림
          - 장시간 레코드의 삽입 및 삭제 발생 시 저장 공간에 많은 낭비가 발생
        - 레코드 삭제 시 대처(빈 공간 활용) 방안
          - [마지막 레코드로 공백 대체](https://user-images.githubusercontent.com/61646760/153032248-8eb69434-7ad9-40a0-af24-eb71eb953512.png)
            - 장보고 레코드를 삭제하면 안창호 레코드를 해당 공백으로 이동시킴
            - 레코드의 순서가 달라져 검색 시간이 길어지는 문제가 있음 (원래는 사번 순 정렬)
          - [삭제 레코드 이후의 레코드를 이동](https://user-images.githubusercontent.com/61646760/153032971-fcf545bb-ec11-4f7e-93e9-4f020549ae37.png)
            - 장보고 레코드를 삭제하면 그 아래에 있는 4개의 레코드를 모두 한 칸씩 위로 올림
            - 레코드 입력 순서가 보존되어 검색 효율을 유지할 수 있으나, 하나하나 일일이 옮기는 데 소요 시간이 커짐
          - [가용 리스트 관리](https://user-images.githubusercontent.com/61646760/153033452-fa009be8-6120-4759-9b9d-dd02a9b42633.png)
            - 예시는 장보고 레코드, 유관순 레코드를 삭제한 경우
            - 파일 헤더에 '공백 레코드 포인터'를 넣어 삭제된 위치를 링크를 통해 파악
              - 연결 리스트를 사용한 것
            - 새로운 레코드가 삽입될 경우, 공백 레코드 포인터를 통해 빈 공간을 찾아 채움
              - 즉, 가용 리스트를 꾸준히 유지함으로써, 빈 공간을 파악하고 새롭게 레코드를 채움
            - 상업 데이터베이스에서 많이 사용하는 방법
  - **가변 길이 레코드(Variable-length Records)**
    - 블럭에 저장되는 레코드의 길이가 서로 다른(가변적) 레코드를 할당하는 방법
    - 가변 길이 레코드가 사용되는 상황
      - 한 블럭 내에 저장되는 레코드 유형이 둘 이상
        - 각 유형의 레코드는 길이가 다를 수 있음
      - 길이가 고정되지 않은 컬럼의 개수가 하나 이상
        - variable character 같은 것
      - 레코드가 멀티셋을 허용한 컬럼을 가질 때
        - 멀티셋 : 레코드의 컬럼 값이 여러 개인 컬럼
        - 원칙적으로 관계형 모델을 사용하는 DBMS에서는 멀티셋을 허용하지 않으나, 몇몇 상용 데이터베이스에서 컬럼 값의 원자성을 확대시키는 멀티셋을 제공하는 경우가 종종 있음
    - [`예) 사원 릴레이션`](https://user-images.githubusercontent.com/61646760/153181790-21a2eb7a-c242-4834-bd75-2d57ec167720.png)  
      ![image](https://user-images.githubusercontent.com/61646760/153186539-2aca640e-e795-455f-bbe9-e9cc80e829fa.png)
      - 처음부터 첫 번째 컬럼 값이 삽입되지 않고, 4Byte를 써서 어디서부터, 몇 바이트 길이까지가 가변 길이 레코드인지 명시
        - `27, 6` : 27Byte부터 32Byte까지, 총 6Byte로 가변 길이 레코드 '홍길동'을 저장했음을 명시
      - 그 이후로 고정 길이 컬럼 삽입
        - `12012`, `인사부`, `90,000,000`
      - 고정 길이와 가변 길이의 경계를 지정해 주기 위해 `NULL` 사용
      - 그렇다면 한 블럭에서 가변 길이 레코드는 어떻게 저장하는가?
        - 하나의 블럭 내부에 모든 레코드의 길이가 다 다르면, 레코드의 시작과 끝을 따로 저장해서 알 수 있어야 함
        - 슬롯-페이지 구조를 고안
    - **슬롯페이지 구조(Slotted-page Structure)**
      - 가변 길이 레코드를 저장하기 위해 고안된 대표적인 구조  
        ![image](https://user-images.githubusercontent.com/61646760/153196717-c254fe72-d9dc-418d-bb06-66495f075a5f.png)
        - 맨 앞 블럭 헤더에 레코드 개수, 레코드 요약 정보를 저장
        - 새로운 레코드가 블럭 내에 들어오면, 레코드는 맨 뒤에서부터 앞으로 차곡차곡 저장됨
        - 새 레코드가 삽입될 때마다, 레코드의 시작과 끝을 '링크'를 통해 블럭 헤더에 모두 저장
- **파일 구조화 방법(File organization methods)**
  - 파일 수준에서 레코드를 관리(순서 등) 하는 기법
    - 하나의 릴레이션은 여러 개의 블럭에 저장되고, 블럭이 여럿 모이면 파일이 되는데, 그 파일에 레코드를 저장하는 방법
  - 파일 구조화 방법 종류
    - **힙 파일 구조(Heap File Organization)**
      - 저장 순서 고려 없이 파일 내 임의의 위치에 배치
        - 메모리에 올라와 있는 무작위 블럭의 빈 공간에 저장
          - 무작위로 접근해서 빈 공간이 있으면 저장하므로 저장 속도는 가장 빠름
          - 무작위로 저장하므로 검색할 때는 모든 블럭을 순차적으로 메모리에 올려 확인해야 함
        - 저장은 빠르지만 사용의 효율은 떨어짐
    - **순차 파일 구조(Sequential File Organization)**
      - 레코드들이 탐색키 기준으로 정렬되어 저장
        - 레코드가 파일에 삽입되는 시점에서 키 값이 부여됨
      - 가장 많이 사용되는 파일 구조화 방법
        - 탐색키 순서대로 넣으므로 저장 속도는 좀 느림
        - 반면 검색 속도는 빠름
      - 순차 파일 구조의 장점
        - 검색키에 대한 정렬 연산이 불필요, 키 값들의 순서로 레코드를 판독하는 연산에 효율적
        - 현재 레코드에서 정렬된 키 순서로 다음 레코드를 찾을 때 부가적인 블럭 접근이 불필요 (포인터를 따라가면 됨)
        - 이진 탐색을 사용하면 더 빠르게 레코드를 검색
      - 순차 파일 구조의 단점
        - 레코드 삽입, 삭제에 많은 비용 소요
      - [`예) 탐색키가 '이름'인 순차 파일 구조`](https://user-images.githubusercontent.com/61646760/153229924-7e3d2b5c-8ed9-47dc-b891-facad5bd2b86.png)
        - 탐색키인 '이름' 순으로 정렬
        - 가용 리스트 관리와 유사하게, 탐색키에 따른 순서에 맞게 모든 레코드가 순서화되어 있어, 다음 레코드를 읽으려면 포인터를 따라가면 됨 
      - **오버플로우 블럭(Overflow Block)**
        - 순차 파일 구조에서 레코드의 정렬된 상태 유지를 위해 삽입된 신규 블럭
        - [`예) 손흥민 레코드 삽입`](https://user-images.githubusercontent.com/61646760/153232463-bbdc3153-9ab9-4f76-92ca-21c0a79efbc4.png)
          - 원래 손흥민 레코드의 위치는 나철수와 안창호 사이이지만, 그러면 포인터를 전부 재설정해야 함
          - 손흥민 레코드에 연결되는 포인터만 수정해 주면 훨씬 간편함
          - 단, 순서대로 데이터에 접근할 때는 두 개의 블럭에 접근해야 한다는 단점이 있으나, 저장 속도는 약간 더 빨라짐
    - **해시 파일 구조(Hash File Organization)**
      - 해시 함수를 사용하여 블럭 주소를 계산
      - 탐색키를 블랙박스(해시 함수) 안에 집어 넣고, 그 산출된 해시 값에 따라 저장할 블럭이 지정됨
      - 해시 함수에 따라 해시 파일 구조의 성능 차이가 커질 수 있다는 단점이 있음
### 저장 장치 관리
- 저장 장치 접근
  - 파일은 논리적 관점에서의 저장 객체
  - 실제 저장될 때에는 여러 개의 물리적 단위인 블럭으로 디스크에 저장
    - 블럭은 메모리와 디스크 간 데이터의 전송 단위
    - 일반적으로 2KB~32KB 사용
    - 블럭 전송을 최소화할수록 입출력 소요 시간이 단축
      - 사용 중인 블럭을 지속적으로 메모리에 적재
      - 한정적 공간으로 인하여 필요에 따라 특정 블럭 할당을 해지
      - 메모리 내부의 버퍼라는 공간에 블럭을 저장하고, 이를 관리하기 위한 버퍼 관리자(Buffer Manager)를 사용
- **버퍼 관리자(Buffer Manager)**  
  ![image](https://user-images.githubusercontent.com/61646760/153241854-07b53428-c913-4d7e-a87e-f05d3a636b0d.png)
  - DBMS 상의 소프트웨어는 필요한 블럭이 있을 때 버퍼 관리자에게 해당 블럭을 요청
    - 요청된 블럭이 버퍼에 있다면, 버퍼 관리자는 블럭이 위치한 메모리 주소를 프로그램에게 전달
    - 요청된 블럭이 없는 경우, 버퍼 관리자는 버퍼 내의 새로운 공간을 할당하고 해당 블럭을 적재
    - 더 이상 적재할 공간이 없다면, 버퍼에 있는 기존 블럭을 선택하여 할당을 해지하고 해당 블럭을 적재
  - 버퍼 관리자의 기능
    - **버퍼 교체 전략(Buffer Replacement Strategy)**
      - 가용 공간을 확보하기 위해 기존에 적재된 블럭의 할당을 특정 기준에 의하여 해지
        - [메모리에 모든 블럭이 꽉 차 있다면? 어떤 블럭을 비워야 할까? 버퍼 관리자가 판단!](https://user-images.githubusercontent.com/61646760/153242361-92bf8524-07b8-44a4-978a-4edaff050421.png)
      - 미래에 가장 적게 사용될 블럭을 선택하여 디스크로 내보내는 것이 이상적인 버퍼 교체 전략
      - 버퍼 교체 전략 기법
        - **LRU(Least Recently Used)**
          - 최근에 가정 적게 참조된 블럭을 교체
            - 메인 메모리가 블럭별로 가장 마지막에 블럭을 사용한 시점 기록
          - `예) 4초, 5초, 8초, 1초 전에 참조된 블럭이 있다면, 8초 전 블럭을 교체`
        - **MFU(Most Frequently Used)**
          - 특정 기간 동안 가장 여러 번 사용된 블럭을 선택하여 블럭을 교체
            - 버퍼 관리자가 각 메모리 블럭에 대해 몇 번 접근되었는지 카운트함
          - `예) 1번, 3번, 2번, 5번 접근된 블럭이 있다면, 5번 접근된 블럭을 교체`
    - [고정 블럭과 블럭 강제 출력](https://user-images.githubusercontent.com/61646760/153245814-5226fdbd-096a-41f1-84d3-483bcb196cd5.png)
      - **고정 블럭**  
        - 장애로 인하여 메모리의 데이터가 손실되어 작업이 중단될 경우, 중단된 작업의 결과물이 디스크에 기록되는 것을 방지
          - 연산 중인 작업의 중간 결과가 디스크로 가지 않도록 막아 줌
        - 디스크 블럭이 교체되는 것을 제한
      - **블럭 강제 출력**
        - 시스템 로그와 같이 중요한 데이터는 디스크에 영구적으로 기록되어야 함
          - 버퍼 교체 전략에 의해 선택되지 않아도 강제로 디스크로 전달
        - 버퍼 공간이 필요 없어도 강제로 디스크에 기록

## 10강. 인덱싱
### 인덱스의 이해
- **인덱스(Index)**
  - DBMS에서 요청된 레코드에 빠르게 접근할 수 있도록 지원하는 데이터와 관련된 부가적인 구조
    - 데이터 검색에서 발생하는 비효율적인 데이터 입출력 문제를 해결하기 위한 목적으로 시작
  - 인덱스의 탐색키를 이용하여 해당 레코드가 저장된 블럭을 디스크 저장 장치 또는 메모리에서 파악하여 해당 블럭을 빠르게 적재
    - 메모리의 레코드 블럭을 곧바로 적재하는 게 아니라, 인덱스 블럭을 먼저 메모리에 올리고, 인덱스 블럭과 연결된 레코드가 저장돼 있는 블럭을 메모리로 올리는 것
      - 레코드 블럭을 바로 적재하는 것에 비해 단계가 하나 늘어난 것 같지만, 속도 면에서 월등히 빠름
      - 인덱스는 실제 레코드 블럭보다 사이즈가 훨씬 작기 때문에, 많은 양의 인덱스를 한꺼번에 메모리에 올릴 수 있고, 조건에 해당되는 레코드가 어디 있는지 그 위치를 빠르게 파악할 수 있기 때문
    - 탐색키 : 파일에서 레코드를 찾는 데 사용되는 컬럼이나 컬럼의 집합
- **인덱싱(Indexing)**
  - 인덱스를 구성하고 생성하는 작업
- 인덱스의 종류
  - **순서 인덱스(Ordered index)** : 특정 값에 대해 정렬된 순서 구조
  - **해시 인덱스(Hash index)** : 버킷의 범위 안에서 값의 균일한 분포에 기초한 구조로 해시 함수가 어떤 값이 어느 버킷에 할당되는지 결정
- 인덱스의 평가 기준
  - 접근 시간 : 데이터를 찾는 데 걸리는 시간
  - 유지 비용 : 새로운 데이터 삽입 및 기존 데이터 삭제 연산으로 인한 인덱스 구조 갱신 비용
  - 공간 비용 : 인덱스 구조에 의해 사용되는 부가적인 공간 비용 (저장에 필요한 공간)
### 순서 인덱스
- **순서 인덱스(Ordered index)**
  - 탐색키로 정렬된 순차 파일에 대하여 레코드에 대한 빠른 접근이 가능하도록 구성한 인덱스
    - 탐색키를 정렬하여 해당 탐색키와 탐색키에 대한 레코드와의 연계를 통하여 인덱스 생성
    - 순서 인덱스는 순차 파일 구조로 저장된 데이터 레코드를 대상으로 만든 인덱스
  - `예) 국어사전, 영어사전`
    - ㄱㄴㄷ순, abc순으로, 탐색키 값들이 순차적으로 정렬돼 있음
  - **인덱스 엔트리(Index entry)**
    - 각각의 레코드에 대해 빠른 접근을 가능하게 하는 작은 레이블 또는 태그
    - 탐색키 값과 레코드를 가리키는 포인터로 구성돼 있으며, 포인터는 다시 블럭ID와 오프셋으로 구성돼 있음  
      ![image](https://user-images.githubusercontent.com/61646760/153638499-f67a0837-2948-431b-9093-339a64cd55d1.png)
      - **탐색키 값** : 인덱스 엔트리가 어떤 레코드를 대상으로 하는지 표시
      - 포인터
        - **블럭ID** : 해당 레코드가 어느 디스크 블럭에 저장되어 있는지 표시
        - **오프셋** : 그 블럭 내부에서 해당 레코드가 어디에 위치해 있는지 (정확히는, 레코드가 블럭의 처음으로부터 몇 Byte 떨어져 있는지) 표시
    - [`예) 김영희 학생 레코드에 대한 인덱스 엔트리`](https://user-images.githubusercontent.com/61646760/153639203-24401f46-3a15-4fb7-bf4e-1dae79dd4ef8.png)
      - 학번이 탐색키, b<sub>1</sub>, b<sub>2</sub> 두 블럭 중 b<sub>2</sub> 블럭, b<sub>2</sub> 블럭의 시작점에서 30Byte 뒤에 김영희 레코드가 위치(오프셋)
      - 이를 통해 곧바로 해당 레코드에 접근이 가능함
  - 순서 인덱스의 종류
    - **밀집 인덱스(Dense index)**
      - 모든 레코드에 대해 `탐색키 값, 포인터` 쌍을 유지
        - 즉, 모든 레코드에 대해 인덱스 엔트리를 구성하는 인덱스
        - 모든 레코드로 곧바로 이동할 수 있는 경로를 제공받으므로, 인덱스 자체의 크기가 매우 커지는 단점이 있음
      - [`예) 순차 파일 구조로 구성된 과목 테이블과 밀집 인덱스`](https://user-images.githubusercontent.com/61646760/153640741-1dca5cec-6824-410a-a6a5-960050bd2441.png)
        - 모든 레코드(과목)에 대해 탐색키 값(과목번호)을 짝지어 인덱스 엔트리를 구성
        - 가령 `COM31`이 메모리에 적재돼서 `COM31`에 대한 포인터를 가져오면, 데이터베이스 시스템에 대한 레코드를 곧바로 메모리에 적재 가능
    - **희소 인덱스(Sparse index)**
      - 인덱스의 엔트리가 일부의 탐색키 값만을 유지
        - 밀집 인덱스와 달리, 인덱스 엔트리가 적으므로 사이즈가 작아 인덱스를 찾는 비용 자체는 적다는 장점이 있음
        - 모든 레코드에 대해 인덱스 엔트리가 구성돼 있는 게 아니므로, 인접한 인덱스 엔트리를 따라가서 순차 파일 내부에서 재검색을 해야 한다는 단점이 있음
      - [`예) 순차 파일 구조로 구성된 과목 테이블과 희소 인덱스`](https://user-images.githubusercontent.com/61646760/153641530-66ab08f1-32e9-4034-8b75-6f839279888b.png)
        - 모든 레코드가 아닌, 일부에 대해 인덱스 엔트리 구성
        - 가령 `COM31`을 찾으려면 바로 갈 수 있는 탐색키가 없으므로, `COM31`보다 작은 엔트리 중 가장 큰 값(`COM11`)을 써서, 순차 파일의 끝 링크를 따라가며 `COM31`이 나올 때까지 확인함
    - **다단계 인덱스(Multi-level index)**
      - 밀집 인덱스에 또 다른 밀집 인덱스를 만들어, 결과적으로 밀집 인덱스와 희소 인덱스를 혼용한 구조
        - 내부 인덱스와 외부 인덱스로 구성
          - 외부 인덱스를 **내부 인덱스보다 희소한 인덱스로 구성**하여 엔트리의 포인터가 내부 인덱스 블럭을 지칭
          - 포인터가 가리키는 블럭을 스캔하여 원하는 레코드보다 작거나 같은 탐색키 값 중에 가장 큰 값을 가지는 레코드를 탐색
        - 내부 인덱스는 1,000,000개의 블럭을 갖는 반면 외부 인덱스는 100개의 블럭만 사용하여 **작은 크기의 외부 인덱스로 메모리에 적재** 가능
          - 즉, 내부 인덱스는 밀집 인덱스로 만들고, 외부 인덱스는 희소 인덱스로 만들어 전체 인덱스 구조를 트리 형태로 만듦
      - 다단계 인덱스의 필요성
        - 4KB 크기의 한 블럭에 100개의 엔트리가 삽입될 때, 100,000,000개의 블럭에 대한 순서(밀집) 인덱스는 대략 4GB가 됨
          - 즉, 인덱스만으로도 4GB가 필요함
          - 인덱스를 더 효율적으로 사용하기 위한 구조 필요
            - 인덱스에 대한 인덱스를 만들면?
        - 인덱스 크기에 따른 검색 성능
          - 인덱스 크기 메모리 크기 : 디스크 I/O이 줄어 탐색 시간이 축소
          - 인덱스 크기 메모리 크기 : 저장된 블럭을 여러 번 나누어 읽어야 하기 때문에 디스크 I/O 비용이 증가하여 탐색 시간이 증가
      - 다단계 인덱스의 구조  
        ![image](https://user-images.githubusercontent.com/61646760/153709452-493932a1-d838-46a3-a98b-83e5aeea1f2a.png)
        - 인덱스 블럭을 실제 레코드가 위치한 블럭과 연결한 '데이터 블럭과 내부 인덱스'의 관계가 곧 밀집 인덱스 구조
        - 이러한 밀집 인덱스에 또 다른 인덱스, 즉 외부 인덱스를 만든 것이 다단계 인덱스
          - 외부 인덱스는 내부 인덱스 블럭의 모든 인덱스를 가리키지는 않으므로 곧바로 레코드에 접근할 수 있는 구조를 제공하지는 않으나, 사용자가 요구한 조건을 만족하는 레코드가 어디에 위치하는지 범위 정도는 알려줄 수 있음
          - 처음에는 작은 크기의 외부 인덱스를 메모리에 적재한 다음, 점점 범위를 좁혀 가면 결국 특정 레코드가 저장돼 있는 블럭을 메모리에 적재할 수 있음
### B+ 트리 인덱스
- 카드 10장 중 원하는 카드를 찾으려면?
  - 하나하나씩 뒤집어 봐야 함
    - 평균 5번 정도는 뒤집어 봐야 찾을 수 있음
  - 카드를 순차적으로 배열해 뒀다면?
    - 대략적인 위치 짐작이 가능 (1~15까지면 5는 대략 중간에 있음)
    - 가운데 카드를 뽑아 보고, 찾는 값보다 크면 왼쪽, 찾는 값보다 작으면 오른쪽 카드를 뽑아 봄
      - **이진 탐색 트리(Binary Search Tree)**
        - 이진 탐색을 보다 구조적으로 할 수 있게끔 만들어 놓은 트리 구조  
          ![image](https://user-images.githubusercontent.com/61646760/153710747-a9fdf9c7-0425-474c-832a-ea33bbadcc03.png)
          - 13을 찾으려면? 8보다 크므로 오른쪽, 10보다 크니까 오른쪽, 14보다 작으니 왼쪽
        - [자료구조 11강. BS, Splay, AVL, BB 참고](https://github.com/Esantomi/knou/tree/main/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0#11%EA%B0%95-BS-Splay-AVL-BB)
- **B+ 트리(B+ tree)**
  - 루트 노드로부터 모든 단말 노드에 이르는 경로의 길이가 같은 높이 균형 트리
    - 다단계 인덱스와 이진 탐색 트리를 결합시켜, 하나의 노드가 하나의 블럭 사이즈가 되게끔 하고, 가지가 두 갈래가 아닌 수십, 수백 갈래로 나뉘는 짧은 계층의 인덱스를 제공하는 구조
    - 순서 인덱스는 파일이 커질수록 데이터 탐색에 있어서 접근 비용이 커지는 문제점을 해결하기 위해 제안
    - 상용 DBMS에서도 널리 사용되는 대표적인 순서 인덱스
    - - [자료구조 12강. 멀티웨이 탐색 트리 (I) 참고](https://github.com/Esantomi/knou/tree/main/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0#12%EA%B0%95-%EB%A9%80%ED%8B%B0%EC%9B%A8%EC%9D%B4-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC-I)
  - B+ 트리의 구조  
    ![image](https://user-images.githubusercontent.com/61646760/153710539-688bc114-6874-4be8-be77-24856d81f52f.png)
    - 하나의 노드가 여러 개의 탐색키를 갖고, 그 하부에 여러 개의 자식 노드를 가짐으로써, 전체적으로 트리 구조를 이루는 인덱스
    - 단말 노드들이 서로를 가리키고 있는, 연결 리스트 형태를 갖는 것이 B+ 트리의 특징
  - B+ 트리의 노드 구조  
    ![image](https://user-images.githubusercontent.com/61646760/153715222-d3d79436-009d-4c16-b345-f50b383cea12.png)
    - 탐색키 K보다 작은 값이 왼쪽, 큰 값이 오른쪽에 들어가게끔 하위 자식 노드를 가리킬 수 있는 포인터 P가 있음
    - `n-1`개의 탐색키, 하위 노드를 가리키는 `n`개의 포인터로 구성
      - `n`을 차수라고 하며, 트리에서는 **팬아웃(fan-out)**이라고 부름
      - 즉, 팬아웃은 하위 노드의 개수를 나타냄
  - B+ 트리의 구성 요소
    - **인덱스 세트(Index set)**  
      ![image](https://user-images.githubusercontent.com/61646760/153755730-3fe3a441-566e-499c-8a53-6c5fb4f6c71b.png)
      - 루트 노드와 중간 노드로 구성
        - 단말 노드에 있는 탐색키 값을 신속하게 찾아갈 수 있도록 경로를 제공하는 목적으로 사용
        - 인덱스 세트에 있는 각각의 노드는 차수 `[𝑛/2] ~ 𝑛`개 사이를 자식으로 소유
      - 노드의 포인터는 실제 레코드를 가리키는 것이 아니라 또 다른 하위 노드를 가리키기 위한 포인터
    - **순차 세트(Sequence set)**  
      ![image](https://user-images.githubusercontent.com/61646760/153755787-2d36cf30-a20b-4089-8db2-bdd2f0d94f6a.png)
      - 단말 노드로 구성 (즉 B+ 트리 최하단 계층의 노드들로 구성)
        - 모든 노드가 순차적으로 서로 연결
          - 각각의 말단 노드들은 형제 노드를 포인터로 가리키고 있으므로 순차적
        - 단말 노드는 적어도 `(𝑛-1)/2`개의 탐색키를 포함
        - 순차 세트는 탐색키에 대한 실제 레코드를 지칭하는 포인터를 제공 (실제 디스크 내부 어떤 블럭의 몇 번째 오프셋에 레코드가 저장돼 있는지)
      - [단말 노드의 구성](https://user-images.githubusercontent.com/61646760/153756814-1bd2f40f-ad81-4cf3-9b05-82213da3f633.png)
        - `COM12`, `COM13`은 해당 탐색키에 대한 레코드가 어디 있는지 가리키는 포인터에 대한 태그
        - 노란 배경의 포인터는 실제 레코드가 저장된 위치를 가리킴
  - [`B+ 트리의 예`](https://user-images.githubusercontent.com/61646760/153856103-133e7aa3-25f0-4848-9a16-3d1429fedaaa.png)
    - 맨 아래 단말 노드들이 실제 레코드를 가리키는 순차 세트, 그 위의 노드들이 인덱스 세트
      - 가령 `HE14` 좌측의 포인터는 '패션과문화' 레코드를 가리킴
    - `COM44`의 과목명은?
      1. 일단 루트에서 시작 : `COM44`와 같거나 `COM44`보다 큰 탐색키 중 가장 작은 탐색키를 찾음
      2. 없으니 오른쪽 아래 노드로 이동
      3. 다시 `COM44`보다 큰 탐색키 중 가장 작은 탐색키를 찾음
      4. `ECE24`, `ECE31`은 둘 다 `COM44`보다 큰데, 그중 더 작은 값인 `ECE24`를 따라 왼쪽 아래 노드로 이동
      5. 노드에 `COM44`가 있으니, 그 왼쪽 포인터를 따라가서 레코드(클라우드컴퓨팅)에 접근함
    - [정재화 교수님 B+ Tree 애니메이션](https://cs.knou.ac.kr/~jaehwachung/BTree-master/static/BPlusTree.html)
      - 교재 따라서 실습해 볼 것
  - B+ 트리상에서의 삽입과 삭제
    - 레코드 삽입, 삭제 시 B+ 트리 수정 동반 (삽입은 분할, 삭제는 병합이 있을 수 있음)
      - 레코드 삽입
        - 노드에서 유지해야 할 탐색키와 포인터 수 증가로 인해 노드를 분할해야 하는 경우가 발생
      - 레코드 삭제
        - 레코드 삭제 시, 해당 탐색키를 단말 노드에서 제거
        - 노드에서 유지해야 할 탐색키 값과 포인터 수 감소로 형제 노드와 키를 재분배 또는 병합해야 하는 경우가 발생
        - 따라서 비용이 많이 듦
      - 높이 균형 유지
        - 노드가 분할되거나 병합되면서 높이의 균형이 맞지 않는 경우가 발생
      - 자주 사용되는 탐색키 값(조건)을 갖고 인덱스를 구성하는 것이 중요함
    - 삽입
      - 검색과 같은 방법을 사용하여 삽입되는 레코드의 탐색키 값이 속할 단말 노드를 탐색
        - 해당 단말 노드에 <탐색키, 포인터> 쌍을 삽입
        - 삽입 시 탐색키가 순서를 유지
    - 삭제
      - 삭제될 레코드의 탐색키를 통해 삭제될 탐색키와 포인터를 포함한 단말 노드를 탐색
        - 같은 탐색키 값을 가지는 다중 엔트리가 존재할 경우, 삭제될 레코드를 가리키는 엔트리를 찾을 때까지 탐색 후 단말 노드에서 제거
        - 단말 노드에서 제거된 엔트리의 오른쪽에 있는 엔트리들은 빈 공간이 없도록 왼쪽으로 이동
    - 노드가 분할되는 삽입
      - [`COM24` 노드 삽입 전](https://user-images.githubusercontent.com/61646760/153868828-385a8d62-dc7b-462e-b4e5-63a0bf8faff7.png)
        1. `COM24`보다 큰 탐색키 중 가장 작은 탐색키인 `COM34`를 따라 좌측으로 이동
        2. `COM12`는 `COM24`보다 크지도 않고 같지도 않으므로 우측으로 이동
        3. 단말 노드에 `COM24`가 들어갈 공간이 없음 → 분할 수행
            - 삽입 대상 노드에 추가적인 저장할 공간 부족 → 두 개의 노드로 분할  
              ![image](https://user-images.githubusercontent.com/61646760/153870251-eb80a007-551d-4c58-9e97-a7a13819846e.png)
              - `COM12`를 하나의 단말 노드로 구성
              - `COM24`와 `COM31`이 하나의 단말 노드로 구성
            - 부모 노드에 탐색키를 조정하고 추가된 노드에 대한 포인터를 삽입 (부모 노드 값 재조정)  
              ![image](https://user-images.githubusercontent.com/61646760/153870086-c64927a3-f473-4868-8cc3-578ee4e49e4f.png)
              - `COM24`, `COM31` 단말 노드에 접근하기 위한 포인터가 필요하므로, 가장 앞에 있는 값인 `COM24`를 상위 노드 탐색키 값에도 삽입함
              - 이로써 새로 분할하여 생성된 노드에도 접근할 수 있는 경로가 만들어짐
      - [`COM24` 노드 삽입 후](https://user-images.githubusercontent.com/61646760/153868956-2ee396bd-ec1f-4e6c-830c-5c3f049ad5b3.png)
        - 단말 노드가 하나 추가되는 재구조화 과정이 일어남
    - 탐색키의 삭제
      - 상기 B+ 트리에서 `COM44` 삭제
        1. `COM44`보다 큰 탐색키가 없으니 우측으로 이동
        2. `COM44`보다 큰 것 중 작은 것은 `ECE24`이므로 좌측으로 이동
        3. `COM44`를 찾았으므로 삭제
      - 상기 B+ 트리에서 `COM12` 삭제
        - `COM12`를 삭제하면 해당 단말 노드에 어떠한 탐색키도 남지 않게 된다는 문제가 발생함
        - `(𝑛−1)/2`개보다 탐색키가 적으므로 다른 노드와 별도의 재구조화 작업이 필요 
        - `COM12`가 저장된 노드 오른쪽의 형제 노드와 키를 재분배  
          ![image](https://user-images.githubusercontent.com/61646760/153874593-54f56682-8c8f-4f3f-aa4d-6067cdfdf807.png)
          - 즉 `COM12`를 삭제하고, 우측 노드의 작은 값(`COM24`)을 텅 빈 블럭으로 분배 및 큰 값(`COM31`)의 이동
          - 이후 상위 노드도 `COM24`, `COM31`로 변경해 줘야 함
        - [`COM12` 노드 삭제 후](https://user-images.githubusercontent.com/61646760/153874910-908f2bc8-b885-47a4-b4a9-c6a9fbdcda12.png)

## 11강. 해싱과 특수 인덱스
### 정적 해싱
- **해시(Hash)**
  - 탐색키에 산술적인 연산을 통해 버킷의 주소를 계산하는 해시 함수를 사용하여 데이터 배분 및 접근하는 기법  
    ![image](https://user-images.githubusercontent.com/61646760/154017903-0cfc67be-d434-42ea-b3b8-130154003fe8.png)
  - 해시의 구조  
    ![image](https://user-images.githubusercontent.com/61646760/154020533-2f999bd9-b335-4384-b68e-c2c7e613b06f.png)
    - 즉, 탐색키에 해당되는 레코드가 해시 함수를 통해 어느 버킷에 저장될지 결정됨 (버킷ID)
  - 해시 함수의 역할
    - 최상의 해시 함수 : [모든 버킷에 균등하게 레코드 저장](https://user-images.githubusercontent.com/61646760/154021583-f30c94a1-2f99-4bcc-93ac-0923bbbe3df0.png)
    - 최악의 해시 함수 : [한쪽 버킷에만 몰려서 레코드 저장](https://user-images.githubusercontent.com/61646760/154021703-b9b40125-ea05-43c6-9771-0df31400bd39.png)
    - 일반적 해시 함수 : [균등하지도 몰리지도 않는 레코드 저장](https://user-images.githubusercontent.com/61646760/154021935-6d42985b-d375-4bb6-8154-cf2e15a19660.png)
  - 해시 파일 구조
    - 각각의 레코드가 어느 버킷에 저장되어야 하는지 해시 함수가 결정하도록 만든 구조
- **버킷(Bucket)**
  - 한 개 이상의 레코드를 저장할 수 있는 저장 공간의 단위
  - 크기는 일반적으로 디스크 블럭의 크기와 일치 (인덱스와 마찬가지)
    - 따라서 버킷은 사실상 블럭과 동일하며, 해싱에서 블럭을 버킷이라고 부르는 것임
- **정적 해싱(Static Hashing)**
  - 버킷의 개수가 고정된 해싱 기법
    - 키 값이 𝐾<sub>𝑖</sub>인 레코드를 삽입하는 경우
      - ℎ(𝐾<sub>𝑖</sub>)를 통하여 𝐾<sub>𝑖</sub>에 대응하는 버킷 주소를 생성하고 레코드를 해당 버킷에 저장
    - 키 값이 𝐾<sub>𝑖</sub>인 레코드를 검색하는 경우
      - ℎ(𝐾<sub>𝑖</sub>)을 통하여 버킷 주소를 생성하고 버킷에 저장된 레코드 접근
      - ℎ(𝐾<sub>𝑖</sub>) = ℎ(𝐾<sub>𝑗</sub>) = m인 경우가 발생하기 때문에 버킷 m에 저장된 모든 레코드를 탐색하여 선택하는 과정이 필요
        - 버킷 내에 여러 레코드가 존재할 수 있기 때문에, 버킷 내에서 재탐색할 필요가 있음
  - 정적 해싱의 문제
    - 데이터베이스의 크기가 커짐에 따른 성능 감소
      - 버킷의 수가 정해져 있으므로, 버킷 내 레코드가 너무 많아져 버킷 내 검색이 느려짐
    - 미리 큰 공간을 잡을 경우 초기에 상당한 양의 공간이 낭비
    - 재구성 시 새롭게 선택된 해시 함수를 사용하여 모든 레코드에 대하여 다시 계산하고 버킷에 할당하는 대량의 비용이 발생
      - 이러한 이유에서, 해시 구조의 크기가 동적으로 결정되는 동적 해싱 기법 제안
- **충돌(Collision)** : 서로 다른 두 레코드가 동일한 버킷에 대응
  - **동거자(Synonyms)** : 충돌에 의해 같은 버킷 주소를 갖는 레코드  
    ![image](https://user-images.githubusercontent.com/61646760/154078306-47536782-307b-4a0b-bc8f-cde50483fb45.png)
    - r<sub>𝑖</sub>와 r<sub>𝑗</sub>는 탐색키가 다른데도 같은 버킷에 대응되므로 동거자가 됨
    - 충돌이 잦아 동거자가 많아지면 오버플로우 발생 가능성도 높아짐
- **오버플로우(Overflow)**
  - 버킷에 레코드를 저장할 수 있는 여유 공간이 없는 상황에 발생
    - 추가적인 버킷을 할당 또는 다음 버킷에 할당하여 처리
      - [`예)` B<sub>2</sub> 버킷이 가득 찼다면 B<sub>2-1</sub>을 추가하여 할당하거나 B<sub>3</sub>에 할당](https://user-images.githubusercontent.com/61646760/154079264-2abba5b8-0b69-4a85-bcdb-26419f89f7e4.png)
    - 오버플로우가 발생할수록 접근 시간이 길어지고 해시 성능이 저하
      - 여러 버킷에 나눠지므로, 검색을 추가로 수행해야 하기 때문
      - `예)` 𝐾<sub>𝑖</sub>를 검색했을 때, 해시 함수에서 B<sub>2</sub> 버킷에 저장돼 있다고 나오면, B<sub>2</sub> 버킷을 메모리에 올려 검색해야 하는데, 오버플로우로 인해 B<sub>2-1</sub>이나 B<sub>3</sub>에 할당했으므로, B<sub>2</sub> 버킷 대신 해당 버킷을 메모리에 올려 재검색해야 함
- **해시 인덱스(Hash index)**
  - 해시 파일 구조와 동작 방식을 레코드가 아닌 인덱스 엔트리에 적용한 인덱스
    - 즉, 버킷에 레코드 대신 인덱스 엔트리가 저장됨
      ![image](https://user-images.githubusercontent.com/61646760/154081609-75f41a9a-0180-455f-a6eb-d539dd1700fb.png)
        - 인덱스 엔트리를 해시 함수에 넣어 버킷ID(어느 버킷에 저장할지)를 도출
  - [`예) 해시 함수 ℎ(𝐾) = 𝐾 % 5를 적용한 해시 인덱스 구조`](https://user-images.githubusercontent.com/61646760/154082385-7fe8f4f0-5acc-4b5e-9639-ce682c9f483f.png)
    - 학번의 끝자리 숫자를 5로 나머지 연산(Modulo Operation: `%`)하여, 산출된 나머지(0~4)에 따라 버킷ID 결정
    - `예) 김마리아는 학생번호 끝자리가 5인데, 나머지 연산을 하면 0이므로 B<sub>0</sub> 버킷에 저장됨`
    - 왜 윤봉길 학생은 학생번호 끝자리가 5인데 B<sub>2</sub> 버킷에 할당?
      - **오버플로우** 때문 (B<sub>0</sub>, B<sub>1</sub> 버킷이 모두 가득 찼기 때문에 B<sub>2</sub> 버킷에 할당됨)
      - 세 번의 디스크 I/O를 거쳐야 윤봉길 학생 레코드에 접근할 수 있음 (오버플로우가 발생하면 인덱스 성능이 저하됨)

### 동적 해싱

### 비트맵 인덱스
