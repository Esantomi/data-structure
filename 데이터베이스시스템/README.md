# 데이터베이스시스템

### 목차
- [1강. 데이터베이스의 이해](#1강-데이터베이스의-이해)
  - [데이터 관리와 파일 처리 시스템](#데이터-관리와-파일-처리-시스템)
  - [데이터베이스와 DBMS](#데이터베이스와-DBMS)
  - [데이터베이스 언어와 아키텍처](#데이터베이스-언어와-아키텍처)
- [2강. 데이터베이스 모델링](#2강-데이터베이스-모델링)
  - [데이터베이스 모델링의 이해](#데이터베이스-모델링의-이해)
  - [사용자 요구사항 분석](#사용자-요구사항-분석)
  - [ER 모델](#ER-모델)
- [3강. 관계형 모델](#3강-관계형-모델)
  - [관계형 모델](#관계형-모델)
  - [ERD의 변환](#ERD의-변환)
  - [데이터 연산](#데이터-연산)
- [4강. SQL (1)](#4강-SQL-1)
  - [데이터베이스 언어](#데이터베이스-언어)
  - [데이터 정의 언어](#데이터-정의-언어)

## 1강. 데이터베이스의 이해
### 데이터 관리와 파일 처리 시스템
- **데이터(Data)**
  - 어떠한 사실에 대한 정량적, 정성적 특징을 나타낼 수 있는 값과 값에 대한 설명
    - [Data Storage Units](https://user-images.githubusercontent.com/61646760/149938472-559d71d6-1ac0-49ea-9ca0-397e2f942d76.png)
    - 빅데이터 처리
      - [IoT > Big Data > AI](https://user-images.githubusercontent.com/61646760/149781586-ae918fdf-8552-4098-83c0-5f9c017a1463.png)
  - 데이터 관리의 필요성
    - 대량의 데이터를 저장 및 관리하고 필요한 데이터를 신속히 검색할 수 있도록 보조하는 장치
      - `예) 파일 처리 시스템, SQL, 데이터 웨어하우스 등`
- **파일 처리 시스템(File Processing System)**
  - 파일을 사용하여 업무에 사용되는 데이터를 관리하는 방식
    - 데이터베이스가 개발되기 전에 데이터 관리에 사용
    - 업무별 애플리케이션이 개별 데이터를 데이터 파일에 저장·관리하는 시스템
  - 발생 가능한 문제
    1. 데이터 종속의 문제
        - 저장된 데이터가 특정 H/W에서 또는 사용자 및 S/W만 사용될 있도록 제한되는 문제
        - 물리적 데이터 종속, 논리적 데이터 종속
    2. 데이터 중복의 문제
        - 동일한 사항에 대한 중복 데이터는 일관성, 보안성, 경제성 측면에서 문제 발생
          - 일관성 : 한 사실에 대해 한 개의 데이터 값을 유지
          - 보안성 : 같은 데이터에 같은 수준의 보안 유지
          - 경제성 : 데이터에 대해 최소한의 저장 공간만을 점유
    3. 데이터 무결성 훼손의 문제
        - 실세계의 데이터는 데이터가 가질 수 있는 가능 범위(제약 조건)를 포함
          - `예) 1학기 최대 수강 과목은 18학점`
        - **데이터 무결성(Data Integrity)**
          - 데이터의 값과 값에 대한 제약 조건을 동시에 만족함으로써 데이터의 정확성 보장
        - 파일 시스템은 데이터 무결성을 보장하기 위한 기능을 제공하지 않음
    4. 데이터 동시 접근의 문제
        - 동일 데이터에 다수 사용자의 접근 허용 시 일관성이 훼손

### 데이터베이스와 DBMS
- **데이터베이스 시스템(Database System)**
  - 정보를 데이터베이스에 저장·관리하여 사용자에게 요구된 형태의 정보로 제공하는 컴퓨터 기반 시스템
    - 즉, `데이터베이스 시스템 = 데이터베이스 + 데이터베이스 관리 시스템(DBMS)`
  - 데이터베이스 시스템의 구성
    ![image](https://user-images.githubusercontent.com/61646760/149782623-b6906d5a-c3cf-4cb3-b3f2-3876e2d50873.png)
    - **메타데이터(Metadata)**
      - 데이터에 대한 데이터
- **데이터베이스(Database)**
  - 특정 기관의 애플리케이션 시스템에서 사용되는 데이터의 집합
  - 데이터베이스의 특징
    - 데이터베이스는 자기 기술성, 추상화, 다중 뷰, 동시성 제어 등의 기능을 통해 파일 처리 시스템의 문제점을 극복한다.
      1. 데이터베이스 시스템의 자기 기술성
          - 데이터와 데이터의 정의 및 설명(메타데이터)을 포함
      2. 프로그램과 데이터의 격리 및 추상화
          - 사용자에게 데이터에 대한 개념적인 표현을 제공하여 접근성을 향상
      3. 다중 뷰 제공
          - 각 사용자가 관심을 갖는 데이터베이스의 일부만을 표현할 수 있는 기능 제공
      4. 데이터 공유와 다수 사용자 트랜잭션 처리
          - 다수의 데이터 조작 요청을 동시성 제어 기능을 통해 데이터의 일관성을 보장하면서 동시에 작업을 수행
- **데이터베이스 관리 시스템(Database Management System: DBMS)**
  - 데이터베이스에 저장된 데이터의 구성, 저장, 관리, 사용을 위한 소프트웨어 패키지
    ![image](https://user-images.githubusercontent.com/61646760/150522013-193db0de-06dd-4a55-8038-69cdbd4f099b.png)
    - 데이터 사용과 데이터 관리 측면을 분리
  - **DBMS 3단계 구조(DBMS Three Level Architecture)**
    - 데이터 추상화와 데이터 독립성을 확보하기 위한 개념적-논리적-물리적 3단계 구조
      ![image](https://user-images.githubusercontent.com/61646760/149783043-713498db-ca00-4c0c-904d-be33c01f6933.png)
      - **외부 단계(External Level)**
        - 사용자 뷰
        - **외부 스키마(External Schema)**
          - 외부 단계에서 사용자에게 필요한 데이터베이스를 정의한 것
          - 각 사용자가 생각하는 데이터베이스의 모습, 논리적 구조로 사용자마다 다른 모습
          - 데이터베이스 하나에 외부 스키마 여러 개 존재
      - **개념 단계(Conceptual Level)**
        - 데이터베이스의 논리적인 전체 구조
        - **개념 스키마(Conceptual Schema)**
          - 개념 단계에서 데이터베이스 전체의 논리적 구조를 정의한 것
          - 조직 전체의 관점에서 생각하는 데이터베이스의 모습
          - 데이터베이스 하나에 개념 스키마 하나만 존재
      - **내부 단계(Internal Level)**
        - 데이터가 기억장소에 저장되기 위한 물리적 구조
        - **내부 스키마(Internal Schema)**
          - 전체 데이터베이스가 저장 장치에 실제로 저장되는 방법을 정의한 것
          - 레코드 구조, 필드 크기, 레코드 접근 경로 등 물리적인 저장 구조를 정의
          - 데이터베이스 하나에 내부 스키마 하나만 존재
      - **외부-개념 사상(external-conceptual mapping)**
        - 특정 외부 스키마와 개념 스키마 간의 대응 관계를 정의
      - **개념-내부 사상(conceptual-internal mapping)**
        - 개념 스키마와 내부 스키마 간의 대응 관계를 정의
- **트랜잭션(Transaction)**
  - 하나의 논리적 작업을 처리하기 위한 일련의 데이터베이스 명령의 집합
    - [`예) 트랜잭션 1, 트랜잭션 2`](https://user-images.githubusercontent.com/61646760/149785989-7e8d4a9a-5dc0-41c7-a282-2faf22583b41.png)
      - 트랜잭션 1은 `Read(A)`와 `Write(A)`로 구성돼 있으며, 트랜잭션 1이 끝난 뒤에야 트랜잭션 2를 수행할 수 있다.

### 데이터베이스 언어와 아키텍처
- **데이터베이스 언어(Database Language)**
  - DBMS는 사용자가 데이터베이스를 쉽게 사용하고 다룰 수 있도록 언어 형태의 인터페이스를 제공
  - 역할에 따라 두 종류의 언어로 구분
    - **데이터 정의 언어(Data Definition Language: DDL)**
      - 데이터베이스 객체를 생성, 수정, 삭제하기 위한 언어
      - DDL의 요구 기능
        - 데이터 모델에 따라 애플리케이션 프로그램이 요구하는 데이터의 논리적 구성이나 특징을 규정
        - 데이터가 기억장치에 저장되도록 데이터의 물리적 구성을 규정
        - 물리적 구성을 논리적 구성으로 변환이 가능하도록 데이터의 물리적 구성과 논리적 구성 간의 사상(mapping)을 규정
    - **데이터 조작 언어(Data Manipulation Language: DML)**
      - 구조화된 데이터에 사용자가 접근 및 조작할 수 있도록 지원하는 언어 (검색, 삽입, 삭제, 수정)
      - DML의 요구 조건
        - 데이터 조작이 쉽고 간편
        - 데이터 조작 기능이 정확하고 완전
        - 사용자의 요청을 시스템 내부에서 효율적으로 처리 가능
  - 현대 데이터베이스 언어는 자연어와 유사한 형태의 **SQL**로 표준화
- **데이터베이스 시스템 아키텍처(Database System Architecture)**
  - DBMS는 전체 시스템을 구성하는 방식에 따라 두 방식으로 아키텍처를 구성할 수 있다.
    - **중앙집중식 방식(Centralized Database System)**
      - 단일 서버가 다수의 클라이언트 장치를 대신하여 작동
      - 중앙 컴퓨터의 과부하로 전체적인 성능 저하
    - **분산 시스템 방식(Distributed Database System)**
      - 클라이언트 장치의 성능 향상으로 자체적인 처리 능력 보유
      - **클라이언트-서버 데이터베이스 시스템(Client-Server Database System)**
        - 애플리케이션 프로그램의 부하를 분산
        - 소프트웨어의 유지 보수 비용을 절감 및 이식성 증가
        - 2계층 구조(2 Tier Architecture)와 3계층 구조(3 Tier Architecture)
          ![image](https://user-images.githubusercontent.com/61646760/149785804-75c02032-065f-4290-b22e-88d3b15f9622.png)
          - [다층 구조 문서 참고하기](https://ko.wikipedia.org/wiki/%EB%8B%A4%EC%B8%B5_%EA%B5%AC%EC%A1%B0)

## 2강. 데이터베이스 모델링
### 데이터베이스 모델링의 이해
- **데이터베이스 모델링(Database Modeling)**
  - 데이터의 의미를 파악하고 데이터와 관여하는 업무 프로세스를 개념적으로 정의하고 분석하는 작업
    - 데이터베이스 모델링의 필요성
      - 비즈니스적 관점 : 어떤 데이터를 저장해야 하는가
      - 컴퓨터 프로그래머 관점 : 어떻게 데이터를 저장해야 하는가 
    - 데이터베이스 모델링의 단계
      ![image](https://user-images.githubusercontent.com/61646760/149943771-2b232079-98fe-4914-8240-17a3cbd9d0c5.png)
      1. **개념적 데이터 모델링(Conceptual Data Modeling)**
          - 요구 사항의 해석 오류를 방지
          - 실세계의 데이터를 개념적으로 일반화시켜 데이터 구조 데이터 타입, 속성, 관계, 제약 조건 등을 이끌어 내는 과정
            - 즉, 사람에게 필요한 작업
          - [`예) 개념적 데이터 모델링의 결과 : 학생-학과-과목-계좌-교수 개체 집합 간 ERD`](https://user-images.githubusercontent.com/61646760/150093315-fc825a4e-695d-4be4-b319-aa7cea914e5a.png)
      2. **논리적 데이터 모델링(Logical Data Modeling)**
          - 특정 DBMS의 구현 모델에 맞춰 데이터를 표현하는 과정
          - 데이터 정의 언어(DDL)로 기술된 개념 스키마 생성
            - 즉, 개념적 데이터 모델링한 것을 DBMS에 어떻게 저장할 것인지 고민하는 단계
          - [관계형 모델(Relational Model)](#관계형-모델)
            - [ERD를 관계형 모델에 맞는 구조, 즉 릴레이션으로 변환 필요](#ERD의-변환)
      3. **물리적 데이터 모델링(Physical Data Modeling)**
          - 데이터베이스 파일의 내부 저장 구조, 파일 구성, 인덱스, 접근 경로 등을 결정하는 과정
  - [데이터베이스 시스템 구현 과정](https://user-images.githubusercontent.com/61646760/149942182-fdd24d22-7de8-42db-bf2a-8ecf9826e205.png)
    - 좌측은 애플리케이션 구현 과정(소프트웨어 공학), 우측은 데이터베이스 시스템 구현 과정
    - 전체적인 데이터 구조를 가진 개념 스키마가 애플리케이션 설계 과정에 반영되면 보다 구체적인 아키텍처를 구축할 수 있다. 
- **데이터 모델링(Data Modeling)**
  - 실세계의 일부분을 DBMS가 지원하는 데이터 모델의 형태로 나타내는 과정
    - 사용할 데이터를 선별하여 데이터베이스에 체계적으로 구조화하여 저장·사용할 방법
- **데이터 모델(Data Model)**
  - 의미, 데이터 타입, 연산 등을 명시하기 위해 사용할 수 있는 개념들의 집합

### 사용자 요구사항 분석
- **사용자 요구사항 분석(Requirements analysis)**
  - 사용자가 원하는 애플리케이션 프로그램의 요구 사항을 만족하는 데이터베이스를 모델링하기 위해 실제 업무에서 사용되는 데이터의 종류와 특징을 폭넓게 파악하는 과정
    - 시스템의 대상이 되는 업무를 분석
      - 정보 시스템의 데이터베이스가 신속하고 효과적으로 업무 처리를 지원
      - 필요한 데이터를 저장 및 운용할 수 있는 구조 개발
    - 도출, 분석, 기록의 3단계로 수행
      - 국제 표준화 : [IEEE-Std-830](https://standards.ieee.org/standard/830-1998.html)
  - 사용자 요구사항 분석의 필요성
    1. 데이터에 대한 충분한 사전 분석없이 적절한 설계가 불가능 
        - 데이터베이스의 활용 범위가 확대됨에 데이터베이스의 효율적 운용에 초점
        - 데이터베이스의 구조가 점차 복잡해지고 수명 주기가 단축되고 때문에 신속, 정확성이 요구
    2. 사용자의 요구를 명세하지 않고 데이터베이스 설계 및 개발을 진행하는 경우
        - 결과물의 완성도 저하 및 사용자 신뢰도 추락
        - 개발 후 발생하는 에러 수정에 많은 추가 비용 지출
  - 사용자 요구사항 분석의 과정  
    ![image](https://user-images.githubusercontent.com/61646760/149949955-b2fe2a33-65fe-4667-bcda-332cd17a6ba6.png)
    1. 요구사항 도출
        - 구축 대상, 프로젝트 목표, 범위를 기준으로 조사 범위를 결정
        - 업무 관계자 인터뷰
        - 외부 자료 수집 및 분석
    2. 요구사항 기록
        - 요구 사항 목록 정리 및 관리자의 승인
        - 정리된 요구 사항을 형식에 맞춰 문서화
        - 프로젝트 종료 때까지 반영 여부 지속적 관리
    3. 요구사항 분석
        - 도출된 요구사항의 명확성, 완전성, 모호성 검증
        - 불완전한 부분이 존재할 경우 요구 사항 도출 단계 재수행
        - 요구 사항을 분류하여 통합 또는 분리
    - **제안 요청서(Request for Proposal: RFP)**
      - 발주자가 특정 과제의 수행에 필요한 요구 사항을 체계적으로 정리하여 제시함으로써 제안자가 제안서를 작성하는 데 도움을 주기 위한 문서
    - **요구사항 명세서(Software Requirement Specification: SRS)**
      - 서비스를 구현하기 위한 다양한 요구 사항을 분석하여, 명확하고 완전하게 정리 기록한 문서
    - **요구사항 정의서(Requirements Definition)**
      - 요구 사항이 모호하거나 정확하지 않을 때는 이전 단계로 회귀하여 요구 사항을 교정

### ER 모델
- **ER 모델(Entity-relationship model)**
  - 실세계의 속성들로 이루어진 개체(entity)와 개체 사이의 관계(relationship)를 정형화시킨 모델
    - 개념적 모델링 단계에서 사용되는 데이터 모델
      - 1976년 카네기 멜론 대학의 Peter Chen 박사에 의하여 제안
      - 데이터 구조와 관계를 ER 다이어그램(ERD)으로 표현
      - 사실상 현재 표준으로 사용되는 데이터 모델
    - 구성 요소
      - 개체 집합
      - 관계 집합
      - 속성
- **개체(Entity)**
  - 실세계에 존재하는 다른 객체와 구별되는 유무형의 사물
  - 개체를 설명하는 여러 속성들로 구성
- **개체 집합(Entity Set)**
  - 같은 속성을 공유하는 개체들의 모임
  - [`예) 학생 개체 집합`](https://user-images.githubusercontent.com/61646760/149961141-98444302-3bc1-4ce1-a46d-4ff38066b6f5.png)
- **관계(Relationship)**
  - 개체와 개체 사이의 연관성
- **관계 집합(Relationship Set)**
  - 개체 집합 간의 전체적 연결 관계
  - [`예) 전공 관계 집합`](https://user-images.githubusercontent.com/61646760/149965080-80acf164-f587-49d1-bfa4-b7fa261e6338.png)
- **속성(Attribute)**
  - 개체를 구체적으로 설명하는 특성
  - 속성에 포함될 수 있는 값의 특성에 따라 여러 종류로 구분
    - 속성의 종류
      - 단순 속성과 복합 속성
        - **단순 속성(Simple Attribute)**
          - 더 이상 작은 구성 요소로 나눌 수 없는 속성
          - `예) 학생 이름, 성별, 나이`
        - **복합 속성(Composite Attribute)**
          - 더 작은 구성 요소로 나눌 수 있는 속성
          - `예) 생년월일` (년월일로 구분 가능)
      - 단일값 속성과 다중값 속성
        - **단일값 속성(Single-Valued Attribute)**
          - 하나의 개체에 대해 단 하나의 값만을 갖는 속성
          - `예) 학생 이름, 성별, 나이`
        - **다중값 속성(Multi-Valued Attribute)**
          - 하나의 개체에 대해 여러 개의 값을 갖는 속성
          - `예) {전화번호}`
            - `{}`로 표기
      - 유도 속성과 저장 속성
        - **유도 속성(Derived Attribute)**
          - 다른 속성의 값으로부터 값이 유추될 수 있는 속성
          - `예) 나이()`
            - 생년월일로부터 나이 유추 가능
            - `()`로 표기 
        - **저장 속성(Stored Attribute)**
          - 유도 속성을 위해 사용될 수 있는 속성
          - `예) 생년월일`
            - 유추할 수 없으며, 저장이 필수적인 속성
      - **널(Null) 속성**
        - 일부 속성값을 가지지 못해 널(null) 값을 갖는 속성
        - 즉, 입력되지 않아 값을 모르는 경우
- **제약 조건(Constraints)**
  - 데이터 모델은 데이터, 의미, 구조, 연관성 및 데이터의 조건을 표현하기 위한 도구
  - ER 모델은 개체와 관계에 대한 표현의 정확성을 위해 데이터가 항상 준수해야 하는 제약 조건을 정의할 수 있는 방법을 제공
    - 제약 조건(Constraints)의 종류
      - **사상수(Mapping Cardinality)**
        - 관계 집합에 참가한 개체 집합들에 대해 각각의 개체가 얼마만큼의 관계를 맺을 수 있는지 명시한 수
        - `예)` [`일대일(1:1)`](https://user-images.githubusercontent.com/61646760/149970202-a8891941-90e4-4c42-9399-5ffa0ce2847c.png), [`일대다(1:N)`](https://user-images.githubusercontent.com/61646760/149970476-df8b256a-efe9-49b1-8e9d-24a8377ba0ee.png), `다대일(N:1)`, [`다대다(M:N)`](https://user-images.githubusercontent.com/61646760/149970621-24b0baa5-923e-457d-a642-cfccd10f8b15.png)
      - **참가 제약 조건(Participation Constraints)**
        - 전체적 참가 : 어떤 개체 집합의 모든 개체가 관계 집합에 참여하는 조건  
          ![image](https://user-images.githubusercontent.com/61646760/149971097-f7958b1e-8f58-4822-a602-10583148ca3d.png)
          - 이중 선을 통해 전체 참가 표시 (모든 과목은 교수와 관계를 가져야 함)
        - 부분적 참가 : 어떤 개체 집합의 일부 개체가 관계 집합에 참여하는 조건
          - '교수'는 부분적 참가를 하는 집합이며, 단일 선으로 표시 (강의를 맡지 않는 교수도 있음)
      - **키 속성(Key Attribute)**
        - 키(key)는 각 개체를 구별하는 데 사용되는 유일한 값을 가지는 속성의 집합
          - 개체를 고유하게 구분하는 역할
          - 관계 집합의 특정 관계를 찾는 역할
        - `예) 학번`
          - 밑줄로 표기
- 특수 속성과 특수 관계
  - **관계 집합의 속성**
    - 두 개체 집합의 관계에서 생성되는 값을 저장하는 속성
    - [`예) 수강 신청 일시 (신청 전에는 없던 속성)`](https://user-images.githubusercontent.com/61646760/149973143-a3068924-2510-48a8-85b3-f6cec90c4601.png)
  - **재귀적 관계(Recursive Relationship)**
    - 한 개체 집합이 자기 자신과 관계 집합을 형성하는 관계
    - [`예) 선수과목코드는 같은 집합 내 과목코드와 관계를 가짐`](https://user-images.githubusercontent.com/61646760/149973496-b209f9f3-3e40-4a4f-814b-119f1fa565b7.png)
  - 특수 관계  
    - **약한 개체 집합(Weak Entity Set)**  
      ![image](https://user-images.githubusercontent.com/61646760/149974696-0ca3e774-5d91-40e1-9a9d-7c201806a53c.png) 
      - 개체의 존재 유무가 관계를 맺고 있는 개체의 존재에 종속되는 개체 집합
      - `예) 계좌 개체는 학생 개체에 종속되어, 학생이 자퇴를 하면 계좌도 사라짐`
        - 이중 선은 참가 제약 조건의 전체적 참가 표시!!
    - **강한 개체 집합(Strong Entity Set)**
      - 약한 개체 집합과 연결되는 일반 개체 집합
      - `예) 계좌 개체에 대비되는 학생 개체`

## 3강. 관계형 모델
### 관계형 모델
- **관계형 모델(Relational Model)**
  - 1969년 에드가 F. 코드에 의해 제안
  - 관계(Relation)로 데이터를 표현하는 모델
  - 데이터 표현이 단순하고 직관적인 구조화 모델
  - 현재 대다수 DBMS의 기초
    - 관계형 모델을 사용하는 관계형 DBMS(RDBMS)
    - Oracle, DB2, PostgreSQL, MySQL, MSSQL 등
- **릴레이션(Relation)**
  - 표와 매우 유사한 구조이지만 일반 표와는 달리, 레코드의 유일성, 레코드의 무순서성, 컬럼의 무순서성, 컬럼 값의 유일성이라는 특징을 갖는다.
  - 릴레이션의 구성
    ![image](https://user-images.githubusercontent.com/61646760/150096225-ea4ce392-3c10-45b9-8533-ed30d795a991.png)
    - **스키마(Schema)**
      - 열에 대한 의미를 갖는 표 머리
      - `예) 학과이름, 단과대학, 주소, 전화번호, 졸업학점`
    - **레코드(Record), 튜플(Tuple)**
      - 행
      - `예) 컴퓨터과학과 | 자연과학대학 | ... | 02-3668-4650 | 130`
    - **컬럼(Column), 속성(Attribute), 필드(Field)**
      - 열
      - `예)`
        ```
        전화번호
        02-3668-4550
        02-3668-4590
        02-3668-4640
        ...
        ```
    - **컬럼 값**
      - 하나의 값에 두 개의 메타데이터가 붙은 것
      - 즉, 레코드와 컬럼 간 관계를 통한 데이터
      - `예) 컴퓨터과학과의 전화번호 02-3668-4650`
    - **인스턴스(Instance)**
      - 특정 시점에서 어떤 릴레이션 스키마에 맞춰서 레코드가 들어가 있는 상태
  - 릴레이션의 특징
    - 레코드의 유일성 : 중복된 레코드의 존재가 불가능
    - 레코드의 무순서성 : 레코드의 순서는 의미가 없음
    - 컬럼의 무순서성 : 컬럼의 순서가 없고, 이름과 값의 쌍으로 구성
    - 컬럼 값의 원자성 : 모든 값들은 나눌 수 없는, 단 하나의 의미로 구성
- **키(Key)**
  - 키의 역할
    - 릴레이션의 레코드를 유일하게 식별하는 값
  - 키의 속성
    - **유일성(Uniqueness)**
    - **최소성(Irreducibility)**
  - 키의 종류
    - **수퍼키(super key)**
      - 유일성 만족
      - `예) 학과이름, {학과이름, 단과대학}, 주소, 전화번호, {전화번호, 졸업학점} 등`
        - `{학과이름, 단과대학}`은 유일성은 만족시키나, 최소성은 만족시키지 못함
    - **후보키(candidate key)**
      - 유일성, 최소성 만족
      - `예) 학과이름, 주소, 전화번호`
    - **기본키(primary key: PK)**
      - 레코드의 구분을 위해 선택된 후보키
      - `예) 학과이름`
    - **외래키(foreign key: FK)**
      - 참조된 다른 릴레이션의 기본키
      - 키의 참조는 두 릴레이션에 포함된 레코드 간 연관성을 표현
      - [`예) 학과 개체 집합과 교수 개체 집합 간 외래키(FK) : 소속학과`](https://user-images.githubusercontent.com/61646760/150117396-c2c13cb4-57a0-416d-afb7-a8a3f24aa2bd.png)
- 관계형 모델의 제약 조건(constraints)
  - 영역 제약 조건
    - 컬럼에 정의된 영역(domain)에 속한 값으로만 컬럼 값이 결정
  - 키 제약 조건
    - 키는 레코드를 고유하게 구별하는 값으로 구성
  - 개체 무결성 제약 조건
    - 어떠한 기본키 값도 널(null)이 될 수 없음 (키는 구분에 필요한 고유값이므로 null이면 안 됨)
  - 참조 무결성 제약 조건
    - 반드시 존재하는 레코드의 기본키만 참조 가능 (즉 없는 걸 참조하는 것은 불가능)
- **널(Null)**
  - '없음' 또는 '0'이 아닌 미지의 값에 대한 표현
    - 입력된 적이 없는 값
    - 적용 불가능한 값

### ERD의 변환
- **논리적 데이터 모델링**
  - 관계형 DBMS(RDBMS)의 구현 모델에 맞춰 데이터의 구조와 관계를 표현
    - 작성된 ERD를 RDBMS가 수용 가능한 구조, 즉 릴레이션으로 변환
  - ER 모델링의 결과를 토대로 실제 상용 DBMS상의 데이터베이스를 만들기 위해서는 각 DBMS에 맞는 구현 데이터 모델로의 변환이 필요한데, 이러한 변환 과정을 **논리적 데이터 모델링**이라고 한다.
- ERD의 관계형 모델로의 변환 방법
  1. 개체 집합 : 개체 집합은 릴레이션으로 변환
  2. 약한 개체 집합 : 강한 개체 집합의 키 속성을 약한 개체 집합의 릴레이션에 포함
  3. 일대일 관계 : 두 릴레이션 중에서 한 릴레이션의 기본키를 다른 릴레이션에서 외래키로 참조
  4. 일대다 혹은 다대일 관계 : '일'쪽의 기본키를 '다'쪽 릴레이션에서 외래키로 참조
  5. 다대다 관계 : **관계 릴레이션을 생성하고, 두 릴레이션의 기본키를 각각 참조하는 외래키를 복합키 형태의 컬럼**으로 구성
  6. 다중값 속성 : 릴레이션의 기본키를 참조하는 외래키와 다중값 속성으로 별도의 릴레이션으로 구성
  7. 관계 집합의 속성 : 외래키가 위치한 릴레이션의 컬럼으로 삽입
- ER 다이어그램의 예시1
  ![image](https://user-images.githubusercontent.com/61646760/150123124-2f18e487-bbf9-4183-b7cc-e13e6e1c8d32.png) 
  - 교수 개체 집합은 `교수번호, 교수이름, 직위, 연봉`의 4개 속성으로 구성되어 있다.
  - 교수 개체 집합의 키 속성은 `교수번호`이다. (밑줄)
  - 교수 개체 집합과 과목 개체 집합은 `강의` 관계 집합을 갖는다. (어떤 교수가 어떤 과목을 가르침)
  - 교수 개체 집합과 과목 개체 집합은 `1:N` 관계이다. (1이 화살표, N은 그냥 직선)
    - 즉, 한 명의 교수는 여러 과목을 가르칠 수 있고, 하나의 과목은 반드시 한 명의 교수에 의해서 강의된다.
  - 교수 개체 집합은 부분적 참가, 과목 개체 집합은 전체적 참가이다. (부분적 참가는 그냥 직선, 전체적 참가는 이중 선)
    - 즉, 어떤 교수는 강의를 안 할 수도 있지만(관계 집합에 미참여), 모든 과목은 특정 교수에게 할당되어야 한다.(관계 집합에 무조건 참여)
- ER 다이어그램의 변환 예시1
  ![image](https://user-images.githubusercontent.com/61646760/150121658-0a8ab507-3283-473b-bc6e-afc677cbb4b6.png)
  - RDBMS에서 사용하기 위해 릴레이션으로 변환
    - 하나의 개체 집합은 하나의 릴레이션으로 변환된다.
      - 교수 개체 집합은 교수 릴레이션이 됨
    - 각각의 속성은 각각의 컬럼으로 변환된다.
      - 교수번호, 교수이름, 직위, 연봉 등이 스키마가 됨
    - 키 속성은 기본키 컬럼으로 변환된다.
      - 밑줄 친 교수번호가 교수번호(PK)로 릴레이션에 들어가게 됨
    - 관계 집합은 외래키로 표현되며, `1:N` 구조에서는 `N` 쪽에 외래키를 위치한다.
      - 교수 릴레이션의 교수번호 기본키가 과목 릴레이션에 외래키로 참조된다. 
- ER 다이어그램의 변환 예시2  
  [학생-과목 관계](https://user-images.githubusercontent.com/61646760/150124064-21df98bf-b804-4635-9e61-da20c1c34988.png)
  - `N:M` 즉 다대다 관계 (그냥 직선)
    - 학생은 여러 과목을 수강할 수 있고, 하나의 과목은 여러 학생들이 수강할 수 있음
  - 수강 관계는 어떤 학생이 어떤 과목을 수강 신청하면 그때 `신청시각`이라는 '관계 집합의 속성'이 만들어진다.
    - 다대다 관계는 한쪽이 다른 한쪽의 외래키로 들어갈 수 없으므로, **관계 집합 자체를 하나의 릴레이션**으로 만들어 준다. (다대다 관계에서만)
    - 관계 집합 릴레이션에는 양쪽 릴레이션의 기본키들이 참조되어 외래키로 들어가게 된다. (기본키 역할도 수행)
    - 관계 집합의 속성은 외래키가 위한 릴레이션에 따라 붙는다.
- ER 다이어그램의 변환 예시3  
  [학생-계좌 관계](https://user-images.githubusercontent.com/61646760/150125065-df403600-43fd-4e62-a92d-e9013f533712.png) 
  - `1:1` 관계이므로 각각의 개체 집합을 각각의 릴레이션으로 변환
  - `1:1` 관계에서는 어느 쪽으로든 외래키를 참조 가능하지만, 되도록이면 개수가 적은 쪽으로 외래키를 넣는다.
  - `보유` 관계 집합이 이중 마름모이므로 약한 개체와의 관계를 나타낸다.
    - 약한 관계이므로, 학생이 학생 릴레이션에서 사라지면 그 학생의 계좌번호도 사라진다.
      - 이때 계좌 릴레이션의 외래키인 `학생번호`는 단순히 FK일 뿐 아니라, 계좌 릴레이션의 기본키(PK)인 `계좌번호`와 같이 복합키로서 기본키를 이루게 된다.
      - 이는 참조 무결성 제약 조건에 의해 계좌 릴레이션의 기본키(PK)인 `학생번호`가 Null이 될 수 없어서, 해당 학생의 계좌를 삭제할 수밖에 없게끔 하기 위해서이다.
        - 따라서, 약한 개체 집합에 대해서는, 참조되는 외래키가 그 릴레이션의 기본키가 되게끔 해야 한다.
- [기타 ERD 참고용 링크](https://developer0809.tistory.com/103)

### 데이터 연산
- **관계 연산(Relational Data Operation)**
  - 관계형 모델을 기반으로 구성된 릴레이션을 사용하여 새로운 릴레이션을 생성하는 표현
    - 즉, 기존의 많은 양의 데이터를 가진 릴레이션에서 사용자가 필요로 하는 데이터만 포함한 새로운 릴레이션을 생성
  - 사용자의 관점에서 필요한 데이터를 릴레이션에서 추출하는 방법을 제공하는 도구
    - **관계 대수(Relational Algebra)**
      - 관계 연산을 정의하는 방법
      - 주어진 릴레이션에서 필요한 릴레이션을 만드는 연산자(`∪, ∩, -, σ, π, x, ⋈, ÷, 집계함수` 등)로 구성
      - 관계 대수 연산자는 새로운 임시 릴레이션을 생성
      - 연산자를 중첩하여 연산 처리 절차를 표현
- **셀렉트 연산(SELECT operation)**
  - 주어진 릴레이션에서 조건을 만족하는 레코드를 갖는 릴레이션을 생성  
    σ<sub>조건</sub>(R)
    - `σ` : 셀렉트
    - `(R)` : 대상 릴레이션
    - <sub>조건</sub> : 아래 첨자로, 원하는 조건 입력
      - `aΘb` 또는 `aΘv`
        - `a, b` : 속성 이름
        - `Θ` : 비교자 {`＝, ≠, ＜, ＞, ≤, ≥`}
        - `v` : 상수 값
        - `R` : 릴레이션
      - 조건의 결합 : `∧`(and), `∨`(or)
  - [`셀렉트 연산의 예`](https://user-images.githubusercontent.com/61646760/150130084-e14890a4-3db9-4351-b518-abf86db18474.png)
    - 교수 릴레이션에서 소속학과가 컴퓨터과학과인 레코드만 추출하여 임시 릴레이션 생성
- **프로젝트 연산(PROJECT Operation)**
  - 기술된 컬럼만 갖는 릴레이션으로 재구성  
    π<컬럼리스트>(R)
    - <컬럼리스트> : A1, A2, …, An와 같이 R에 존재하는 컬럼을 ,(콤마)로 분리하여 기술
      - 아래 첨자로 표기
  - [`프로젝트 연산의 예`](https://user-images.githubusercontent.com/61646760/150133368-01705af5-5e1d-4e91-aafa-39c85d0b37c5.png)
    - 교수이름, 소속학과만 있는 릴레이션 생성
- 관계 대수 연산식의 활용
  - [`예) 단계1`](https://user-images.githubusercontent.com/61646760/150133664-ce3bf736-a643-4d56-a69b-6db969b9957f.png), [`예) 단계2`](https://user-images.githubusercontent.com/61646760/150133801-5c4f0f8e-4916-446f-8daf-2652176ad8e8.png)
    - 직위가 부교수인 교수의 교수이름을 출력하기
    - **SELECT**를 통해 부교수 레코드만 뽑아 낸 뒤, **PROJECT**를 통해 교수이름 컬럼만 출력
- **집합 연산자(SET operator)**
  - 릴레이션은 집합, 레코드는 집합에 포함된 원소
    - 합집합
    - 교집합
    - 차집합
  - 집합 연산자 사용 조건
    - 릴레이션 R과 S의 차수가 동일 (즉, 두 릴레이션의 차수가 동일)
      - 차수 : 한 릴레이션에 포함된 컬럼의 개수
    - 모든 i에 대해 R의 i번째 컬럼의 도메인과 S의 i번째 컬럼의 도메인이 반드시 동일 (문자에 대한 컬럼인지 숫자에 대한 컬럼인지 도메인이 동일)
- **카테시안 프로덕트 연산(Cartesian Product Operation)**
  ![image](https://user-images.githubusercontent.com/61646760/150135441-48461b14-d821-4ed0-b44f-94766b0576a3.png)
  - 두 릴레이션에 포함된 레코드 간의 모든 조합을 생성하는 이항 연산자  
    `R × S`
  - [`예) 카테시안 프로덕트 연산`](https://user-images.githubusercontent.com/61646760/150135722-600f22ba-25d4-403a-b90c-3d1023d14654.png), [`예) 카테시안 프로덕트 연산 결과`](https://user-images.githubusercontent.com/61646760/150135803-d9bc166e-65a5-49b0-b933-8f3a5ffc4a70.png)
  - 자주 사용하는 중요한 연산
- **조인 연산(JOIN operation)**
  - 두 릴레이션에서 조건을 만족하는 레코드를 결합한 레코드로 구성된 릴레이션을 생성  
    R⋈<sub>AθB</sub>S
    - JOIN 연산은 카테시안 프로덕트 연산과 SELECT 연산의 결합  
      σ<sub>AθB</sub>(R × S)
  - '컴퓨터과학과' 소속의 교수가 강의하는 과목의 과목명과 과목코드는?
    - 교수 릴레이션과 과목 릴레이션이라는 서로 다른 두 개의 릴레이션에서 추출할 필요가 있다.
    - 아래 조인 연산의 예에서 한 단계만 더 수행하면 됨
  - [`조인 연산의 예`](https://user-images.githubusercontent.com/61646760/150163298-865ff02c-4f35-433d-9761-8356083d21bb.png)
    - 과목 릴레이션의 교수번호와 교수 릴레이션의 교수번호가 같은 레코드만 생성
    - 카테시안 프로덕트 & SELECT 연산과 동일 : [`카테시안`](https://user-images.githubusercontent.com/61646760/150162393-be1b6ba2-99e0-4d65-9a2b-8979c0a9148e.png), [`카테시안 결과`](https://user-images.githubusercontent.com/61646760/150162808-61ee9b1c-7a55-493b-892d-9fdfd16cbffa.png), [`SELECT 결과`](https://user-images.githubusercontent.com/61646760/150162946-605b5871-5823-4f48-b334-3210f88acada.png)
- **집계 함수 연산(Aggregate Function Operation)**
  - 집계 함수를 값들의 집합 또는 레코드의 집합에 적용하는 연산  
    ![image](https://user-images.githubusercontent.com/61646760/150164696-98094b6d-b548-4bb4-9650-2b2fe9af0552.png)
    - `x()` : AVG, SUM, MIN, MAX, COUNT 등의 집계 함수
    - `A` : 집계 연산을 적용할 컬럼
  - 레코드 그룹화를 위해 집계 함수 연산자 앞에 그룹화 속성을 기술  
    ![image](https://user-images.githubusercontent.com/61646760/150165684-090f8d57-bb42-42d9-bf1b-dff194a05e76.png)
    - `B` : 그룹의 기준이 되는 컬럼
    - `x()` : 집계 함수
    - `A` : 집계 연산을 적용할 컬럼
    - `R` : 릴레이션
  - [`집계 함수의 예 : count 연산`](https://user-images.githubusercontent.com/61646760/150165061-9a7c9726-00f7-4089-811c-89a316cc18e8.png)
  - [`집계 함수의 예 : 소속학과별 교수 count`](https://user-images.githubusercontent.com/61646760/150166134-83c2b3a6-5cfc-4063-acb8-a5fe0abe9f4e.png)
    - 즉, 그룹별로 수행하는 집계 함수 연산

## 4강. SQL (1)
### 데이터베이스 언어
- **SQL(Structured Query Language)**
  - 관계 대수에 기초하여 RDBMS의 데이터 관리를 위해 설계된 언어
  - 1986년 ANSI, 1987년 ISO에서 표준으로 제정
    - `SQL 86, SQL 89, SQL 92, SQL:1999, SQL:2003, SQL:2008`
    - 상용 DBMS의 특성에 맞게 국제표준을 확장한 독자적 버전이 존재
  - 특징
    - 비절차적(선언형) 언어, 필요한 데이터만 기술
    - 자연어와 매우 유사하고 간단, 명료함
  - 구성
    - **데이터 정의 언어(DDL: Data Definition Language)**
      - 데이터베이스 내의 객체를 생성 및 삭제하고 그 구조를 수정하는 명령어의 집합
      - 데이터가 준수해야 하는 제약 조건을 기술
      - `CREATE`, `ALTER`, `DROP`문 등
    - **데이터 조작 언어 (DML: Data Manipulation Language)**
      - DDL에 의해 정의된 테이블에 데이터를 조작하는 명령어의 집합
      - 데이터에 대한 CRUD(생성, 검색, 삭제, 수정) 명령을 포함
      - `INSERT`, `UPDATE`, `DELETE`, `SELECT`문 등
### 데이터 정의 언어
- **데이터 정의 언어(DDL: Data Definition Language)**
  - 데이터베이스 객체를 생성, 삭제 또는 구조를 수정하는 명령어의 집합
  - 데이터베이스 객체의 종류
    - 데이터 저장 : 테이블(Table), 인덱스(Index), 뷰(View)
    - 데이터 조작 : 트리거(Trigger), 프로시저(Procedure), 함수(function) 등
  - DDL 명령어 종류
    - `CREATE` : 객체 생성
    - `ALTER` : 객체 수정
    - `DROP` : 객체 삭제
  - [DDL의 구문 형식](https://user-images.githubusercontent.com/61646760/150523924-eb4f0662-7006-4010-8477-dbf0786d13f5.png)
    - 테이블 정의 구문 형식
      - 새로운2 차원 형태의 테이블을 생성
        ```
        CREATE TABLE 테이블이름 (
          <컬럼1> <데이터 타입1> [제약조건1]
          <컬럼2> <데이터 타입2> [제약조건2]
          ...
          <컬럼n> <데이터 타입n> [제약조건n]
         [PRIMARY KEY 컬럼명]
         [UNIQUE 컬럼명]
         [FOREIGN KEY 컬럼 REFERENCES 테이블이름(컬럼)]
        )
        ```
      - [`테이블 생성의 예`](https://user-images.githubusercontent.com/61646760/150525505-924d05f9-ea10-427f-839b-eaca190e3d32.png)
    - 테이블 수정 구문 형식
      - 생성된 테이블에 새로운 컬럼을 추가, 수정(이름, 데이터 타입, 제약 조건) 또는 삭제하는 명령
        ```
        ALTER TABLE 테이블이름
          [ADD COLUMN 컬럼 데이터타입 [제약조건]]
          [DROP COLUMN 컬럼이름]
          [CHANGE COLUMN 수정전컬럼 수정후컬럼]
          [MODIFY COLUMN 컬럼 데이터타입]
        ```
      - 위에서부터 컬럼 추가, 컬럼 삭제, 컬럼명 변경, 컬럼 데이터 타입 변경
      - [`테이블 수정의 예) 교수 테이블에 데이터 타입이 INT인 나이 컬럼을 추가하시오`](https://user-images.githubusercontent.com/61646760/150538679-71981ea1-8558-49b0-9269-904e81d87302.png)
        ```
        ALTER TABLE 교수
          ADD COLUMN 나이 INT
        ```
    - 테이블 삭제 구문 형식
      - 존재하는 테이블을 스키마에서 삭제
      - 삭제할 테이블의 모든 데이터가 소실되어 복구가 불가능한 연산이므로 각별한 주의를 요구
        ```
        DROP TABLE 테이블이름
        ```
      - `테이블 삭제의 예) 교수 테이블을 삭제하시오.`
        - `DROP TABLE 교수`
- **스키마(Schema)**
  - 한 조직의 데이터베이스 시스템 운영에 필요한 테이블, 인덱스, 뷰 등의 데이터베이스 객체의 집합
    - 즉, `스키마 = 데이터베이스`
  - 스키마 관리 방법
    - Forward Engineer
    - SQL 에디터
    - 내비게이터 패널
  - 스키마 관리 구문 형식
    - 스키마 생성 : `CREATE SCHEMA 스키마 이름`
    - 스키마 삭제 : `DROP SCHEMA 스키마 이름`
- **데이터 타입(Data Type)**
  - 컬럼이 가질 수 있는 값의 범위, 즉 도메인을 결정
    - 프로그래밍 언어에서 변수를 생성하는 데이터 타입의 사용 목적 및 방법과 매우 유사
  - 기본 데이터 타입
    - 문자 : `CHAR(n)`, `VARCHAR(n)`, `TEXT`
    - 숫자 : `INT`, `FLOAT`, `DOUBLE`, `DECIMAL(m, n)`
    - 날짜/시간 : `DATE`, `TIME`, `DATETIME`, `TIMESTAMP`
  - 정수 데이터 타입
    - `TINYINT`
      - 1바이트 정수, -128~127
      - 나이, 학년 등의 크기가 작은 정수
    - `SMALLINT`
      - 2바이트 정수, -32768~32767
      - 물품 번호, 인원 등 중간 크기의 정수
    - `INT`
      - 4바이트 정수, 약 -20억~20억
      - 물품의 금액, 전화번호 등의 일반 크기의 정수
    - `BIGINT`
      - 8바이트 정수
      - 계좌의 잔고, 천문학적인 크기의 정수
  - 실수 데이터 타입
    - 고정 소수형
      - `DECIMAL(M, N)` : 전체 M자리, 소수점 이하 N자리의 숫자
        - `예)` `DECIMAL(5, 2)`는 -999.99~999.99
      - `NUMERIC` : `DECIMAL`과 동일
    - 부동 소수형
      - `FLOAT` : 4바이트 크기 부동 소수
      - `FLOAT(P)` : 소수점 이하 P개 자리의 부동 소수
      - `DOUBLE` : 8바이트 크기 부동 소수형
  - 날짜/시간 데이터 타입
    - 날짜 데이터 타입
      - `DATE` : `YYYY MM DD` 형식의 시간
      - `YEAR` : `YYYY` 형식의 연도
    - 시간 데이터 타입
      - `TIME` : `HH:MI:SS` 형식의 시간
    - 날짜/시간 데이터 타입
      - `DATETIME` : `YYYY MM DD HH:MI:SS` 형식의 날짜 및 시간
      - `TIMESTAMP` : `DATETIME`과 거의 동일
  - 문자 데이터 타입
    - `CHAR(N)` : 최대 길이가 N인 고정 길이 문자열
    - `VARCHAR(N)` : 최대 길이가 N인 가변 길이 문자열
      - 'DATABASE' 문자열 입력 시, 두 타입의 차이
        ![image](https://user-images.githubusercontent.com/61646760/150534788-3888868c-b519-46b7-9f19-140a96cad294.png)
        - 10칸이 고정이냐, 가변이냐의 차이
          - `VARCHAR`가 유연해서 더 좋다고 생각할 수 있으나, 입력된 값이 변경되면 그 길이에 맞춰 뒤의 값들도 당겨지거나 밀리게 되므로, 자주 수정되는 값의 타입을 `VARCHAR`로 설정하면 악수가 될 수 있다.
        - [CHAR와 VARCHAR](https://user-images.githubusercontent.com/61646760/150535257-35813192-3b1c-4110-a784-bb1ab6aacdbc.png)
    - `TEXT`, `CLOB` : 길이가 최대 2~4GB인 가변 길이 문자열
    - `ENUM` : 유한 개의 문자열 집합 중 하나의 값을 선택
      - 성별 : `ENUM('남', '여')`
      - 혈액형 : `ENUM('A', 'B', 'O', 'AB')`
- **제약 조건(Constraint)**
  - 테이블과 테이블에 존재하는 데이터를 보다 무결하게 관리하기 위한 목적으로 사용
    - DBMS는 테이블 조작 시 테이블에 정의된 제약 조건을 만족시키는지 지속적으로 검사
      - 즉, 제약 조건을 만족하지 않는 데이터를 DBMS에서 거절함
    - DBMS는 적용하려는 제약의 유형에 따라 다양한 제약 조건을 지원
  - 제약 조건의 종류
    - `PRIMARY KEY` : 기본키 지정, `UNIQUE`와 `NOT NULL`특성을 모두 가짐
    - `FOREIGN KEY` : 외래키 지정, 참조 컬럼 정의
    - `NOT NULL` : NULL이 될 수 없는 컬럼에 지정
    - `UNIQUE` : 동일한 컬럼 값을 가질 수 없음을 지정
    - `AUTO_INCREMENT` : 레코드가 추가될 때 자동적으로 속성 값이 1부터 1씩 증가되어 입력
    - `CHECK` : 컬럼 값이 특정 조건 준수 여부 지정
  - [제약 조건 사용의 예1](https://user-images.githubusercontent.com/61646760/150542488-b5e7cc42-09d7-43e0-9882-cb16a1f68470.png)
  - [제약 조건 응용해 보기](https://user-images.githubusercontent.com/61646760/150542672-532c3f48-dde8-4b9e-9678-8941095f0324.png)
    - [제약 조건 응용해 보기 답안](https://user-images.githubusercontent.com/61646760/150542745-27ff76d5-2c6c-4f6a-b7b9-eb1f359a6aa7.png)
