# 알고리즘

### 목차
- [1강. 알고리즘 학습에 앞서서...](#1강-알고리즘-학습에-앞서서)
  - [과목 소개](#과목-소개)
  - [알고리즘의 필요성](#알고리즘의-필요성)
  - [기본 자료구조](#기본-자료구조)
- [2강. 알고리즘의 기초](#2강-알고리즘의-기초)
  - [알고리즘의 개념](#알고리즘의-개념)
  - [알고리즘의 설계](#알고리즘의-설계)
  - [알고리즘의 분석](#알고리즘의-분석)
  - [점근 성능](#점근-성능)
  - [순환 알고리즘의 성능](#순환-알고리즘의-성능)
- [3강. 분할정복 알고리즘 (1)](#3강-분할정복-알고리즘-1)
  - [분할정복 방법의 원리](#분할정복-방법의-원리)
  - [이진 탐색](#이진-탐색)
  - [퀵 정렬](#퀵-정렬)

## 1강. 알고리즘 학습에 앞서서...
### 과목 소개
- 컴퓨터과학(Computer Science)
  - 컴퓨터 + 데이터 + 프로그램 + 알고리즘  
    ![image](https://user-images.githubusercontent.com/61646760/154800227-e8df4355-6bd3-45d4-883d-c8d8f6ef3c3a.png)
  - 알고리즘 과학
    - 컴퓨터과학에서 다루는 모든 내용은 곧 알고리즘과 관련된 이슈를 다루는 것  
      ![image](https://user-images.githubusercontent.com/61646760/154800251-9e802f14-5f31-4661-9cac-67f10f805a97.png)
    - 컴퓨터의 한계? ⇔ (그 문제를 풀 수 있는) 알고리즘의 존재 여부
      - 알고리즘이 존재하면 프로그램을 짜서 문제를 처리할 수 있음
      - 알고리즘이 존재하지 않으면 컴퓨터로 처리가 불가능함
- 학습 목표
  - 잘 알려진 특정 문제를 통해 알고리즘의 설계 및 분석 방법 습득
    - **설계** : 어떤 문제를 푸는 방법을 찾는 것
    - **분석** : 그 방법의 효율성, 성능을 따지는 것
      - 즉 문제를 풀고, 그 방법이 좋은 방법인지 따지는 것
  - 컴퓨터 기반 문제 해결 방법에 대해 체계적으로 생각하는 훈련
    - 어떤 알고리즘이 더 좋은 알고리즘인가?
    - 특정 문제를 풀기 위해서는 어떤 방법으로 설계를 해야 하는가?
  - 주어진 문제에 대한 지적 추상화 능력 및 통찰력 향상
- 교재 구성  
  ![image](https://user-images.githubusercontent.com/61646760/154800542-b7f2798b-1bdc-4f23-9fd6-98b4a3d7b3d7.png)
  - 2장-4장 : 알고리즘 설계의 대표적인 방법들
  - 5장-6장 : 문제 중심의 알고리즘 (정렬과 탐색은 컴퓨터 연산에서 많이 사용되는 연산)
  - 7장 : 이론적, 개념적 논의
  - 8장 : 심화 내용
### 알고리즘의 필요성
- **컴퓨터과학(Computer Science)**
  - 컴퓨터를 이용해서 주어진 문제를 해결하기 위한 학문  
    ![image](https://user-images.githubusercontent.com/61646760/154800902-962968d4-3f5d-4e77-9de4-0932660edb18.png)
- **알고리즘(Algorithm)**
  - 문제 풀이 절차/방법 (문제 해결을 위한 [레시피](https://user-images.githubusercontent.com/61646760/154801014-738df5e9-273a-4ed5-8ac9-255e2e58c09a.png))
    - '효율성'을 따지는 단계적 처리 과정
  - [`예) 최댓값 찾기 알고리즘`](https://user-images.githubusercontent.com/61646760/154801092-a76e76cf-0630-4ae5-b757-1f72590864c1.png)
  - [`예) 쾨니히스베르크의 다리 문제(Seven Bridges of Königsberg)`](https://user-images.githubusercontent.com/61646760/154801247-a37ac96e-9692-4367-834c-1a039a130b1a.png)
    - 오일러 경로(Eulerian path)
    - 그래프의 모든 간선을 오직 한 번씩만 지나는 경로
      - 한붓 그리기 알고리즘
        - 홀수점(한 점에서 연결된 선분이 홀수 개인 점)이 0개 혹은 2개이어야 한다.
        - 홀수점이 2개일 경우 홀수점에서 시작해야 한다.
        - [`예) 한붓 그리기 알고리즘으로 해결 가능?`](https://user-images.githubusercontent.com/61646760/154801486-dbd52ddb-8a78-4b4e-812f-f2d1d8706783.png)
          - 좌측 상단에서부터 가능(홀수점 0개), 가능(홀수점 2개), 불가(홀수점 4개), 불가(홀수점 4개)
          - 마지막이 쾨니히스베르크의 다리 문제이므로, 오일러 경로는 없음
  - [`예) 단일 출발점 최단 경로`](https://user-images.githubusercontent.com/61646760/154801948-c0199823-bc2e-47f3-b296-03cd1156355b.png)
    - 데이크스트라 알고리즘
      - 고속도로를 이용해서 서울에서 목적지까지 가장 짧게(거리, 시간) 가는 방법
### 기본 자료구조
- **자료구조(Data Structure)**
  - 컴퓨터에서 데이터 사이의 논리적 관계를 표현하고 조직화하는 방법
  - 프로그램 = 자료구조 + 알고리즘
    - 자료구조에 대한 고려 없는 효율적인 알고리즘의 선택, 또는 알고리즘에 대한 고려 없는 효율적인 자료구조의 선택은 무의미
  - 기본적인 자료구조 6가지  
    ![image](https://user-images.githubusercontent.com/61646760/154802120-23452e28-ace1-4a0d-9cd5-312b594370ea.png)
- **배열(Array)**
  - 같은 자료형을 갖는 여러 개의 데이터를 하나의 변수로 모아 놓은 데이터의 집합체
  - `예) char A[7]`
    - 문자라는 자료형을 갖는, 최대 7개의 데이터를, 하나의 변수 A로 모아 놓은 데이터의 집합체  
      ![image](https://user-images.githubusercontent.com/61646760/154802398-0e0f229f-6006-40a4-9129-585ac390ce1b.png)
      - 즉, 배열은 `(index, value)`의 쌍의 집합
        - 각각의 원소에 접근하기 위해 index를 사용 (index를 통해 바로 접근 가능)
          - `예) '수'라는 원소에 접근하기 위해 'A[2]' index를 사용`
        - 데이터 삽입/삭제를 위해서는, 삽입/삭제되는 칸 뒤의 모든 원소들이 한 칸씩 이동해야 함
          - 즉, 삽입과 삭제가 있을 시 부가적으로 자료의 이동이 발생함
          - 자료가 많을 경우 부담이 될 수 있음 (삽입/삭제가 빈번한 경우 배열 자료구조는 적절치 않음)
          - 이런 문제를 해결하기 위해 고안된 것이 **'연결 리스트'**
      - 물리적으로 연속적인 공간을 받아서 할당하고, 배열 시작 주소 `a`, 하나의 배열 공간 `α`를 가지므로, 이를 이용해 배열의 원소 주소를 계산할 수 있음
        - `예) A[0]=a, A[1]=a+α …`
      - 배열은 **논리적, 물리적 표현의 순서가 같음**
        - `예) 일 월 수 목 금 토`
- **연결 리스트(Linked List)**
  - 각 노드가 데이터와 포인터를 가지고, 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료구조  
    ![image](https://user-images.githubusercontent.com/61646760/154805405-db6d9290-a233-4b94-b819-4373f15f3cb3.png)
      - 노드는 실제 데이터가 저장되는 **데이터 필드(data field)**, 연결되는 노드 주소를 저장하는 **링크 필드(link field)**로 구성
      - 배열과 달리 연결 리스트는 **논리적 순서와 물리적 순서가 같지 않음**
        - 링크 필드를 이용해서 논리적 순서를 유지
          1. head에서 시작 (75는 메모리 주소)
          2. 75 노드의 데이터 필드에는 `일`이 저장돼 있음
          3. 75 노드의 링크 필드 값은 62이므로, 62 노드로 연결 (`월`)
          4. 62 노드의 링크 필드 값은 50이므로, 50 노드로 연결 (`화`)
      - 각각의 원소에 접근하기 위해 **순차 접근**을 사용함
        - 즉, head에서 출발해서 원하는 데이터가 나올 때까지 링크를 타고 이동
        - 데이터가 많으면 데이터를 찾아가는 데 너무 많은 시간이 소요된다는 단점이 있음
      - 데이터 삽입/삭제를 위해서는 **이전 노드의 링크 필드 값 변경**이 필요
        - `예) '화' 노드를 삭제하려면, '월' 노드의 링크 필드 값을 17로 변경해 줘야 함
        - `예) '금' 노드와 '토' 노드 사이에 새로운 노드를 삽입하려면, '금' 노드의 링크 필드 값을 새로운 노드의 주소 값으로 변경해 줘야 함
          - 연결 리스트는 링크 필드를 조정하면 되니 배열에 비해 삽입/삭제가 간단하다는 장점이 있음
- 배열과 연결 리스트의 종류  
  ![image](https://user-images.githubusercontent.com/61646760/154806980-10a7cc7d-9115-4656-8a84-9fc16298392c.png)
  - 배열
    - **1차원 배열(One-dimensional Array)** : 각각의 원소에 접근하기 위해 1개의 index가 필요
    - **2차원 배열(Two-dimensional Array)** : 각각의 원소에 접근하기 위해 2개의 index가 필요
    - **3차원 배열(Three-dimensional Array)** : 각각의 원소에 접근하기 위해 3개의 index가 필요
  - 연결 리스트
    - **단일 연결 리스트(Singly Linked List)** : 하나의 노드에 링크 필드가 1개 있음 (일방통행)
      - **단일 원형 연결 리스트(Singly Circular Linked List)** : 마지막 노드의 링크 필드가 첫 번째 노드에 연결
    - **이중 연결 리스트(Doubly Linked List)** : 하나의 노드에 링크 필드가 2개 있음 (양방통행)
      - **이중 원형 연결 리스트(Doubly Circular Linked List)** : 마지막 노드의 오른쪽 링크 필드는 첫 번째 노드에, 첫 번째 노드의 왼쪽 링크 필드는 마지막 노드에 연결
- **스택(Stack)**
  - 데이터의 삽입과 삭제가 한쪽 끝에서만 이루어지는 선형 리스트 자료구조  
    ![image](https://user-images.githubusercontent.com/61646760/154827418-5a621b66-7c51-43ed-ac78-244ac292d8a9.png)
  - 스택의 특징
    - **후입선출(LIFO: last in, first out)**
      - `예) A B C D 순으로 데이터가 삽입되고, D C B A 순으로 데이터가 삭제됨`
    - `top`이라는 변수를 써서 삽입/삭제가 이루어지는 곳을 가리킴
    - 데이터 삽입은 `push`, 데이터 삭제는 `pop`이라고 함
  - 스택의 동작  
    ![image](https://user-images.githubusercontent.com/61646760/154827699-373f9446-da17-4357-914a-40bb2ce6645c.png)
    1. 처음에는 `top`이 빈 곳을 가리키고 있으므로, `top`을 한 칸 위로 올려 줌
    2. `push('A')`로 `top` 위치에 A를 넣어 줌
    3. `push('B')`를 할 때 `top`을 한 칸 위로 올려 주고 `top`의 위치에 B를 push함
    4. `pop`을 할 때 `top`이 가리키는 값을 삭제하고, `top`의 위치를 한 칸 밑으로 이동
- **큐(Queue)**
  - 한쪽 끝에서는 데이터의 삽입만 이루어지고, 다른 쪽 끝에서는 데이터의 삭제만 이루어지는 선형 리스트 자료구조  
    ![image](https://user-images.githubusercontent.com/61646760/154827434-bb06c276-44bb-4ff4-95bb-55989a2c1fe2.png)
  - 큐의 특징
    - **선입선출(FIFO: first in, first out)**
      - `예) A B C D E 순으로 데이터가 삽입되고, A B C D E 순으로 데이터가 삭제됨`
    - `front`라는 변수로 삭제가 이루어지는 곳을, `rear`라는 변수로 삽입이 이루어지는 곳을 가리킴
      - 삽입과 삭제를 반복하면, `front`와 `rear`의 위치가 자꾸 오른쪽으로 이동하게 됨
  - 큐의 동작  
    ![image](https://user-images.githubusercontent.com/61646760/154829347-cda6736c-e8ee-4b91-977a-49eac6addbda.png)
    1. 처음에는 `front`와 `rear`가 빈 곳을 가리키고 있음
    2. A를 삽입하려면 `rear`를 오른쪽으로 한 칸 옮기고 그 위치에 A를 삽입
    3. B를 삽입하려면 `rear`를 오른쪽으로 한 칸 옮기고 그 위치에 B를 삽입
    4. A를 삭제하려면 `front`를 오른쪽으로 한 칸 옮기고 그 위치의 A를 삭제
- **트리(Tree)**
  - 하나 이상의 노드(node)로 구성된 유한 집합 T
    - (조건 1) T의 원소 가운데 **단 하나의 루트(root) 노드**가 존재한다. (그림의 A)
    - (조건 2) 루트 노드를 제외한 나머지 노드는 n개(n≥0)의 서로 분리된 부분집합 T<sub>1</sub>, T<sub>2</sub>, …, T<sub>n</sub>으로 나누어지며, 각 T<sub>i</sub>(서브트리)는 트리가 된다.  
      ![image](https://user-images.githubusercontent.com/61646760/154829680-0cecfba1-ec9e-44c9-ab22-d1bebb87d650.png)
        - T<sub>1</sub>, T<sub>2</sub>, T<sub>3</sub>는 T의 서브트리
        - T<sub>1</sub>의 루트 노드(B)를 제외하면, T<sub>11</sub>, T<sub>12</sub>의 서브트리가 생김
          - 이는 트리의 순환적 정의
        - 선형 자료구조인 '배열, 연결 리스트, 스택, 큐'와 달리 비선형 자료구조
  - 주요 용어
    - **차수(degree)**
      - 노드의 차수 : 노드가 가진 서브트리의 개수 (`예) A의 차수는 3, B의 차수는 2, E의 차수는 1, J의 차수는 0`)
      - 트리의 차수 : 트리에 있는 노드의 차수 중 가장 큰 값 (`예) T의 차수는 3`)
    - **단말(terminal) 노드**
      - 차수가 0인 노드 (`예) J, K, L, M, N`)
      - 리프(leaf) 노드라고도 함
    - **비단말(nonterminal) 노드**
      - 단말 노드를 제외한 나머지 노드
    - **부모(parent) 노드, 자식(child) 노드, 형제(sibling) 노드**
      - `예) A의 자식 노드는 B, C, D`
      - `예) B의 부모 노드는 A`
      - `예) B, C, D는 형제 노드` (같은 부모를 갖는 노드) 
    - **조상(ancestor), 후손(descendant)**
      - 선조, 자손이라고도 함
      - `예) F의 조상은 B와 A`
      - `예) D의 후손은 G, H, I, M, N` (해당 노드 아래 달린 모든 노드)
    - **레벨(level)**
      - 루트 노드로부터의 거리 (`예) A는 0이고 B, C, D는 1`)
    - **높이(height)**
      - 맨 마지막 레벨 + 1 (`예) T의 높이는 4`)
      - 깊이(depth)라고도 함
    - **숲(forest)**
      - 루트 노드(A)를 제거하면 세 개의 서브트리 T<sub>1</sub>, T<sub>2</sub>, T<sub>3</sub>가 생기는데, 이 서브트리의 집합을 숲이라고 함
- **이진 트리(Binary Tree)**
  - 각 노드의 차수가 2 이하인 순서 트리  
    ![image](https://user-images.githubusercontent.com/61646760/154830908-d501dfa9-b8b3-43a5-b000-b9bbf8739c90.png)
    - 트리의 차수는 2
      - 즉, 각 노드가 최대 2개의 서브트리를 가짐
    - '순서 트리'라는 것은 각 노드의 위치, 순서가 중요하다는 것
      - `예) A 노드가 B, C를 자식 노드로 갖는 트리는 2개 존재하는데, B와 C의 순서가 다르므로 두 트리는 다름`
    - 노드가 0개인 것도 이진 트리로 취급함
  - 이진 트리의 특성  
    ![image](https://user-images.githubusercontent.com/61646760/154831857-d824b276-16ec-401d-992d-ed1a9beabb44.png)
    - 레벨 i에서 최대 노드의 개수(i≥0) = 2<sup>i</sup>
      - `예) 레벨 0의 최대 노드 개수는 1, 레벨 1의 최대 노드 개수는 2, 레벨 2의 최대 노드 개수는 4`
    - 높이 h인 이진 트리의 최대 노드의 개수(h≥1) = 2<sup>h</sup>-1
      - `예) 트리의 높이가 4이니 최대 노드의 개수는 15개`
    - n<sub>0</sub> = n<sub>2</sub> + 1 (n<sub>0</sub> : 단말 노드의 수, n<sub>2</sub> : 차수가 2인 노드의 수)
      - `예) 단말 노드 8개, n<sub>2</sub> 7개이므로, 8 = 7 + 1
  - 이진 트리의 종류  
    ![image](https://user-images.githubusercontent.com/61646760/154832314-4c1f00ef-cec0-4bbc-bb9c-32884b56a132.png)
    - **포화 이진 트리(Perfect Binary Tree)** : 높이 h인 이진 트리가 최대 노드 개수를 갖는 트리
    - **완전 이진 트리(Complete Binary Tree)** : 마지막 레벨 직전까지는 포화 이진 트리고, 마지막 레벨은 좌측에서부터 노드가 채워진 이진 트리
    - **전 이진 트리(Full Binary Tree)** : 각 노드의 차수가 0이거나 2인 이진 트리 (차수가 1인 노드가 없음)
    - **균형 이진 트리(Balanced Binary Tree)** : 왼쪽 서브트리의 높이와 오른쪽 서브트리의 높이의 차이가 1 이내인 이진 트리 (`예) 왼쪽 서브트리 높이 2, 오른쪽 서브트리 높이 3`)
    - **경사 이진 트리(Skewed Binary Tree)** : 모든 비단말 노드가 한쪽 방향으로만 자식 노드를 갖는 이진 트리
  - 이진 트리의 구현
    - 모든 자료구조는 컴퓨터로 구현할 때 배열, 연결 리스트 중 하나를 사용  
      ![image](https://user-images.githubusercontent.com/61646760/154832700-85589131-e3a7-48bc-96ae-d0d02f9f128b.png)
      - 트리의 높이가 4이므로, 2<sup>4</sup> - 1 = 15개의 최대 노드 개수를 가짐
      - 따라서 총 15칸짜리 배열을 만들고, 위치에 맞게 노드의 값을 채워 넣음
      - 혹은 노드당 데이터 필드(data field)와 좌우 2개의 링크 필드(link field)를 갖는 연결 리스트(linked list)를 사용해 구현할 수도 있음
- **그래프(Graph)**
  - 그래프 G = (V, E)
    - V : 정점(vertex)의 집합
    - E : 간선(edge)의 집합
  - 즉, 그래프는 정점의 집합(V)과 간선의 집합(E)을 모아 놓은 것  
    ![image](https://user-images.githubusercontent.com/61646760/154832899-cae7210d-b740-469c-8a77-ebc358143c2e.png)
    - 트리의 노드가 그래프에서는 정점(vertex)
    - 방향성 유무에 따라 <b>무방향 그래프(undirected graph)</b>와 <b>방향 그래프(directed graph)</b>로 나뉨
    - 무방향 그래프는 `(1, 2) = (2, 1)`로, 방향 그래프는 `<1, 2>`로 표현하는 등, 간선 표현 방법에 차이가 있음
      - `<1, 2> ≠ <2, 1>`
    - 그래프 그림을 정점의 집합(V)과 간선의 집합(E)으로도 표기할 수 있음
      - V(G<sub>2</sub>) = {1, 2, 3, 4, 5}
        - 5개의 정점
      - E(G<sub>2</sub>) = {(1, 2), (1, 3), (2, 4), (3, 5)}
        - 4개의 간선
  - **가중 그래프(Weighted Graph)**
    - 정점(Vertex)를 연결하는 간선(Edge)에 가중치를 부여한 그래프
  - 주요 용어 (교재 18p 참고)
    - 인접(adjacent), 부수(incident)
    - 부분 그래프(subgraph)
    - 경로(path), 경로의 길이(length)
    - 차수(degree)
      - 방향 그래프의 경우 : 진입 차수(in-degree), 진출 차수(out-degree)
    - 단순 경로(simple path), 사이클(cycle), 루프(loop)
    - 연결(connected)
      - 방향 그래프의 경우 : 강력(강하게) 연결(strongly-connected), 약하게 연결(weakly-connected)
  - 그래프의 구현
    - 모든 자료구조는 컴퓨터로 구현할 때 배열, 연결 리스트 중 하나를 사용  
      ![image](https://user-images.githubusercontent.com/61646760/154833369-a5252492-12d5-4b21-a05d-345e1c2ca5db.png)
      - **인접 행렬(adjacency matrix)**
        - 배열을 이용해 그래프를 구현하는 방법
          - 2차원 배열 사용
        - 행 이름, 열 이름이 정점(vertex)이고, 내부에 들어가는 값이 간선(edge)의 유무, 가중치(weight)
          - `예) 1과 2 사이에는 가중치 3이 있음`
          - 정점 사이에 간선이 없으면 `∞`로 표시
          - 가중치가 없는 그래프라면 내부 값은 `0`과 `1`로 간선의 유무만 표시
      - **인접 리스트(adjacency list)**
        - 연결 리스트를 이용해 그래프를 구현하는 방법
          - 각 정점에서 간선이 존재하는 정점들을 연결 리스트로 표현
            - `예) 정점 1에서 2로 가는 정점의 가중치는 3, 정점 1에서 3으로 가는 정점의 가중치는 2, 정점 1에서 4로 가는 정점의 가중치는 4`
          - 가중치가 없는 그래프라면, 가운데 가중치 필드만 제거하면 됨

## 2강. 알고리즘의 기초
### 알고리즘의 개념
- **알고리즘(Algorithm)**
  - 주어진 문제를 풀기 위한 명령어들의 단계적 나열
    - 주어진 문제에 대한 결과를 생성하기 위해 모호하지 않고 간단하며 컴퓨터가 수행 가능한 일련의 유한 개의 명령들을 순서적으로 구성한 것
      - 즉, 아래 4가지 조건을 만족하는 알고리즘이 있다면 해당 문제는 이론적으로 컴퓨터로 풀 수 있음
    - But 결과 도출까지 너무 많은 시간이 소요되면, 알고리즘이 존재해도 실질적으로 풀지 못하는 경우라고 할 수 있음
      - 현실적인 관점에서는 알고리즘이 효율성도 만족할 수 있어야 함
  - 알고리즘의 조건
    - 입출력 : 0개 이상의 외부 입력, 1개 이상의 출력 존재
    - 명확성 : 각 명령은 모호하지 않고 단순 명확해야 함
    - 유한성 : 한정된 수의 단계를 거친 후에는 반드시 종료
    - 유효성 : 모든 명령은 컴퓨터에서 수행 가능해야 함
    - 효율성 : 실용적 관점
  - 알고리즘의 생성 단계  
    ![image](https://user-images.githubusercontent.com/61646760/154985552-9f7f8a6b-8495-4342-a089-46dd5f03ec2b.png)
    1. 설계
    2. 표현/기술
        - [일상 언어/의사코드(pseudo-code)](https://user-images.githubusercontent.com/61646760/154989447-2b0fff5d-5938-4540-a1ba-a0744d65a272.png)
        - [순서도(flow chart)](https://user-images.githubusercontent.com/61646760/154989510-ef0ccd5e-fced-4f87-9ef7-84463760e7e1.png)
    3. 정확성 검증
        - 본 강의에서는 생략
    4. 효율성 분석
        - 초점을 맞춰서 학습
### 알고리즘의 설계
- 최댓값 찾기?
  - 알고리즘① : [값들을 하나씩 모두 비교해 가면서 찾는 방법](https://user-images.githubusercontent.com/61646760/155131784-4532bac3-258f-414e-b780-eeddad30ee98.png)
  - 알고리즘② : [토너먼트 방식](https://user-images.githubusercontent.com/61646760/155131878-20d4efda-d087-4c30-b556-dfd7df78c957.png)
  - 최댓값 찾기 알고리즘①과 알고리즘② 중에서 어떤 것이 더 효율적인가?
    - 비교 횟수가 적을수록 효율적
    - 알고리즘①, ② 모두 7번 비교하므로 효율성이 동일함
- 뒤섞인 카드에서 원하는 카드 찾기  
  ![image](https://user-images.githubusercontent.com/61646760/155135574-684d6007-6c26-468c-8232-b8567f9ca889.png)
  - 앞에서부터 하나씩 뒤집어 봄
    - K가 6번째에 위치하고 있다면 6번만에 K 탐색 완료
  - **순차 탐색(sequential search)**
    - 하나씩 앞에서부터 원하는 데이터와 비교해 가며 찾는 방법
- 순서대로 나열된 카드에서 원하는 카드 찾기  
  ![image](https://user-images.githubusercontent.com/61646760/155136176-2544d746-73ff-4b67-8467-01c6c745e6e5.png)
  - 가운데 카드가 7이면 10은 무조건 그 오른쪽에 있고, 여섯 번째 카드가 J면 10은 무조건 그 왼쪽에 있음
    - 세 번만에 10 탐색 완료
  - **이진 탐색(binary search)**
    - 오름차순으로 정렬된 리스트에서 특정한 값의 위치를 찾는 알고리즘
    - 처음 중간의 값을 임의의 값으로 선택하여, 그 값과 찾고자 하는 값의 크고 작음을 비교하는 방식을 채택함
- 주어지는 문제, 속성, 조건 등이 매우 다양하므로, **모든 문제에 적용할 수 있는 범용적인 설계 기법은 미존재**
  - 가령 순차 탐색과 이진 탐색은 적용될 수 있는 문제의 조건이 다름
    - 순차는 무작위로 섞여 있는 경우, 이진은 순서대로 정렬돼 있는 경우
  - 보편적으로 많은 문제에 적용되는, 대표적인 설계 기법이 3가지 존재함
- 대표적인 알고리즘 설계 기법
  - **분할정복 방법(Divide-and-conquer algorithm)**
    - 교재 2장
  - **동적 프로그래밍 방법(Dynamic programming)**
    - 교재 3장
  - **욕심쟁이 방법(Greedy algorithm)**
    - 교재 4장
### 알고리즘의 분석
- **정확성(Correctness) 분석**
  - 유효한 입력이 주어졌을 때, 유한 시간 내에 정확한 결과를 생성할 수 있는지 분석
  - 다양한 수학적 기법을 사용한 이론적인 증명이 필요
    - 까다로우므로 본 강의에서는 효율성 분석에 초점
- **효율성(Efficiency) 분석**
  - 알고리즘 수행에 필요한 컴퓨터 자원의 양을 측정
    - **공간 복잡도(space complexity)**
      - 메모리 양
        - 정적 공간(컴파일할 당시 필요한 메모리) + 동적 공간(실제 실행하는 중간에 필요한 메모리)
      - 비교적 쉽게 계산될 수 있음
    - **시간 복잡도(time complexity)**
      - 수행 시간
      - 알고리즘 분석은 주로 시간 복잡도를 분석하는 것
- **시간 복잡도(time complexity)**
  - **알고리즘의 단위 연산의 수행 횟수의 합**
  - 구현한 알고리즘을 컴퓨터에서 실행시켜 실제 수행 시간 측정?
    - 컴퓨터 속도, 프로그래밍 언어, 프로그램 작성 방법, 컴파일러의 효율성 등에 종속적
    - 일반성 결여!
  - 시간 복잡도에 영향을 미치는 요인
    - **입력 크기(𝑛)**
      - 입력으로 제공되는 데이터의 크기, 문제가 해결하려는 대상이 되는 개체의 개수
        - `예) 행렬의 크기, 리스트 원소의 수, 그래프의 정점의 수 등`
      - 입력 크기 𝑛이 증가하면 수행 시간도 증가
        - 단순히 수행되는 단위 연산의 개수의 합으로 표현하는 것은 부적절 (데이터 10개 기준? 10,000개 기준?)
          - 입력 크기 𝑛에 대한 함수 <b>𝑓(𝑛)</b>으로 표현
    - 입력 데이터의 상태
      - 시간 복잡도는 입력 데이터의 상태에 종속적 (데이터 상태에 따라 시간이 많이 걸리거나 적게 걸림)  
        ![`예) 출근 소요 시간`](https://user-images.githubusercontent.com/61646760/155148229-b9d02557-19c6-4337-b28e-00861f86074f.png)
        - 평균 수행 시간
          - But 현실적으로 입력 데이터의 모든 경우의 수를 다 따질 수 없음
        - 최선 수행 시간
          - 알고리즘의 수행 시간이 가장 짧음
        - **최악 수행 시간**
          - 알고리즘의 수행 시간이 가장 긺 (수행 시간의 상한)
          - 셋 중 시간 복잡도로 사용
  - 시간 복잡도 구하기1  
    ![시간 복잡도 구하기](https://user-images.githubusercontent.com/61646760/155149183-6f700288-72af-43e6-afa7-bb450766d901.png)
    - 𝑛이 10이면 𝑓(𝑛)은 35
    - 실제로는 점근 성능으로 표기 (Big-O)
  - 즉, 시간 복잡도는 알고리즘에서 수행되는 **단위 연산의 수행 횟수의 합**으로 표현되는데, **입력 크기(𝑛)의 함수**로 표현되고, **최악의 수행 시간**으로 표현됨
### 점근 성능
- **점근 성능(Asymptotic performance)**
  - 입력 크기 𝑛이 무한대로 커짐에 따라 결정되는 알고리즘의 성능
    - 알고리즘 설계 시 데이터를 몇 개로 가정하고 설계할까?
      - 무한대로 가정하고 알고리즘 설계
      - 즉, 점근 성능은 데이터의 개수가 무한히 많을 때의 성능
  - `예) 세 알고리즘의 점근 성능`  
    ![image](https://user-images.githubusercontent.com/61646760/155152033-7d15e770-5e07-46f4-9f43-4f2ba94c8509.png)
    - 데이터가 늘어나면(16개 이상) 𝑓<sub>2</sub>(𝑛)보다 𝑓<sub>1</sub>(𝑛) 알고리즘의 성능이 더 좋아짐
    - 𝑓<sub>3</sub>(𝑛)의 경우, 데이터 𝑛이 커질수록 𝑛<sup>2</sup>이 함수 값에 가장 큰 영향을 미침
      - 최고차항이 가장 중요함
        - 𝑛이 계속 커지면 계수의 영향도 줄어듦
      - 𝑓<sub>1</sub>의 점근 성능은 𝑛, 𝑓<sub>2</sub>의 점근 성능은 𝑛<sup>2</sup>, 𝑓<sub>3</sub>의 점근 성능은 𝑛<sup>2</sup>
  - 점근 성능의 결정 방법
    - 수행 시간의 다항식 함수에서 **최고차항**만을 계수 없이 취해서 표현
      - 데이터 𝑛이 무한대로 커지면, 함수 값에 가장 큰 영향을 미치는 건 최고차항이기 때문
    - (최고차항만으로 표기하므로) 수행 시간의 정확한 값이 아닌 **어림값**
      - 수행 시간의 증가 추세를 파악하는 데 용이
      - 알고리즘의 우열 표현이 용이 (성능 비교 용이)
    - 즉, **알고리즘의 수행 시간을 점근 성능으로 표현**하고 싶다면, 각각의 **단위 연산이 수행된 횟수를 다 계산해 𝑓(𝑛)을** 구한 뒤, 그중에서 **최고차항만을 뽑아서 O(최고차항)으로 표현**하면 끝
- **점근 표기법(Asymptotic notation)**
  - 알고리즘의 시간 복잡도를 나타낼 때 사용하는 표기법
  - 점근적 상한 `𝑓(𝑛) = O(𝑔(𝑛))`, 점근적 하한 `𝑓(𝑛) = Ω(𝑔(𝑛))`, 점근적 상하한 `𝑓(𝑛) = Θ(𝑔(𝑛))` 등을 사용해서 표기함
    - 점근적 상한을 나타내는 Big-O 표기법을 가장 많이 사용함
  - **Big-O 표기법(Big Oh notation)**
    - 𝑛이 𝑛<sub>0</sub>보다 클 때, 알고리즘의 수행 시간 𝑓(𝑛)은 아무리 커도 𝑐·𝑔(𝑛)보다 작음
      - 즉, 𝑓(𝑛)이 아무리 나빠도 𝑐·𝑔(𝑛)보다는 좋음 (점근적 상한)
    - **최악의 수행 시간**을 표기하는 방법  
      ![image](https://user-images.githubusercontent.com/61646760/155180720-c0aebc3b-18d2-429e-b391-5d413dfa50df.png)
  - **Big-Ω 표기법(Big omega notation)**  
    - 𝑛이 𝑛<sub>0</sub>보다 클 때, 알고리즘의 수행 시간 𝑓(𝑛)은 아무리 작아도 𝑐·𝑔(𝑛)보다 큼
      - 즉, 𝑓(𝑛)이 아무리 좋아도 𝑐·𝑔(𝑛)보다는 나쁨 (점근적 하한)
    - **최선의 수행 시간**을 표기하는 방법  
      ![image](https://user-images.githubusercontent.com/61646760/155180793-08400dc7-02ae-4be6-9807-eff5d1b21cbd.png)
  - **Big-Θ 표기법(Big theta notation)**
    - 𝑛이 𝑛<sub>0</sub>보다 클 때, 알고리즘의 수행 시간 𝑓(𝑛)은 𝑐<sub>1</sub>·𝑔(𝑛)보다 크고 𝑐<sub>2</sub>·𝑔(𝑛)보다 작음
      - Big-O와 Big-Ω를 동시에 만족
    - 상한과 하한을 동시에 가짐  
      ![image](https://user-images.githubusercontent.com/61646760/155180864-2f657a9a-a2c5-4bdc-bb26-c853edd7d3a8.png)
  - [`예) 실제 문제 적용`](https://user-images.githubusercontent.com/61646760/155260405-c9bf7064-53dc-4f11-8bab-fd8063917bea.png)
    - 최고차항을 써서 O(최고차항), Ω(최고차항), Θ(최고차항)으로 표기
  - 𝑔(𝑛)의 결정 방법  
    ![image](https://user-images.githubusercontent.com/61646760/155261840-262ae206-88e9-48db-837b-099a0722ce85.png)
    - Big-O에서 𝑔(𝑛)은 𝑓(𝑛)보다 크거나 같음
      - `예)` 𝑓(𝑛)이 O(𝑛<sup>3</sup>)이면 𝑔(𝑛)은 𝑛<sup>3</sup>, 𝑛<sup>4</sup>, 𝑛<sup>5</sup> …
      - 그중에서 가장 낮은 차수의 함수를 선택 (상기 경우 𝑛<sup>3</sup>)
    - Big-Ω에서 𝑔(𝑛)은 𝑓(𝑛)보다 작거나 같음
      - `예)` 𝑓(𝑛)이 Ω(𝑛<sup>3</sup>)이면 𝑔(𝑛)은 𝑛<sup>3</sup>, 𝑛<sup>2</sup>, 𝑛𝑙𝑜𝑔𝑛, 𝑛, 𝑙𝑜𝑔𝑛
      - 그중에서 가장 높은 차수의 함수를 선택 (상기 경우 𝑛<sup>3</sup>)
  - 주요 O-표기 간의 연산 시간의 크기 관계  
    ![image](https://user-images.githubusercontent.com/61646760/155263479-35bf2b19-3d4b-4a83-8080-974df594d296.png)
    - [`예)` 𝑛, 𝑛<sup>2</sup>, 𝑛<sup>3</sup>](https://user-images.githubusercontent.com/61646760/155263560-51388c82-6909-45d2-b0f5-f73e19b2c57c.png)
      - 𝑛 = 10일 때는 각각 10, 100, 1000
      - 𝑛 = 100일 때는 각각 100, 10000, 1000000
        - 알고리즘의 수행 시간이 각각 10배, 100배, 1000배 증가
      - **최고차항의 값이 클수록, 데이터 증가에 따른 수행 시간 증가가 커짐**
        - 데이터(입력 크기)가 늘어도 함수 값(수행 시간)이 조금 느는 것이 좋은 알고리즘
    - Big-O 함수에 따른 연산 시간의 증가 추세 그래프  
      ![image](https://user-images.githubusercontent.com/61646760/155264034-24ce3454-2f18-47d1-ad06-80843e13be32.png)
    - Big-O 함수에 따른 연산 시간의 증가 추세 테이블  
      ![image](https://user-images.githubusercontent.com/61646760/155264644-90bbe9e0-b825-4f0f-8835-499931aced4b.png)
    - [효율적인 알고리즘의 중요성 : 입력 크기에 따른 실제 수행 시간 증가 비율](https://user-images.githubusercontent.com/61646760/155264787-cd3268d0-b4a0-4f20-9086-490856cde16c.png)
      - 2<sup>𝑛</sup> 알고리즘은 사실상 사용이 불가능함
      - 효율적인 알고리즘을 개발하는 것이 중요한 이유임
  - 시간 복잡도 구하기2
    - 알고리즘의 시간 복잡도를 구하려면
      - 알고리즘의 수행 시간 𝑓(𝑛)을 구한 후,
      - 𝑓(𝑛) = O(𝑔(𝑛))을 만족하는 최소 차수의 함수 𝑔(𝑛)을 찾음
    - 실용(현실)적인 접근 방법
      - 알고리즘에 나타난 **루프의 반복 횟수를 조사**하여 시간 복잡도를 취함  
        ![image](https://user-images.githubusercontent.com/61646760/155265231-633330c7-3d19-4864-855c-841cb59c5ff0.png)
        - 좌측 알고리즘의 경우, 위에서부터 1번, 𝑛+1번, 𝑛번, 𝑛번 실행하므로, 총 3𝑛+2 = 𝑓(𝑛) = O(𝑛)
          - 간단히 보면 while문 𝑛번이므로 O(𝑛)
          - 나머지 라인은 계수나 상수에 영향을 주는 것들
        - 우측 알고리즘의 경우, 첫 번째 for문 𝑛번, 두 번째 for문 𝑛번이므로, 총 𝑛<sup>2</sup> = O(𝑛<sup>2</sup>)
      - 계수 없이 최고차항만으로 점근 성능으로 나타내기 때문에 루프의 반복 횟수면 충분함
### 순환 알고리즘의 성능
- **순환(Recursion)**
  - 알고리즘의 수행 과정에서 자기 자신의 알고리즘을 다시 수행하는 형태(= 재귀)  
    ![image](https://user-images.githubusercontent.com/61646760/155265778-f1c70f1c-ca33-4aee-96ba-3e22e7a2d885.png)
    - **순환 알고리즘**은 분할정복 방법(Divide-and-conquer algorithm)을 적용하는 알고리즘으로, 기본적으로 순환적으로 표현됨
    - 순환 알고리즘은 알고리즘 수행 횟수를 계산하기 어려우므로, 점화식으로 표현
      - 데이터 n개를 찾는 데 걸리는 시간 𝑇(𝑛)은, 가운데를 기준으로 좌우 데이터 중 한쪽을 찾는 데 걸리는 시간 𝑇(𝑛/2)에, if문에서 소요되는 상수 시간 O(1)을 더하여 구함
- **점화식(Recurrence relation)**
  - 함수의 한 값이 자신을 포함한 수식으로 다시 표현된 식을 의미하며, 순환 형태의 알고리즘 수행 시간은 점화식으로 표현됨
    - [`예) 점화식의 폐쇄형 구하기`](https://user-images.githubusercontent.com/61646760/155267333-196338ec-8c69-4af4-a435-b723c60c4f27.png)
  - 기본 점화식  
    ![image](https://user-images.githubusercontent.com/61646760/155267501-d4893f92-db82-4112-b999-40c4595abd3b.png)
    - 이 6개를 기억하면 바로바로 적용이 가능
    - 이 중에서 2번(퀵 정렬), 3번(이진 탐색), 6번(합병 정렬, 퀵 정렬)은 반드시 암기해야 함
  - 분할정복 방법으로 나타내는 알고리즘은 순환 알고리즘으로 표현되고, 순환 알고리즘의 성능은 점화식으로 표현되며, 점화식을 통해 알고리즘의 성능을 구할 수 있음
- 정리하기  
  ![image](https://user-images.githubusercontent.com/61646760/155267956-021bfd8a-b969-42bd-8ab8-1e7189ec8e9a.png)

## 3강. 분할정복 알고리즘 (1)
- 학습 목표
  - 분할정복 방법의 원리, 특징, 처리 단계 등을 이해하고 설명할 수 있다.
  - 이진 탐색의 원리, 동작, 성능, 특징을 이해하고 적용할 수 있다.
  - 퀵 정렬의 원리, 동작, 분할 함수, 성능, 특징을 이해하고 적용할 수 있다.
### 분할정복 방법의 원리
- **분할정복 방법(Divide and Conquer)**
  - **순환적으로recursively** 문제를 푸는 **하향식top-down 접근** 방법
    - 주어진 문제의 입력을 더 이상 나눌 수 없을 때까지 두 개 이상의 **작은 문제로 순환적으로 분할**하고,
    - 이렇게 분할된 작은 문제들을 **각각 해결**한 후 이 해들을 **결합해서 원래 문제의 해를 구하는** 방식
  - 특징
    - 분할된 작은 문제는 원래 문제와 동일
      - 단, 입력 크기만 작아짐
    - 분할된 작은 문제는 서로 독립적
      - 순환적 분할 및 결과 통합이 가능
- 분할정복 방법의 처리 단계
  - 각 순환 호출마다 세 단계의 처리 과정을 거침
    - **분할** : 주어진 문제를 여러 개의 작은 문제로 분할한다.
    - **정복** : 작은 문제를 순환적으로 분할. 만약 작은 문제가 더 이상 분할되지 않을 정도로 크기가 충분히 작다면 순환 호출 없이 작은 문제의 해를 구한다.
    - **결합** : 작은 문제에 대해 정복된 해를 결합하여 원래 문제의 해를 구한다. (※ 결합 단계가 없는 문제도 존재)
- 적용 알고리즘의 종류 및 분할 과정  
![image](https://user-images.githubusercontent.com/61646760/181897980-23710170-93b8-4068-ac26-c0ab0f0bd75f.png)
  - 이진 탐색 : 정확히 반으로 쪼개고, 쪼갠 것의 한쪽만 정확히 반으로 쪼개는 식의 분할 수행
  - 합병 정렬 : 정확히 반으로 쪼개고, 쪼갠 것의 양쪽을 정확히 반으로 쪼개는 식의 분할 수행
  - 퀵 정렬 : 크기가 일정하지 않게 반으로 쪼개고, 쪼갠 것의 양쪽을 일정하지 않게 반으로 쪼개는 식의 분할 수행
  - 선택 문제 : 크기가 일정하지 않게 반으로 쪼개고, 쪼갠 것의 한쪽만 일정하지 않게 반으로 쪼개는 식의 분할 수행
### 이진 탐색
- 이진 탐색(binary search)
  - 정렬된 상태의 입력 데이터에 대한 효과적인 탐색 방법
    - 오름차순으로 정렬되었다고 가정
- 탐색 방법  
  ![image](https://user-images.githubusercontent.com/61646760/181902864-deb3fc2b-39d4-437b-b03b-8c52a095cea4.png)
  - 배열의 가운데 원소 `A[mid]`와 탐색키 `x`를 비교  
    1. **탐색키 = 가운데 원소** : 탐색 성공 (인덱스 mid 반환 후 종료)
    2. **탐색키 < 가운데 원소** : 이진 탐색 (원래 크기 ½인 **왼쪽** 부분배열) 순환 호출
    3. **탐색키 > 가운데 원소** : 이진 탐색 (원래 크기 ½인 **오른쪽** 부분배열) 순환 호출
- 분할정복 처리 단계
  - 분할 : 배열의 가운데 원소를 기준으로 왼쪽과 오른쪽 부분배열로 분할. 탐색키와 가운데 원소가 같으면 가운데 원소의 배열 인덱스를 반환/종료
  - 정복 : 탐색키가 가운데 원소보다 작으면 왼쪽 부분배열을 대상으로 이진 탐색을 순환 호출, 크면 오른쪽 부분배열을 대상으로 이진 탐색을 순환 호출
  - 결합 : 필요 없음 (부분배열에 대해서 탐색 결과가 직접 반환)
### 퀵 정렬
