# 알고리즘

### 목차
- [1강. 알고리즘 학습에 앞서서...](#1강-알고리즘-학습에-앞서서)
  - [과목 소개](#과목-소개)
  - [알고리즘의 필요성](#알고리즘의-필요성)
  - [기본 자료구조](#기본-자료구조)

## 1강. 알고리즘 학습에 앞서서...
### 과목 소개
- 컴퓨터과학(Computer Science)
  - 컴퓨터 + 데이터 + 프로그램 + 알고리즘  
    ![image](https://user-images.githubusercontent.com/61646760/154800227-e8df4355-6bd3-45d4-883d-c8d8f6ef3c3a.png)
  - 알고리즘 과학
    - 컴퓨터과학에서 다루는 모든 내용은 곧 알고리즘과 관련된 이슈를 다루는 것  
      ![image](https://user-images.githubusercontent.com/61646760/154800251-9e802f14-5f31-4661-9cac-67f10f805a97.png)
    - 컴퓨터의 한계? ⇔ (그 문제를 풀 수 있는) 알고리즘의 존재 여부
      - 알고리즘이 존재하면 프로그램을 짜서 문제를 처리할 수 있음
      - 알고리즘이 존재하지 않으면 컴퓨터로 처리가 불가능함
- 학습 목표
  - 잘 알려진 특정 문제를 통해 알고리즘의 설계 및 분석 방법 습득
    - **설계** : 어떤 문제를 푸는 방법을 찾는 것
    - **분석** : 그 방법의 효율성, 성능을 따지는 것
      - 즉 문제를 풀고, 그 방법이 좋은 방법인지 따지는 것
  - 컴퓨터 기반 문제 해결 방법에 대해 체계적으로 생각하는 훈련
    - 어떤 알고리즘이 더 좋은 알고리즘인가?
    - 특정 문제를 풀기 위해서는 어떤 방법으로 설계를 해야 하는가?
  - 주어진 문제에 대한 지적 추상화 능력 및 통찰력 향상
- 교재 구성  
  ![image](https://user-images.githubusercontent.com/61646760/154800542-b7f2798b-1bdc-4f23-9fd6-98b4a3d7b3d7.png)
  - 2장-4장 : 알고리즘 설계의 대표적인 방법들
  - 5장-6장 : 문제 중심의 알고리즘 (정렬과 탐색은 컴퓨터 연산에서 많이 사용되는 연산)
  - 7장 : 이론적, 개념적 논의
  - 8장 : 심화 내용
### 알고리즘의 필요성
- **컴퓨터과학(Computer Science)**
  - 컴퓨터를 이용해서 주어진 문제를 해결하기 위한 학문  
    ![image](https://user-images.githubusercontent.com/61646760/154800902-962968d4-3f5d-4e77-9de4-0932660edb18.png)
- **알고리즘(Algorithm)**
  - 문제 풀이 절차/방법 (문제 해결을 위한 [레시피](https://user-images.githubusercontent.com/61646760/154801014-738df5e9-273a-4ed5-8ac9-255e2e58c09a.png))
    - '효율성'을 따지는 단계적 처리 과정
  - [`예) 최댓값 찾기 알고리즘`](https://user-images.githubusercontent.com/61646760/154801092-a76e76cf-0630-4ae5-b757-1f72590864c1.png)
  - [`예) 쾨니히스베르크의 다리 문제(Seven Bridges of Königsberg)`](https://user-images.githubusercontent.com/61646760/154801247-a37ac96e-9692-4367-834c-1a039a130b1a.png)
    - 오일러 경로(Eulerian path)
    - 그래프의 모든 간선을 오직 한 번씩만 지나는 경로
      - 한붓 그리기 알고리즘
        - 홀수점(한 점에서 연결된 선분이 홀수 개인 점)이 0개 혹은 2개이어야 한다.
        - 홀수점이 2개일 경우 홀수점에서 시작해야 한다.
        - [`예) 한붓 그리기 알고리즘으로 해결 가능?`](https://user-images.githubusercontent.com/61646760/154801486-dbd52ddb-8a78-4b4e-812f-f2d1d8706783.png)
          - 좌측 상단에서부터 가능(홀수점 0개), 가능(홀수점 2개), 불가(홀수점 4개), 불가(홀수점 4개)
          - 마지막이 쾨니히스베르크의 다리 문제이므로, 오일러 경로는 없음
  - [`예) 단일 출발점 최단 경로`](https://user-images.githubusercontent.com/61646760/154801948-c0199823-bc2e-47f3-b296-03cd1156355b.png)
    - 데이크스트라 알고리즘
      - 고속도로를 이용해서 서울에서 목적지까지 가장 짧게(거리, 시간) 가는 방법
### 기본 자료구조
- **자료구조(Data Structure)**
  - 컴퓨터에서 데이터 사이의 논리적 관계를 표현하고 조직화하는 방법
  - 프로그램 = 자료구조 + 알고리즘
    - 자료구조에 대한 고려 없는 효율적인 알고리즘의 선택, 또는 알고리즘에 대한 고려 없는 효율적인 자료구조의 선택은 무의미
  - 기본적인 자료구조 6가지  
    ![image](https://user-images.githubusercontent.com/61646760/154802120-23452e28-ace1-4a0d-9cd5-312b594370ea.png)
- **배열(Array)**
  - 같은 자료형을 갖는 여러 개의 데이터를 하나의 변수로 모아 놓은 데이터의 집합체
  - `예) char A[7]`
    - 문자라는 자료형을 갖는, 최대 7개의 데이터를, 하나의 변수 A로 모아 놓은 데이터의 집합체  
      ![image](https://user-images.githubusercontent.com/61646760/154802398-0e0f229f-6006-40a4-9129-585ac390ce1b.png)
      - 즉, 배열은 `(index, value)`의 쌍의 집합
        - 각각의 원소에 접근하기 위해 index를 사용 (index를 통해 바로 접근 가능)
          - `예) '수'라는 원소에 접근하기 위해 'A[2]' index를 사용`
        - 데이터 삽입/삭제를 위해서는, 삽입/삭제되는 칸 뒤의 모든 원소들이 한 칸씩 이동해야 함
          - 즉, 삽입과 삭제가 있을 시 부가적으로 자료의 이동이 발생함
          - 자료가 많을 경우 부담이 될 수 있음 (삽입/삭제가 빈번한 경우 배열 자료구조는 적절치 않음)
          - 이런 문제를 해결하기 위해 고안된 것이 **'연결 리스트'**
      - 물리적으로 연속적인 공간을 받아서 할당하고, 배열 시작 주소 `a`, 하나의 배열 공간 `α`를 가지므로, 이를 이용해 배열의 원소 주소를 계산할 수 있음
        - `예) A[0]=a, A[1]=a+α …`
      - 배열은 **논리적, 물리적 표현의 순서가 같음**
        - `예) 일 월 수 목 금 토`
- **연결 리스트(Linked List)**
  - 각 노드가 데이터와 포인터를 가지고, 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료구조  
    ![image](https://user-images.githubusercontent.com/61646760/154805405-db6d9290-a233-4b94-b819-4373f15f3cb3.png)
      - 노드는 실제 데이터가 저장되는 **데이터 필드(data field)**, 연결되는 노드 주소를 저장하는 **링크 필드(link field)**로 구성
      - 배열과 달리 연결 리스트는 **논리적 순서와 물리적 순서가 같지 않음**
        - 링크 필드를 이용해서 논리적 순서를 유지
          1. head에서 시작 (75는 메모리 주소)
          2. 75 노드의 데이터 필드에는 `일`이 저장돼 있음
          3. 75 노드의 링크 필드 값은 62이므로, 62 노드로 연결 (`월`)
          4. 62 노드의 링크 필드 값은 50이므로, 50 노드로 연결 (`화`)
      - 각각의 원소에 접근하기 위해 **순차 접근**을 사용함
        - 즉, head에서 출발해서 원하는 데이터가 나올 때까지 링크를 타고 이동
        - 데이터가 많으면 데이터를 찾아가는 데 너무 많은 시간이 소요된다는 단점이 있음
      - 데이터 삽입/삭제를 위해서는 **이전 노드의 링크 필드 값 변경**이 필요
        - `예) '화' 노드를 삭제하려면, '월' 노드의 링크 필드 값을 17로 변경해 줘야 함
        - `예) '금' 노드와 '토' 노드 사이에 새로운 노드를 삽입하려면, '금' 노드의 링크 필드 값을 새로운 노드의 주소 값으로 변경해 줘야 함
          - 연결 리스트는 링크 필드를 조정하면 되니 배열에 비해 삽입/삭제가 간단하다는 장점이 있음
- 배열과 연결 리스트의 종류  
  ![image](https://user-images.githubusercontent.com/61646760/154806980-10a7cc7d-9115-4656-8a84-9fc16298392c.png)
  - 배열
    - **1차원 배열(One-dimensional Array)** : 각각의 원소에 접근하기 위해 1개의 index가 필요
    - **2차원 배열(Two-dimensional Array)** : 각각의 원소에 접근하기 위해 2개의 index가 필요
    - **3차원 배열(Three-dimensional Array)** : 각각의 원소에 접근하기 위해 3개의 index가 필요
  - 연결 리스트
    - **단일 연결 리스트(Singly Linked List)** : 하나의 노드에 링크 필드가 1개 있음 (일방통행)
      - **단일 원형 연결 리스트(Singly Circular Linked List)** : 마지막 노드의 링크 필드가 첫 번째 노드에 연결
    - **이중 연결 리스트(Doubly Linked List)** : 하나의 노드에 링크 필드가 2개 있음 (양방통행)
      - **이중 원형 연결 리스트(Doubly Circular Linked List)** : 마지막 노드의 오른쪽 링크 필드는 첫 번째 노드에, 첫 번째 노드의 왼쪽 링크 필드는 마지막 노드에 연결
