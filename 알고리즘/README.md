# 알고리즘

### 목차
- [1강. 알고리즘 학습에 앞서서...](#1강-알고리즘-학습에-앞서서)
  - [과목 소개](#과목-소개)
  - [알고리즘의 필요성](#알고리즘의-필요성)
  - [기본 자료구조](#기본-자료구조)
- [2강. 알고리즘의 기초](#2강-알고리즘의-기초)
  - [알고리즘의 개념](#알고리즘의-개념)
  - [알고리즘의 설계](#알고리즘의-설계)
  - [알고리즘의 분석](#알고리즘의-분석)
  - [점근 성능](#점근-성능)
  - [순환 알고리즘의 성능](#순환-알고리즘의-성능)

## 1강. 알고리즘 학습에 앞서서...
### 과목 소개
- 컴퓨터과학(Computer Science)
  - 컴퓨터 + 데이터 + 프로그램 + 알고리즘  
    ![image](https://user-images.githubusercontent.com/61646760/154800227-e8df4355-6bd3-45d4-883d-c8d8f6ef3c3a.png)
  - 알고리즘 과학
    - 컴퓨터과학에서 다루는 모든 내용은 곧 알고리즘과 관련된 이슈를 다루는 것  
      ![image](https://user-images.githubusercontent.com/61646760/154800251-9e802f14-5f31-4661-9cac-67f10f805a97.png)
    - 컴퓨터의 한계? ⇔ (그 문제를 풀 수 있는) 알고리즘의 존재 여부
      - 알고리즘이 존재하면 프로그램을 짜서 문제를 처리할 수 있음
      - 알고리즘이 존재하지 않으면 컴퓨터로 처리가 불가능함
- 학습 목표
  - 잘 알려진 특정 문제를 통해 알고리즘의 설계 및 분석 방법 습득
    - **설계** : 어떤 문제를 푸는 방법을 찾는 것
    - **분석** : 그 방법의 효율성, 성능을 따지는 것
      - 즉 문제를 풀고, 그 방법이 좋은 방법인지 따지는 것
  - 컴퓨터 기반 문제 해결 방법에 대해 체계적으로 생각하는 훈련
    - 어떤 알고리즘이 더 좋은 알고리즘인가?
    - 특정 문제를 풀기 위해서는 어떤 방법으로 설계를 해야 하는가?
  - 주어진 문제에 대한 지적 추상화 능력 및 통찰력 향상
- 교재 구성  
  ![image](https://user-images.githubusercontent.com/61646760/154800542-b7f2798b-1bdc-4f23-9fd6-98b4a3d7b3d7.png)
  - 2장-4장 : 알고리즘 설계의 대표적인 방법들
  - 5장-6장 : 문제 중심의 알고리즘 (정렬과 탐색은 컴퓨터 연산에서 많이 사용되는 연산)
  - 7장 : 이론적, 개념적 논의
  - 8장 : 심화 내용
### 알고리즘의 필요성
- **컴퓨터과학(Computer Science)**
  - 컴퓨터를 이용해서 주어진 문제를 해결하기 위한 학문  
    ![image](https://user-images.githubusercontent.com/61646760/154800902-962968d4-3f5d-4e77-9de4-0932660edb18.png)
- **알고리즘(Algorithm)**
  - 문제 풀이 절차/방법 (문제 해결을 위한 [레시피](https://user-images.githubusercontent.com/61646760/154801014-738df5e9-273a-4ed5-8ac9-255e2e58c09a.png))
    - '효율성'을 따지는 단계적 처리 과정
  - [`예) 최댓값 찾기 알고리즘`](https://user-images.githubusercontent.com/61646760/154801092-a76e76cf-0630-4ae5-b757-1f72590864c1.png)
  - [`예) 쾨니히스베르크의 다리 문제(Seven Bridges of Königsberg)`](https://user-images.githubusercontent.com/61646760/154801247-a37ac96e-9692-4367-834c-1a039a130b1a.png)
    - 오일러 경로(Eulerian path)
    - 그래프의 모든 간선을 오직 한 번씩만 지나는 경로
      - 한붓 그리기 알고리즘
        - 홀수점(한 점에서 연결된 선분이 홀수 개인 점)이 0개 혹은 2개이어야 한다.
        - 홀수점이 2개일 경우 홀수점에서 시작해야 한다.
        - [`예) 한붓 그리기 알고리즘으로 해결 가능?`](https://user-images.githubusercontent.com/61646760/154801486-dbd52ddb-8a78-4b4e-812f-f2d1d8706783.png)
          - 좌측 상단에서부터 가능(홀수점 0개), 가능(홀수점 2개), 불가(홀수점 4개), 불가(홀수점 4개)
          - 마지막이 쾨니히스베르크의 다리 문제이므로, 오일러 경로는 없음
  - [`예) 단일 출발점 최단 경로`](https://user-images.githubusercontent.com/61646760/154801948-c0199823-bc2e-47f3-b296-03cd1156355b.png)
    - 데이크스트라 알고리즘
      - 고속도로를 이용해서 서울에서 목적지까지 가장 짧게(거리, 시간) 가는 방법
### 기본 자료구조
- **자료구조(Data Structure)**
  - 컴퓨터에서 데이터 사이의 논리적 관계를 표현하고 조직화하는 방법
  - 프로그램 = 자료구조 + 알고리즘
    - 자료구조에 대한 고려 없는 효율적인 알고리즘의 선택, 또는 알고리즘에 대한 고려 없는 효율적인 자료구조의 선택은 무의미
  - 기본적인 자료구조 6가지  
    ![image](https://user-images.githubusercontent.com/61646760/154802120-23452e28-ace1-4a0d-9cd5-312b594370ea.png)
- **배열(Array)**
  - 같은 자료형을 갖는 여러 개의 데이터를 하나의 변수로 모아 놓은 데이터의 집합체
  - `예) char A[7]`
    - 문자라는 자료형을 갖는, 최대 7개의 데이터를, 하나의 변수 A로 모아 놓은 데이터의 집합체  
      ![image](https://user-images.githubusercontent.com/61646760/154802398-0e0f229f-6006-40a4-9129-585ac390ce1b.png)
      - 즉, 배열은 `(index, value)`의 쌍의 집합
        - 각각의 원소에 접근하기 위해 index를 사용 (index를 통해 바로 접근 가능)
          - `예) '수'라는 원소에 접근하기 위해 'A[2]' index를 사용`
        - 데이터 삽입/삭제를 위해서는, 삽입/삭제되는 칸 뒤의 모든 원소들이 한 칸씩 이동해야 함
          - 즉, 삽입과 삭제가 있을 시 부가적으로 자료의 이동이 발생함
          - 자료가 많을 경우 부담이 될 수 있음 (삽입/삭제가 빈번한 경우 배열 자료구조는 적절치 않음)
          - 이런 문제를 해결하기 위해 고안된 것이 **'연결 리스트'**
      - 물리적으로 연속적인 공간을 받아서 할당하고, 배열 시작 주소 `a`, 하나의 배열 공간 `α`를 가지므로, 이를 이용해 배열의 원소 주소를 계산할 수 있음
        - `예) A[0]=a, A[1]=a+α …`
      - 배열은 **논리적, 물리적 표현의 순서가 같음**
        - `예) 일 월 수 목 금 토`
- **연결 리스트(Linked List)**
  - 각 노드가 데이터와 포인터를 가지고, 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료구조  
    ![image](https://user-images.githubusercontent.com/61646760/154805405-db6d9290-a233-4b94-b819-4373f15f3cb3.png)
      - 노드는 실제 데이터가 저장되는 **데이터 필드(data field)**, 연결되는 노드 주소를 저장하는 **링크 필드(link field)**로 구성
      - 배열과 달리 연결 리스트는 **논리적 순서와 물리적 순서가 같지 않음**
        - 링크 필드를 이용해서 논리적 순서를 유지
          1. head에서 시작 (75는 메모리 주소)
          2. 75 노드의 데이터 필드에는 `일`이 저장돼 있음
          3. 75 노드의 링크 필드 값은 62이므로, 62 노드로 연결 (`월`)
          4. 62 노드의 링크 필드 값은 50이므로, 50 노드로 연결 (`화`)
      - 각각의 원소에 접근하기 위해 **순차 접근**을 사용함
        - 즉, head에서 출발해서 원하는 데이터가 나올 때까지 링크를 타고 이동
        - 데이터가 많으면 데이터를 찾아가는 데 너무 많은 시간이 소요된다는 단점이 있음
      - 데이터 삽입/삭제를 위해서는 **이전 노드의 링크 필드 값 변경**이 필요
        - `예) '화' 노드를 삭제하려면, '월' 노드의 링크 필드 값을 17로 변경해 줘야 함
        - `예) '금' 노드와 '토' 노드 사이에 새로운 노드를 삽입하려면, '금' 노드의 링크 필드 값을 새로운 노드의 주소 값으로 변경해 줘야 함
          - 연결 리스트는 링크 필드를 조정하면 되니 배열에 비해 삽입/삭제가 간단하다는 장점이 있음
- 배열과 연결 리스트의 종류  
  ![image](https://user-images.githubusercontent.com/61646760/154806980-10a7cc7d-9115-4656-8a84-9fc16298392c.png)
  - 배열
    - **1차원 배열(One-dimensional Array)** : 각각의 원소에 접근하기 위해 1개의 index가 필요
    - **2차원 배열(Two-dimensional Array)** : 각각의 원소에 접근하기 위해 2개의 index가 필요
    - **3차원 배열(Three-dimensional Array)** : 각각의 원소에 접근하기 위해 3개의 index가 필요
  - 연결 리스트
    - **단일 연결 리스트(Singly Linked List)** : 하나의 노드에 링크 필드가 1개 있음 (일방통행)
      - **단일 원형 연결 리스트(Singly Circular Linked List)** : 마지막 노드의 링크 필드가 첫 번째 노드에 연결
    - **이중 연결 리스트(Doubly Linked List)** : 하나의 노드에 링크 필드가 2개 있음 (양방통행)
      - **이중 원형 연결 리스트(Doubly Circular Linked List)** : 마지막 노드의 오른쪽 링크 필드는 첫 번째 노드에, 첫 번째 노드의 왼쪽 링크 필드는 마지막 노드에 연결
- **스택(Stack)**
  - 데이터의 삽입과 삭제가 한쪽 끝에서만 이루어지는 선형 리스트 자료구조  
    ![image](https://user-images.githubusercontent.com/61646760/154827418-5a621b66-7c51-43ed-ac78-244ac292d8a9.png)
  - 스택의 특징
    - **후입선출(LIFO: last in, first out)**
      - `예) A B C D 순으로 데이터가 삽입되고, D C B A 순으로 데이터가 삭제됨`
    - `top`이라는 변수를 써서 삽입/삭제가 이루어지는 곳을 가리킴
    - 데이터 삽입은 `push`, 데이터 삭제는 `pop`이라고 함
  - 스택의 동작  
    ![image](https://user-images.githubusercontent.com/61646760/154827699-373f9446-da17-4357-914a-40bb2ce6645c.png)
    1. 처음에는 `top`이 빈 곳을 가리키고 있으므로, `top`을 한 칸 위로 올려 줌
    2. `push('A')`로 `top` 위치에 A를 넣어 줌
    3. `push('B')`를 할 때 `top`을 한 칸 위로 올려 주고 `top`의 위치에 B를 push함
    4. `pop`을 할 때 `top`이 가리키는 값을 삭제하고, `top`의 위치를 한 칸 밑으로 이동
- **큐(Queue)**
  - 한쪽 끝에서는 데이터의 삽입만 이루어지고, 다른 쪽 끝에서는 데이터의 삭제만 이루어지는 선형 리스트 자료구조  
    ![image](https://user-images.githubusercontent.com/61646760/154827434-bb06c276-44bb-4ff4-95bb-55989a2c1fe2.png)
  - 큐의 특징
    - **선입선출(FIFO: first in, first out)**
      - `예) A B C D E 순으로 데이터가 삽입되고, A B C D E 순으로 데이터가 삭제됨`
    - `front`라는 변수로 삭제가 이루어지는 곳을, `rear`라는 변수로 삽입이 이루어지는 곳을 가리킴
      - 삽입과 삭제를 반복하면, `front`와 `rear`의 위치가 자꾸 오른쪽으로 이동하게 됨
  - 큐의 동작  
    ![image](https://user-images.githubusercontent.com/61646760/154829347-cda6736c-e8ee-4b91-977a-49eac6addbda.png)
    1. 처음에는 `front`와 `rear`가 빈 곳을 가리키고 있음
    2. A를 삽입하려면 `rear`를 오른쪽으로 한 칸 옮기고 그 위치에 A를 삽입
    3. B를 삽입하려면 `rear`를 오른쪽으로 한 칸 옮기고 그 위치에 B를 삽입
    4. A를 삭제하려면 `front`를 오른쪽으로 한 칸 옮기고 그 위치의 A를 삭제
- **트리(Tree)**
  - 하나 이상의 노드(node)로 구성된 유한 집합 T
    - (조건 1) T의 원소 가운데 **단 하나의 루트(root) 노드**가 존재한다. (그림의 A)
    - (조건 2) 루트 노드를 제외한 나머지 노드는 n개(n≥0)의 서로 분리된 부분집합 T<sub>1</sub>, T<sub>2</sub>, …, T<sub>n</sub>으로 나누어지며, 각 T<sub>i</sub>(서브트리)는 트리가 된다.  
      ![image](https://user-images.githubusercontent.com/61646760/154829680-0cecfba1-ec9e-44c9-ab22-d1bebb87d650.png)
        - T<sub>1</sub>, T<sub>2</sub>, T<sub>3</sub>는 T의 서브트리
        - T<sub>1</sub>의 루트 노드(B)를 제외하면, T<sub>11</sub>, T<sub>12</sub>의 서브트리가 생김
          - 이는 트리의 순환적 정의
        - 선형 자료구조인 '배열, 연결 리스트, 스택, 큐'와 달리 비선형 자료구조
  - 주요 용어
    - **차수(degree)**
      - 노드의 차수 : 노드가 가진 서브트리의 개수 (`예) A의 차수는 3, B의 차수는 2, E의 차수는 1, J의 차수는 0`)
      - 트리의 차수 : 트리에 있는 노드의 차수 중 가장 큰 값 (`예) T의 차수는 3`)
    - **단말(terminal) 노드**
      - 차수가 0인 노드 (`예) J, K, L, M, N`)
      - 리프(leaf) 노드라고도 함
    - **비단말(nonterminal) 노드**
      - 단말 노드를 제외한 나머지 노드
    - **부모(parent) 노드, 자식(child) 노드, 형제(sibling) 노드**
      - `예) A의 자식 노드는 B, C, D`
      - `예) B의 부모 노드는 A`
      - `예) B, C, D는 형제 노드` (같은 부모를 갖는 노드) 
    - **조상(ancestor), 후손(descendant)**
      - 선조, 자손이라고도 함
      - `예) F의 조상은 B와 A`
      - `예) D의 후손은 G, H, I, M, N` (해당 노드 아래 달린 모든 노드)
    - **레벨(level)**
      - 루트 노드로부터의 거리 (`예) A는 0이고 B, C, D는 1`)
    - **높이(height)**
      - 맨 마지막 레벨 + 1 (`예) T의 높이는 4`)
      - 깊이(depth)라고도 함
    - **숲(forest)**
      - 루트 노드(A)를 제거하면 세 개의 서브트리 T<sub>1</sub>, T<sub>2</sub>, T<sub>3</sub>가 생기는데, 이 서브트리의 집합을 숲이라고 함
- **이진 트리(Binary Tree)**
  - 각 노드의 차수가 2 이하인 순서 트리  
    ![image](https://user-images.githubusercontent.com/61646760/154830908-d501dfa9-b8b3-43a5-b000-b9bbf8739c90.png)
    - 트리의 차수는 2
      - 즉, 각 노드가 최대 2개의 서브트리를 가짐
    - '순서 트리'라는 것은 각 노드의 위치, 순서가 중요하다는 것
      - `예) A 노드가 B, C를 자식 노드로 갖는 트리는 2개 존재하는데, B와 C의 순서가 다르므로 두 트리는 다름`
    - 노드가 0개인 것도 이진 트리로 취급함
  - 이진 트리의 특성  
    ![image](https://user-images.githubusercontent.com/61646760/154831857-d824b276-16ec-401d-992d-ed1a9beabb44.png)
    - 레벨 i에서 최대 노드의 개수(i≥0) = 2<sup>i</sup>
      - `예) 레벨 0의 최대 노드 개수는 1, 레벨 1의 최대 노드 개수는 2, 레벨 2의 최대 노드 개수는 4`
    - 높이 h인 이진 트리의 최대 노드의 개수(h≥1) = 2<sup>h</sup>-1
      - `예) 트리의 높이가 4이니 최대 노드의 개수는 15개`
    - n<sub>0</sub> = n<sub>2</sub> + 1 (n<sub>0</sub> : 단말 노드의 수, n<sub>2</sub> : 차수가 2인 노드의 수)
      - `예) 단말 노드 8개, n<sub>2</sub> 7개이므로, 8 = 7 + 1
  - 이진 트리의 종류  
    ![image](https://user-images.githubusercontent.com/61646760/154832314-4c1f00ef-cec0-4bbc-bb9c-32884b56a132.png)
    - **포화 이진 트리(Perfect Binary Tree)** : 높이 h인 이진 트리가 최대 노드 개수를 갖는 트리
    - **완전 이진 트리(Complete Binary Tree)** : 마지막 레벨 직전까지는 포화 이진 트리고, 마지막 레벨은 좌측에서부터 노드가 채워진 이진 트리
    - **전 이진 트리(Full Binary Tree)** : 각 노드의 차수가 0이거나 2인 이진 트리 (차수가 1인 노드가 없음)
    - **균형 이진 트리(Balanced Binary Tree)** : 왼쪽 서브트리의 높이와 오른쪽 서브트리의 높이의 차이가 1 이내인 이진 트리 (`예) 왼쪽 서브트리 높이 2, 오른쪽 서브트리 높이 3`)
    - **경사 이진 트리(Skewed Binary Tree)** : 모든 비단말 노드가 한쪽 방향으로만 자식 노드를 갖는 이진 트리
  - 이진 트리의 구현
    - 모든 자료구조는 컴퓨터로 구현할 때 배열, 연결 리스트 중 하나를 사용  
      ![image](https://user-images.githubusercontent.com/61646760/154832700-85589131-e3a7-48bc-96ae-d0d02f9f128b.png)
      - 트리의 높이가 4이므로, 2<sup>4</sup> - 1 = 15개의 최대 노드 개수를 가짐
      - 따라서 총 15칸짜리 배열을 만들고, 위치에 맞게 노드의 값을 채워 넣음
      - 혹은 노드당 데이터 필드(data field)와 좌우 2개의 링크 필드(link field)를 갖는 연결 리스트(linked list)를 사용해 구현할 수도 있음
- **그래프(Graph)**
  - 그래프 G = (V, E)
    - V : 정점(vertex)의 집합
    - E : 간선(edge)의 집합
  - 즉, 그래프는 정점의 집합(V)과 간선의 집합(E)을 모아 놓은 것  
    ![image](https://user-images.githubusercontent.com/61646760/154832899-cae7210d-b740-469c-8a77-ebc358143c2e.png)
    - 트리의 노드가 그래프에서는 정점(vertex)
    - 방향성 유무에 따라 <b>무방향 그래프(undirected graph)</b>와 <b>방향 그래프(directed graph)</b>로 나뉨
    - 무방향 그래프는 `(1, 2) = (2, 1)`로, 방향 그래프는 `<1, 2>`로 표현하는 등, 간선 표현 방법에 차이가 있음
      - `<1, 2> ≠ <2, 1>`
    - 그래프 그림을 정점의 집합(V)과 간선의 집합(E)으로도 표기할 수 있음
      - V(G<sub>2</sub>) = {1, 2, 3, 4, 5}
        - 5개의 정점
      - E(G<sub>2</sub>) = {(1, 2), (1, 3), (2, 4), (3, 5)}
        - 4개의 간선
  - **가중 그래프(Weighted Graph)**
    - 정점(Vertex)를 연결하는 간선(Edge)에 가중치를 부여한 그래프
  - 주요 용어 (교재 18p 참고)
    - 인접(adjacent), 부수(incident)
    - 부분 그래프(subgraph)
    - 경로(path), 경로의 길이(length)
    - 차수(degree)
      - 방향 그래프의 경우 : 진입 차수(in-degree), 진출 차수(out-degree)
    - 단순 경로(simple path), 사이클(cycle), 루프(loop)
    - 연결(connected)
      - 방향 그래프의 경우 : 강력(강하게) 연결(strongly-connected), 약하게 연결(weakly-connected)
  - 그래프의 구현
    - 모든 자료구조는 컴퓨터로 구현할 때 배열, 연결 리스트 중 하나를 사용  
      ![image](https://user-images.githubusercontent.com/61646760/154833369-a5252492-12d5-4b21-a05d-345e1c2ca5db.png)
      - **인접 행렬(adjacency matrix)**
        - 배열을 이용해 그래프를 구현하는 방법
          - 2차원 배열 사용
        - 행 이름, 열 이름이 정점(vertex)이고, 내부에 들어가는 값이 간선(edge)의 유무, 가중치(weight)
          - `예) 1과 2 사이에는 가중치 3이 있음`
          - 정점 사이에 간선이 없으면 `∞`로 표시
          - 가중치가 없는 그래프라면 내부 값은 `0`과 `1`로 간선의 유무만 표시
      - **인접 리스트(adjacency list)**
        - 연결 리스트를 이용해 그래프를 구현하는 방법
          - 각 정점에서 간선이 존재하는 정점들을 연결 리스트로 표현
            - `예) 정점 1에서 2로 가는 정점의 가중치는 3, 정점 1에서 3으로 가는 정점의 가중치는 2, 정점 1에서 4로 가는 정점의 가중치는 4`
          - 가중치가 없는 그래프라면, 가운데 가중치 필드만 제거하면 됨

## 2강. 알고리즘의 기초
### 알고리즘의 개념
- **알고리즘(Algorithm)**
  - 주어진 문제를 풀기 위한 명령어들의 단계적 나열
    - 주어진 문제에 대한 결과를 생성하기 위해 모호하지 않고 간단하며 컴퓨터가 수행 가능한 일련의 유한 개의 명령들을 순서적으로 구성한 것
      - 즉, 아래 4가지 조건을 만족하는 알고리즘이 있다면 해당 문제는 이론적으로 컴퓨터로 풀 수 있음
    - But 결과 도출까지 너무 많은 시간이 소요되면, 알고리즘이 존재해도 실질적으로 풀지 못하는 경우라고 할 수 있음
      - 현실적인 관점에서는 알고리즘이 효율성도 만족할 수 있어야 함
  - 알고리즘의 조건
    - 입출력 : 0개 이상의 외부 입력, 1개 이상의 출력 존재
    - 명확성 : 각 명령은 모호하지 않고 단순 명확해야 함
    - 유한성 : 한정된 수의 단계를 거친 후에는 반드시 종료
    - 유효성 : 모든 명령은 컴퓨터에서 수행 가능해야 함
    - 효율성 : 실용적 관점
  - 알고리즘의 생성 단계  
    ![image](https://user-images.githubusercontent.com/61646760/154985552-9f7f8a6b-8495-4342-a089-46dd5f03ec2b.png)
    1. 설계
    2. 표현/기술
        - [일상 언어/의사코드(pseudo-code)](https://user-images.githubusercontent.com/61646760/154989447-2b0fff5d-5938-4540-a1ba-a0744d65a272.png)
        - [순서도(flow chart)](https://user-images.githubusercontent.com/61646760/154989510-ef0ccd5e-fced-4f87-9ef7-84463760e7e1.png)
    3. 정확성 검증
        - 본 강의에서는 생략
    4. 효율성 분석
        - 초점을 맞춰서 학습

### 알고리즘의 설계
### 알고리즘의 분석
### 점근 성능
### 순환 알고리즘의 성능
