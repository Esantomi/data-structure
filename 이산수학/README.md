# 이산수학

### 목차
- [1강. 이산수학의 개요](#1강-이산수학의-개요)
  - [1.1 이산수학 - 개관](#11-이산수학---개관)
  - [1.2 모델링과 추상화](12-모델링과-추상화)
  - [1.3 알고리즘 언어](#13-알고리즘-언어)
  - [1.4 이산수학의 응용 분야](#14-이산수학의-응용-분야)
  - [1강 정리](#1강-정리)
- [2강. 논리](#2강-논리)
  - [2.1 명제](#21-명제)
  - [2.2 논리연산](#22-논리연산)
    - [논리적 동치](#논리적-동치)
  - [2.3 술어논리](#23-술어논리)
    - [술어논리와 명제함수](#술어논리와-명제함수)
    - [타당성 검사](#타당성-검사)
  - [2.4 추론](#24-추론)
- [3강. 증명](#3강-증명)
  - [3.1 기본사항](#31-기본사항)
  - [3.2 직접 증명법](#32-직접-증명법)
  - [3.3 수학적 귀납법](#33-수학적-귀납법)
  - [3.4 간접 증명법](#34-간접-증명법)
  - [3.5 다양한 증명 방법](#35-다양한-증명-방법)

## 1강. 이산수학의 개요
### 1.1 이산수학 - 개관
- 수학의 대분류
  - **대수학(algebra)**
    - 일련의 공리들을 만족하는 수학적 구조들의 일반적인 성질을 연구하는 수학의 한 분야
    - `예) 방정식 풀이`
  - **해석학(analysis)**
    - 대수학과 기하학에 대하여, 미분과 적분의 개념을 기초로 함수의 연속성에 관한 성질을 연구하는 수학의 분야
    - `예) 미분, 적분`
  - **기하학(geometry)**
    - 공간에 있는 도형의 성질, 즉 대상들의 치수, 모양, 상대적 위치 등을 연구하는 수학의 한 분야
- 대상인 수학 구조가 연속적인지 여부에 따른 분류  
  ![image](https://user-images.githubusercontent.com/61646760/220309199-30113042-0861-44f6-805e-f6b4fddaa934.png)
  - 연속수학(continuous mathematics)
  - **이산수학(discrete mathematics)** : 이산적인 수학 구조에 대해서 연구하는 학문
### 1.2 모델링과 추상화
- **문제 해결(problem solving)**
  - 도구
    - 수학의 경우 : 정의, 정리
    - 축구의 경우 : 축구공, 축구화, 골대 등
  - 기법
    - 수학의 경우 : 가우스 소거법(일차연립 방정식), 근의 공식(2차, 3차 방정식)
    - 축구의 경우 : 킥, 헤딩, 트래핑 등
  - 방법론
    - 상황에 따라 가장 효과적이고 효율적인 도구와 기법을 선택하는 것
- 문제 해결 과정  
  ![image](https://user-images.githubusercontent.com/61646760/220310263-0bb910e8-5ee8-4523-8202-161fe9937522.png)
  - 수학적 모델링의 문제 해결 방식과 정보 모델링의 문제 해결 방식이 다름
- **추상화(abstraction)**
  - 일정한 인식 목표를 추구하기 위하여 여러 가지 표상(表象)이나 개념(槪念)에서 특정한 특성이나 속성을 빼냄
  - 문제와 관련된 핵심 내용만 남기고 관련 없는 내용을 제거하여 문제를 단순화시키는 과정
    - 예시
      - 문제를 수식으로 추상화하는 것
      - 디지털 논리 회로의 간소화의 경우 : `F(X, Y) = X + XY + X_barY = X + Y`이므로, 두 회로의 기능은 동일
### 1.3 알고리즘 언어
- **알고리즘(algorithm)**
  - 어떠한 문제를 해결하기 위한 여러 동작들의 유한한 모임
    - a set of instructions, sometimes called a procedure or a function, that is used to perform a certain task. [Wikipedia]
    - an explicit step by step procedure for solving the problem. [Dossey , et al.]
- 알고리즘의 표현 방법
  - computer programming language
  - flow chart
  - pseudocode
- **컴퓨터 프로그래밍 언어(computer programming language)**
  - 컴퓨터 작동을 위한 동작을 세밀하게 지시
  - 알고리즘의 핵심요소가 잘 드러나지 않음
  - 중요하지 않은 부차적인 표현에 신경써야 함
  - 통일된 언어가 존재하지 않음
- **순서도(flow chart)**
  - 장점 : 알고리즘의 작동 방식을 도식화함
  - 단점 : 내용이 복잡하거나 프로그램의 크기가 클 경우에 표현하기 어려움
- **의사코드(pseudocode)**
  - 모호한 부분은 프로그래밍 언어의 문법을 채용하여 명확하게 기술
  - 구체적으로 표현할 필요가 없는 부분은 자연어를 통해 설명식으로 기술
  - 알고리즘의 작동방식을 설명하는 용도로만 사용
    - 본 강의에서는 C 언어를 기반으로 하는 의사코드 사용
  - 명령문
    - 할당문
    - 제어문 : 3가지 제어 구조(control structure)
      - **순차문(Sequence)**
      - **조건문(Selection)** : if문, switch문
      - **반복문(Iteration)** : for문, while문, foreach문
### 1.4 이산수학의 응용 분야
![image](https://user-images.githubusercontent.com/61646760/220321832-9588e359-8bbe-43e9-b85f-3d074d9d3f3c.png)
### 1강 정리
- **이산수학**이란 이산적인 수학 구조에 대해서 연구하는 학문
- 성공적인 문제 해결을 위해 **도구**, **기법**, **방법론** 선택이 중요
- **수학적 모델링**이란 수학적 도구로 실생활의 문제를 해결할 수 있도록 추상화하는 과정
- **추상화**란 문제와 관련된 핵심 내용을 남기기 위해 관련 없는 내용을 제거 혹은 단순화 시키는 과정
- **정보 모델링**이란 실생활의 문제를 컴퓨터에서 해결할 수 있는 형태로 추상화 하는 과정
- 알고리즘을 모호하지 않게 표현하기 위해 **컴퓨터 프로그래밍 언어**, **순서도**, **의사코드** 등을 사용

## 2강. 논리
### 2.1 명제
- **명제(Proposition)**
  - 참과 거짓을 구별할 수 있는 문장이나 수학적 식을 명제라고 한다.
    - `𝑥+2=0`은 명제인가? 명제함수! ([2.3 술어논리](#23-술어논리) 참고)
  - 명제의 진릿값(truth value)
    - **참(True)**, **T** : 명제가 타당한 경우
    - **거짓(False)**, **F** : 명제가 타당하지 않은 경우
- 명제의 종류
  - 합성명제
  - 조건명제, 쌍조건명제
  - 항진명제, 모순명제
### 2.2 논리연산
- 실수 연산식과 논리 연산식  
  ![image](https://user-images.githubusercontent.com/61646760/220622404-1d4a075c-4190-4036-b087-2802014bbd95.png)
  - 즉 논리 상수(T, F)와 논리 변수(명제)를 논리 연산자를 통해 논리 연산식으로 만들면 합성 명제가 됨
  - 연산
    - 1항 연산 : 피연산자가 1개인 경우 (e.g. 절댓값)
    - 2항 연산 : 피연산자가 2개인 경우
- **합성명제(compound proposition)**
  - 하나 이상의 명제와 논리 연산자 그리고 괄호로 이루어진 명제
- 논리 연산(logical operation)과 논리 연산자(logical operator)
  - **논리합(disjunction; or, ∨)**
    - `𝒑∨𝒒`
    - 진리표  
      ![image](https://user-images.githubusercontent.com/61646760/220623374-7734252c-70ad-4193-92e5-7bea7fecc037.png)
  - **논리곱(conjunction; and, ∧)**
    - `𝒑∧𝒒`
    - 진리표  
      ![image](https://user-images.githubusercontent.com/61646760/220623646-525c06df-be6a-44b8-bd3f-c98aefbc0546.png)
  - **부정(negation; ∼, ¬)**
    - `∼𝒑`
    - 진리표  
      ![image](https://user-images.githubusercontent.com/61646760/220623939-f51d8488-b69b-4249-92d7-f2d13eda2bb5.png)
  - **배타적 논리합(exclusive or; xor, ⨁)**
    - `𝒑⨁𝒒 ≡ (𝒑∧∼𝒒)∨(∼𝒑∧𝒒)`
    - 진리표  
      ![image](https://user-images.githubusercontent.com/61646760/220624209-7b983015-2080-4059-856e-110dabfcf395.png)
- **조건명제(conditional proposition, →)**
  - 명제 `𝒑`와 `𝒒`가 있을 때, 명제 `𝒑`가 조건의 역할을 수행하고 명제 `𝒒`가 결론의 역할을 수행하는 경우
  - `𝒑→𝒒` (`𝒑⇒𝒒`)
    - `𝑝`는 `𝑞`의 충분조건
    - `𝑞`는 `𝑝`의 필요조건
  - 진리표  
    ![image](https://user-images.githubusercontent.com/61646760/220624585-47dabc73-98a0-4bb5-b405-b929a6a0f8f5.png)
- **쌍조건명제(conditional proposition, ↔)**
  - 명제 `𝒑`와 `𝒒`가 있을 때, 명제 `𝒑`와 `𝒒`가 조건의 역할과 결론의 역할을 동시에 수행하는 경우
  - `𝑝↔𝑞` (`𝑝⇔𝑞`)
    - `(𝑝→𝑞)∧(𝑞→𝑝)`와 동일
    - 참고 : `𝑝↔𝑞 ≡ ∼(𝒑⨁𝒒)`
  - 진리표  
    ![image](https://user-images.githubusercontent.com/61646760/220625027-b5b19f60-7feb-4c23-bcec-09417a223bbc.png)
- **항진명제(tautology)**
  - 합성명제를 구성하는 명제의 진리값과 상관없이 항상 참(T)인 명제
- **모순명제(contradiction)**
  - 합성명제를 구성하는 명제의 진리값과 상관없이 항상 거짓(F)인 명제
#### 논리적 동치
- **논리적 동치(logical equivalence, ≡)**
  - 두 명제 `𝒑`와 `𝒒`가 논리적으로 동등하면 논리적 동치라고 하고, `𝒑≡𝒒`로 표시한다.
    - 논리적으로 동등하다는 말은 두 명제가 항상 동일한 진리값을 가진다는 의미
  - `𝒑↔𝒒` (`𝒑⇔𝒒`, `𝒑=𝒒`, `𝒑≡𝒒`)
- 역, 이, 대우  
  ![image](https://user-images.githubusercontent.com/61646760/220626242-f46a19fc-d8cd-4825-9ae7-d80ed2cce0d2.png)
  - 조건명제 `𝒑→𝒒`에 대해
    - **역(converse)** : `𝒒→𝒑`
    - **이(inverse)** : `∼𝒑→∼𝒒`
    - **대우(contrapositive)** : `∼𝒒→∼𝒑`
- 논리적 동치 법칙
  1. **교환법칙 (commutation law)** : `𝒑∨𝒒 ≡ 𝒒∨𝒑`, `𝒑∧𝒒 ≡ 𝒒∧𝒑`, `𝒑↔𝒒 ≡ 𝒒↔𝒑`
  2. **결합법칙 (associative law)** : `(𝒑∨𝒒)∨𝒓 ≡ 𝒑∨(𝒒∨𝒓)`, `(𝒑∧𝒒)∧𝒓 ≡ 𝒑∧(𝒒∧𝒓)`
  3. **분배법칙 (distributive law)** : `𝒑∨(𝒒∧𝒓) ≡ (𝒑∨𝒒)∧(𝒑∨𝒓)`, `𝒑∧(𝒒∨𝒓) ≡ (𝒑∧𝒒)∨(𝒑∧𝒓)`
  4. **항등법칙 (identity law)** : `𝒑∨F ≡ 𝒑`, `𝒑∧T ≡ 𝒑`
  5. **지배법칙 (domination law)** : `𝒑∨T ≡ T`, `𝒑∧F ≡ F`
  6. **부정법칙 (negation law)** : `∼T ≡ F`, `∼F ≡ T`, `𝒑∨(∼𝒑) ≡ T`, `𝒑∧(∼𝒑) ≡ F`
  7. **이중 부정 법칙 (double negation law)** : `∼(∼𝒑) ≡ 𝒑`
  8. **멱등법칙 (idempotent law)** : `𝒑∨𝒑≡ 𝒑`, `𝒑∧𝒑≡ 𝒑`
  9. **드 모르간 법칙(de Morgan’s law)** : `∼(𝒑∨𝒒) ≡ (∼𝒑)∧(∼𝒒)`, `∼(𝒑∧𝒒) ≡ (∼𝒑)∨(∼𝒒)`
  10. **흡수법칙 (absorption law)** : `𝒑∨(𝒑∧𝒒) ≡ 𝒑`, `𝒑∧(𝒑∨𝒒) ≡ 𝒑`
  11. **함축법칙 (implication law)** : `𝒑→𝒒 ≡ ∼𝒑∨𝒒`
  12. **대우법칙** : `𝒑→𝒒 ≡ ∼𝒒→∼𝒑`
### 2.3 술어논리
#### 술어논리와 명제함수
- 논리(logic)
  - **명제논리(proposition logic)**
    - 명제
  - **술어논리(predicate logic)**
    - 명제함수
- **명제함수(propositional function)**
  - 변수의 값에 의해 함수의 진리값이 결정되는 문장이나 식
  - 변수의 명세
    - 변수의 값을 적시 (e.g. `P(1, 2)`의 진리값은?)
    - 변수의 범위를 제시 (**한정화**: ∀∃)
- **한정화=양화(quantification)**
  - **전체 한정자 = 보편 양화사(universal quantifier, ∀)**
    - 전체 한정자는 “**모든**” 또는 “임의의”를 의미하며, 명제함수 `∀𝒙𝑷(𝒙)`와 같이 사용되었을 경우에는 정의역의 **모든 [임의의] 𝒙**에 대해서 `𝑷(𝒙)`가 참(T)임을 의미한다.
    - `∀`는 Arbitrary에서 따옴
  - **존재 한정자 = 존재 양화사(existential quantifier, ∃)**
    - 존재 한정자는 “**존재한다**”를 의미하며, 명제함수 `∃𝒙𝑷(𝒙)`와 같이 사용되었을 때는 정의역의 **어떤 𝒙**에 대해서 `𝑷(𝒙)`가 참(T)임을 의미한다.
    - `∃`는 Exist에서 따옴
#### 타당성 검사
- **벤 다이어그램(Venn diagram)**
  - 한정자가 사용된 명제함수의 타당성을 직관적으로 검사함
  - `예) “모든 평행사변형은 사각형이다.”`  
    ![image](https://user-images.githubusercontent.com/61646760/220856894-b266e0aa-bd32-484c-8520-794980c6a6b3.png)
### 2.4 추론
- **추론(inference)**
  - 참으로 알려진 명제를 기초로 하여 다른 명제를 유도해 내는 과정을 추론이라고 한다.
  - 결론의 근거를 제공하는 알려진 명제를 '**전제(premise)**'라고 한다.
  - 새로 유도된 명제는 '**결론(conclusion)**'이라고 한다.
- **유효 추론(valid argument)**
  - 유효추론은 **전제를 참(T)이라고 가정**하였을 때 **결론이 항상 참(T)이 되는 추론**
    - `예) ((𝒑→𝒒)∧(𝒒→𝒓)) → (𝒑→𝒓)` (삼단논법)
  - 결론이 거짓이면 **허위 추론(fallacious argument)**
- 추론 규칙
  - 기본적인 추론 규칙은 논리적 동치(항진명제)를 이용함  
    ![image](https://user-images.githubusercontent.com/61646760/220858781-8cbb8166-b26a-4af2-b5d0-886fd4317406.png)
  - 다음 추론은 유효한 추론인가?
    - `𝒑 → 𝒒`, `𝒒`, `∴ 𝒑`
      - 유효하지 않은 추론임!  
        ![image](https://user-images.githubusercontent.com/61646760/220859457-66ad64aa-23d8-42b4-a4b5-fde58ab74157.png)
        - 전제가 모두 참일 때 결론이 T이기도 하고 F이기도 함

## 3강. 증명
### 3.1 기본사항
- **공리(axiom)**
  - 어떤 다른 명제들을 증명하기 위해 **전제로 사용되는 가장 기본적인 가정**으로, **별도의 증명 없이 참으로 이용되는 명제**를 공리라고 한다.
  - 공리의 예
    - 두 점이 주어졌을 때, 두 점을 통과하는 직선을 그릴 수 있다. (유클리드 기하학)
    - 어떤 자연수도, 그 수의 다음 수가 존재한다. (페아노의 공리)
    - 어떤 것도 포함하지 않는 집합이 존재한다. (공리적 집합론)
- **증명(proof)**
  - 증명이란 **특정한 공리들을 가정**하고, **그 가정하에 제안된 명제가 참임을 입증**하는 작업이다.
- **정리(theorem)**
  - **공리로부터 증명된 명제**를 정리라고 한다.
  - **보조정리(lemma)**
    - 정리를 증명하는 과정 중에 사용되는 증명된 명제
    - “a lemma is a proven proposition which is used as a stepping stone to a larger result”
  - **따름정리(corollary)**
    - 정리로부터 쉽게 도출되는 부가적인 명제
    - “a corollary typically follows a theorem”
- 증명 방법
  - 직접 증명법
    - 공리와 정의, 그리고 정리를 논리적으로 직접 연결하여 증명한다.
  - 수학적 귀납법
    - 자연수 𝑛에 대한 명제의 성질을 증명하는 데 유용한 증명 방법
    - 기본단계, 귀납가정, 귀납단계를 이용한다
  - 간접 증명법
    - 증명해야 할 명제를 증명하기 쉬운 형태로 변형하여 증명하는 방법이다.
    - `예) 대우 증명법, 모순 증명법, 반례 증명법, 존재 증명법 등`
  - 그 외
    - 전수 증명법, 조합적 증명법, 컴퓨터 이용 증명법
### 3.2 직접 증명법
- **직접 증명법(direct proof)**
  - 다른 말로 '**연역법(deduction)**'이라고도 함
    - 연역법 : 이미 증명된 하나 또는 둘 이상의 명제를 전제로 하여 새로운 명제를 결론으로 이끌어 내는 것
  - 명제를 변형하지 않고 증명함
  - 주로, 공리와 정의 그리고 이미 증명된 정리를 논리적으로 직접 연결해 증명하는 형식을 따른다.
- **파스칼 삼각형(Pascal’s triangle)**
  - Pascal’s triangle is a triangular array of the binomial coefficients (즉 이항계수들을 삼각형 형태로 만든 것)  
    ![image](https://user-images.githubusercontent.com/61646760/220874046-de2417ab-ba3b-4772-bd56-90f7f5b4ace2.png)
  - **이항계수(binomial coefficient)**
    - 2개로 이루어진 식, 즉 이항식을 이항 정리로 전개했을 때의 각 항의 계수  
      ![image](https://user-images.githubusercontent.com/61646760/220875207-80f8e936-225c-45a4-911d-95a338cd9409.png)
      - (𝒙+𝒚)^5을 이항 정리로 풀면 각 항의 계수는 파스칼 삼각형에서 볼 수 있듯 1, 5, 10, 10, 5, 1이 된다.
  - 정리
    - 𝒏, 𝒌는 양의 정수이고, 𝒌 ≤ 𝒏이라고 가정하면 `𝑪(𝒏+𝟏, 𝒌) = 𝑪(𝒏, 𝒌) + 𝑪(𝒏, 𝒌−𝟏)`이다.
### 3.3 수학적 귀납법
- **수학적 귀납법(mathematical induction)**
  - 모든 자연수가 어떤 주어진 성질을 만족시킨다는 명제를 증명하는 방법의 하나
    - 모든 자연수 𝒏에 대해 명제를 증명하는 데 유용
  - **기초 단계와 귀납 단계가 성립함**을 보임으로써 **모든 자연수 𝒏에 대해 𝑷(𝒏)이 참**임을 보이는 증명 방법
    - `예) 𝒏=1일 때 𝑷가 참(T)이다. 만약 𝒏=𝒌일 때 𝑷가 참(T)이라고 가정하고, 𝒏=𝒌+1일 때도 명제가 성립하는지 증명하면 모든 자연수에 대해 𝑷(𝒏)이 참이 된다.`
- 3단계 과정
  1. **기본 단계(basis)** : 𝒏의 출발점에서 명제가 성립하는가 확인
  2. **귀납 가정(inductive assumption)** : 𝒏 = 𝒌일 때 명제가 성립한다고 가정
  3. **귀납 단계(inductive step)** : 𝒏 = 𝒌+1일 때도 명제가 성립함을 증명
- `예) 𝒏이 자연수일 때 다음을 증명하시오. 1+2+⋯+𝒏 = 𝒏(𝒏+1)/2`
### 3.4 간접 증명법
- **간접 증명법(indirect proof)**
  - 증명해야 할 명제를 증명하기 쉬운 형태로 변형하여 증명하는 방법
  - 대표적인 종류
    - 대우 증명법
    - 모순 증명법
    - 반례 증명법
    - 존재 증명법
- **대우 증명법(proof by transposition)**
  - 𝑷→𝑸 ⇔ ∼𝑸→∼𝑷
    - 명제 𝒑→𝒒와 ∼𝒒→∼𝒑가 동치임(대우가 참이면 주어진 명제도 참)을 이용한 증명법
  - `예) 𝒙^𝟐이 홀수라면 𝒙도 홀수임을 증명하시오.`
- **모순 증명법(proof by contradiction)**
  - 동의어
    - **귀류법(歸謬法)** : 오류로 귀착된다는 것을 보임
    - **배리법(背理法)** : 이치에 어긋나게 된다는 것을 보임
  - 𝑷→𝑸를 증명할 때 ∼𝑷를 가정하면 모순이 발생함을 보임
  - `예) √2가 유리수가 아님을 증명하시오.`
- 한정자=양화사(quantifier)가 포함된 명제의 증명
  - **반례 증명법(proof by counter-example)**
    - 전체 한정자=보편 양화사(∀)가 사용된 명제가 거짓임을 증명
      - 주어진 명제에 모순이 되는 예(반례)를 찾아 증명하는 방법
    - `예) 다음 명제가 거짓임을 증명하시오. “모든 실수 𝒂, 𝒃에 대해 𝒂^𝟐=𝒃^𝟐이면 𝒂=𝒃이다.”`
  - **존재 증명법(existence proof)**
    - 존재 한정자=존재 양화사(∃)가 사용된 명제가 참임을 증명
      - 주어진 명제가 참이 되는 예를 찾아 증명하는 방법
    - **구성적 존재 증명법(constructive proof)**
      - 명제함수 ∃𝒙𝑷(𝒙)를 증명할 때 𝑷(𝒙)를 참으로 만드는 𝒙를 찾거나 찾는 과정을 제시함
      - `예) 𝒂^𝒃이 무리수가 되는 유리수 𝒂, 𝒃가 존재함을 증명하시오.`
    - **비구성적 존재 증명법(non constructive proof)**
      - 명제함수 ∃𝒙𝑷(𝒙)를 증명할 때 𝑷(𝒙)를 참으로 만드는 𝒙를 찾지 않고 우회적으로 명제가 타당함을 보이는 방법
      - `예) 𝒂^𝒃이 유리수가 되는 무리수 𝒂, 𝒃가 존재함을 비구성적인 방법을 사용해 증명하시오.`
### 3.5 다양한 증명 방법
- **전수 증명법(exhaustive proof)**
  - 명제에서 유도될 수 있는 경우의 수가 적을 때 일일이 모든 경우의 수를 조사하는 방법
  - `예) 𝒏이 5 이하의 자연수일 때 (𝒏+𝟏)^𝟐 ≥ 𝟐^𝒏임을 증명하시오.`
- **조합적 증명법(combinatorial proof)**
  - 두 집합의 원소의 개수가 동일함을 증명할 때 사용됨
  - 전단 증명
    - 원소가 𝒏개인 집합 𝑨와 원소가 𝒎개인 집합 𝑩를 찾은 후, 두 집합이 일대일 관계임을 보여 𝒏 = 𝒎임을 증명함
    - 참고
      - **전단사 함수(bijection, bijective function)** : 두 집합 사이를 중복 없이 모두 일대일로 대응시키는 함수
      - **전사 함수(surjection, surjective function)** : 공역=치역인 함수
      - **단사 함수(injection, injective function)** : 일대일 함수. 정의역의 서로 다른 원소를 공역의 서로 다른 원소로 대응시키는 함수
  - 중복 산정 : 동일한 집합의 원소를 두 가지 방법으로 센 다음, 그 결과가 각각 𝒏과 𝒎이라면 𝒏 = 𝒎임을 증명함
- **컴퓨터를 이용한 증명(computer-assisted proof)**
  - 증명하기가 복잡한 경우 컴퓨터의 데이터 처리 능력을 이용하여 증명함
  - `예) 4색 정리`
    - 평면을 유한 개의 부분으로 나누어 각 부분에 색을 칠할 때, 서로 맞닿은 부분을 다른 색으로 칠한다면 네 가지 색으로 충분하다.
