# 이산수학

### 목차
- [1강. 이산수학의 개요](#1강-이산수학의-개요)
  - [1.1 이산수학 - 개관](#11-이산수학---개관)
  - [1.2 모델링과 추상화](12-모델링과-추상화)
  - [1.3 알고리즘 언어](#13-알고리즘-언어)
  - [1.4 이산수학의 응용 분야](#14-이산수학의-응용-분야)
  - [1강 정리](#1강-정리)
- [2강. 논리](#2강-논리)
  - [2.1 명제](#21-명제)
  - [2.2 논리연산](#22-논리연산)
    - [논리적 동치](#논리적-동치)
  - [2.3 술어논리](#23-술어논리)
    - [술어논리와 명제함수](#술어논리와-명제함수)
    - [타당성 검사](#타당성-검사)
  - [2.4 추론](#24-추론)
- [3강. 증명](#3강-증명)
  - [3.1 기본사항](#31-기본사항)
  - [3.2 직접 증명법](#32-직접-증명법)
  - [3.3 수학적 귀납법](#33-수학적-귀납법)
  - [3.4 간접 증명법](#34-간접-증명법)
  - [3.5 다양한 증명 방법](#35-다양한-증명-방법)
- [4강. 집합론](#4강-집합론)
  - [4.1 기본사항](#41-기본사항)
  - [4.2 집합 연산](#42-집합-연산)
  - [4.3 집합의 대수 법칙](#43-집합의-대수-법칙)
    - [4.3.1 집합의 크기에 관한 성질](#431-집합의-크기에-관한-성질)
    - [4.3.2 포함관계 및 항등식](#432-포함관계-및-항등식)
- [5강. 행렬](#5강-행렬)
  - [5.1 기본사항](#51-기본사항)
  - [5.2 행렬의 연산](#52-행렬의-연산)
    - [5.2.1 기본연산](#521-기본연산)
    - [5.2.2 가우스 소거법](#522-가우스-소거법)
    - [5.2.3 가우스 소거법 예제](#523-가우스-소거법-예제)
  - [5.3 행렬의 종류](#53-행렬의-종류)
  - [5.4 부울행렬](#54-부울행렬)
- [6강. 관계](#6강-관계)
  - [6.1 기본사항](#61-기본사항)
  - [6.2 관계의 표현](#62-관계의-표현)
  - [6.3 관계의 성질](#63-관계의-성질)
  - [6.4 관계의 종류](#64-관계의-종류)

## 1강. 이산수학의 개요
### 1.1 이산수학 - 개관
- 수학의 대분류
  - **대수학(algebra)**
    - 일련의 공리들을 만족하는 수학적 구조들의 일반적인 성질을 연구하는 수학의 한 분야
    - `예) 방정식 풀이`
  - **해석학(analysis)**
    - 대수학과 기하학에 대하여, 미분과 적분의 개념을 기초로 함수의 연속성에 관한 성질을 연구하는 수학의 분야
    - `예) 미분, 적분`
  - **기하학(geometry)**
    - 공간에 있는 도형의 성질, 즉 대상들의 치수, 모양, 상대적 위치 등을 연구하는 수학의 한 분야
- 대상인 수학 구조가 연속적인지 여부에 따른 분류  
  ![image](https://user-images.githubusercontent.com/61646760/220309199-30113042-0861-44f6-805e-f6b4fddaa934.png)
  - 연속수학(continuous mathematics)
  - **이산수학(discrete mathematics)** : 이산적인 수학 구조에 대해서 연구하는 학문
### 1.2 모델링과 추상화
- **문제 해결(problem solving)**
  - 도구
    - 수학의 경우 : 정의, 정리
    - 축구의 경우 : 축구공, 축구화, 골대 등
  - 기법
    - 수학의 경우 : 가우스 소거법(일차연립 방정식), 근의 공식(2차, 3차 방정식)
    - 축구의 경우 : 킥, 헤딩, 트래핑 등
  - 방법론
    - 상황에 따라 가장 효과적이고 효율적인 도구와 기법을 선택하는 것
- 문제 해결 과정  
  ![image](https://user-images.githubusercontent.com/61646760/220310263-0bb910e8-5ee8-4523-8202-161fe9937522.png)
  - 수학적 모델링의 문제 해결 방식과 정보 모델링의 문제 해결 방식이 다름
- **추상화(abstraction)**
  - 일정한 인식 목표를 추구하기 위하여 여러 가지 표상(表象)이나 개념(槪念)에서 특정한 특성이나 속성을 빼냄
  - 문제와 관련된 핵심 내용만 남기고 관련 없는 내용을 제거하여 문제를 단순화시키는 과정
    - 예시
      - 문제를 수식으로 추상화하는 것
      - 디지털 논리 회로의 간소화의 경우 : `F(X, Y) = X + XY + X_barY = X + Y`이므로, 두 회로의 기능은 동일
### 1.3 알고리즘 언어
- **알고리즘(algorithm)**
  - 어떠한 문제를 해결하기 위한 여러 동작들의 유한한 모임
    - a set of instructions, sometimes called a procedure or a function, that is used to perform a certain task. [Wikipedia]
    - an explicit step by step procedure for solving the problem. [Dossey , et al.]
- 알고리즘의 표현 방법
  - computer programming language
  - flow chart
  - pseudocode
- **컴퓨터 프로그래밍 언어(computer programming language)**
  - 컴퓨터 작동을 위한 동작을 세밀하게 지시
  - 알고리즘의 핵심요소가 잘 드러나지 않음
  - 중요하지 않은 부차적인 표현에 신경써야 함
  - 통일된 언어가 존재하지 않음
- **순서도(flow chart)**
  - 장점 : 알고리즘의 작동 방식을 도식화함
  - 단점 : 내용이 복잡하거나 프로그램의 크기가 클 경우에 표현하기 어려움
- **의사코드(pseudocode)**
  - 모호한 부분은 프로그래밍 언어의 문법을 채용하여 명확하게 기술
  - 구체적으로 표현할 필요가 없는 부분은 자연어를 통해 설명식으로 기술
  - 알고리즘의 작동방식을 설명하는 용도로만 사용
    - 본 강의에서는 C 언어를 기반으로 하는 의사코드 사용
  - 명령문
    - 할당문
    - 제어문 : 3가지 제어 구조(control structure)
      - **순차문(Sequence)**
      - **조건문(Selection)** : if문, switch문
      - **반복문(Iteration)** : for문, while문, foreach문
### 1.4 이산수학의 응용 분야
![image](https://user-images.githubusercontent.com/61646760/220321832-9588e359-8bbe-43e9-b85f-3d074d9d3f3c.png)
### 1강 정리
- **이산수학**이란 이산적인 수학 구조에 대해서 연구하는 학문
- 성공적인 문제 해결을 위해 **도구**, **기법**, **방법론** 선택이 중요
- **수학적 모델링**이란 수학적 도구로 실생활의 문제를 해결할 수 있도록 추상화하는 과정
- **추상화**란 문제와 관련된 핵심 내용을 남기기 위해 관련 없는 내용을 제거 혹은 단순화 시키는 과정
- **정보 모델링**이란 실생활의 문제를 컴퓨터에서 해결할 수 있는 형태로 추상화 하는 과정
- 알고리즘을 모호하지 않게 표현하기 위해 **컴퓨터 프로그래밍 언어**, **순서도**, **의사코드** 등을 사용

## 2강. 논리
### 2.1 명제
- **명제(Proposition)**
  - 참과 거짓을 구별할 수 있는 문장이나 수학적 식을 명제라고 한다.
    - `𝑥+2=0`은 명제인가? 명제함수! ([2.3 술어논리](#23-술어논리) 참고)
  - 명제의 진릿값(truth value)
    - **참(True)**, **T** : 명제가 타당한 경우
    - **거짓(False)**, **F** : 명제가 타당하지 않은 경우
- 명제의 종류
  - 합성명제
  - 조건명제, 쌍조건명제
  - 항진명제, 모순명제
### 2.2 논리연산
- 실수 연산식과 논리 연산식  
  ![image](https://user-images.githubusercontent.com/61646760/220622404-1d4a075c-4190-4036-b087-2802014bbd95.png)
  - 즉 논리 상수(T, F)와 논리 변수(명제)를 논리 연산자를 통해 논리 연산식으로 만들면 합성 명제가 됨
  - 연산
    - 1항 연산 : 피연산자가 1개인 경우 (e.g. 절댓값)
    - 2항 연산 : 피연산자가 2개인 경우
- **합성명제(compound proposition)**
  - 하나 이상의 명제와 논리 연산자 그리고 괄호로 이루어진 명제
- 논리 연산(logical operation)과 논리 연산자(logical operator)
  - **논리합(disjunction; or, ∨)**
    - `𝒑∨𝒒`
    - 진리표  
      ![image](https://user-images.githubusercontent.com/61646760/220623374-7734252c-70ad-4193-92e5-7bea7fecc037.png)
  - **논리곱(conjunction; and, ∧)**
    - `𝒑∧𝒒`
    - 진리표  
      ![image](https://user-images.githubusercontent.com/61646760/220623646-525c06df-be6a-44b8-bd3f-c98aefbc0546.png)
  - **부정(negation; ∼, ¬)**
    - `∼𝒑`
    - 진리표  
      ![image](https://user-images.githubusercontent.com/61646760/220623939-f51d8488-b69b-4249-92d7-f2d13eda2bb5.png)
  - **배타적 논리합(exclusive or; xor, ⨁)**
    - `𝒑⨁𝒒 ≡ (𝒑∧∼𝒒)∨(∼𝒑∧𝒒)`
    - 진리표  
      ![image](https://user-images.githubusercontent.com/61646760/220624209-7b983015-2080-4059-856e-110dabfcf395.png)
- **조건명제(conditional proposition, →)**
  - 명제 𝒑와 𝒒가 있을 때, 명제 𝒑가 조건의 역할을 수행하고 명제 𝒒가 결론의 역할을 수행하는 경우
  - 𝒑→𝒒 (`𝒑⇒𝒒`)
    - 𝒑는 𝒒의 충분조건
    - 𝒒는 𝒑의 필요조건
  - 진리표  
    ![image](https://user-images.githubusercontent.com/61646760/220624585-47dabc73-98a0-4bb5-b405-b929a6a0f8f5.png)
- **쌍조건명제(conditional proposition, ↔)**
  - 명제 `𝒑`와 `𝒒`가 있을 때, 명제 `𝒑`와 `𝒒`가 조건의 역할과 결론의 역할을 동시에 수행하는 경우
  - 𝒑↔𝒒 (𝒑⇔𝒒)
    - (𝒑→𝒒)∧(𝒒→𝒑)와 동일
    - 참고 : 𝒑↔𝒒 ≡ ∼(𝒑⨁𝒒)
  - 진리표  
    ![image](https://user-images.githubusercontent.com/61646760/220625027-b5b19f60-7feb-4c23-bcec-09417a223bbc.png)
- **항진명제(tautology)**
  - 합성명제를 구성하는 명제의 진리값과 상관없이 항상 참(T)인 명제
- **모순명제(contradiction)**
  - 합성명제를 구성하는 명제의 진리값과 상관없이 항상 거짓(F)인 명제
#### 논리적 동치
- **논리적 동치(logical equivalence, ≡)**
  - 두 명제 𝒑와 𝒒가 논리적으로 동등하면 논리적 동치라고 하고, **𝒑≡𝒒**로 표시한다.
    - 논리적으로 동등하다는 말은 두 명제가 항상 동일한 진리값을 가진다는 의미
  - 𝒑↔𝒒 (𝒑⇔𝒒, 𝒑=𝒒, 𝒑≡𝒒)
- 역, 이, 대우  
  ![image](https://user-images.githubusercontent.com/61646760/220626242-f46a19fc-d8cd-4825-9ae7-d80ed2cce0d2.png)
  - 조건명제 𝒑→𝒒에 대해
    - **역(converse)** : `𝒒→𝒑`
    - **이(inverse)** : `∼𝒑→∼𝒒`
    - **대우(contrapositive)** : `∼𝒒→∼𝒑`
- 논리적 동치 법칙
  1. **교환법칙 (commutation law)** : `𝒑∨𝒒 ≡ 𝒒∨𝒑`, `𝒑∧𝒒 ≡ 𝒒∧𝒑`, `𝒑↔𝒒 ≡ 𝒒↔𝒑`
  2. **결합법칙 (associative law)** : `(𝒑∨𝒒)∨𝒓 ≡ 𝒑∨(𝒒∨𝒓)`, `(𝒑∧𝒒)∧𝒓 ≡ 𝒑∧(𝒒∧𝒓)`
  3. **분배법칙 (distributive law)** : `𝒑∨(𝒒∧𝒓) ≡ (𝒑∨𝒒)∧(𝒑∨𝒓)`, `𝒑∧(𝒒∨𝒓) ≡ (𝒑∧𝒒)∨(𝒑∧𝒓)`
  4. **항등법칙 (identity law)** : `𝒑∨F ≡ 𝒑`, `𝒑∧T ≡ 𝒑`
  5. **지배법칙 (domination law)** : `𝒑∨T ≡ T`, `𝒑∧F ≡ F`
  6. **부정법칙 (negation law)** : `∼T ≡ F`, `∼F ≡ T`, `𝒑∨(∼𝒑) ≡ T`, `𝒑∧(∼𝒑) ≡ F`
  7. **이중 부정 법칙 (double negation law)** : `∼(∼𝒑) ≡ 𝒑`
  8. **멱등법칙 (idempotent law)** : `𝒑∨𝒑≡ 𝒑`, `𝒑∧𝒑≡ 𝒑`
  9. **드 모르간 법칙(de Morgan’s law)** : `∼(𝒑∨𝒒) ≡ (∼𝒑)∧(∼𝒒)`, `∼(𝒑∧𝒒) ≡ (∼𝒑)∨(∼𝒒)`
  10. **흡수법칙 (absorption law)** : `𝒑∨(𝒑∧𝒒) ≡ 𝒑`, `𝒑∧(𝒑∨𝒒) ≡ 𝒑`
  11. **함축법칙 (implication law)** : `𝒑→𝒒 ≡ ∼𝒑∨𝒒`
  12. **대우법칙** : `𝒑→𝒒 ≡ ∼𝒒→∼𝒑`
- [4.3.2 포함관계 및 항등식](#432-포함관계-및-항등식) 참고
### 2.3 술어논리
#### 술어논리와 명제함수
- 논리(logic)
  - **명제논리(proposition logic)**
    - 명제
  - **술어논리(predicate logic)**
    - 명제함수
- **명제함수(propositional function)**
  - 변수의 값에 의해 함수의 진리값이 결정되는 문장이나 식
  - 변수의 명세
    - 변수의 값을 적시 (e.g. `P(1, 2)`의 진리값은?)
    - 변수의 범위를 제시 (**한정화**: ∀∃)
- **한정화=양화(quantification)**
  - **전체 한정자 = 보편 양화사(universal quantifier, ∀)**
    - 전체 한정자는 “**모든**” 또는 “임의의”를 의미하며, 명제함수 `∀𝒙𝑷(𝒙)`와 같이 사용되었을 경우에는 정의역의 **모든 [임의의] 𝒙**에 대해서 `𝑷(𝒙)`가 참(T)임을 의미한다.
    - `∀`는 Arbitrary에서 따옴
  - **존재 한정자 = 존재 양화사(existential quantifier, ∃)**
    - 존재 한정자는 “**존재한다**”를 의미하며, 명제함수 `∃𝒙𝑷(𝒙)`와 같이 사용되었을 때는 정의역의 **어떤 𝒙**에 대해서 `𝑷(𝒙)`가 참(T)임을 의미한다.
    - `∃`는 Exist에서 따옴
#### 타당성 검사
- **벤 다이어그램(Venn diagram)**
  - 한정자가 사용된 명제함수의 타당성을 직관적으로 검사함
  - `예) “모든 평행사변형은 사각형이다.”`  
    ![image](https://user-images.githubusercontent.com/61646760/220856894-b266e0aa-bd32-484c-8520-794980c6a6b3.png)
### 2.4 추론
- **추론(inference)**
  - 참으로 알려진 명제를 기초로 하여 다른 명제를 유도해 내는 과정을 추론이라고 한다.
  - 결론의 근거를 제공하는 알려진 명제를 '**전제(premise)**'라고 한다.
  - 새로 유도된 명제는 '**결론(conclusion)**'이라고 한다.
- **유효 추론(valid argument)**
  - 유효추론은 **전제를 참(T)이라고 가정**하였을 때 **결론이 항상 참(T)이 되는 추론**
    - `예) ((𝒑→𝒒)∧(𝒒→𝒓)) → (𝒑→𝒓)` (삼단논법)
  - 결론이 거짓이면 **허위 추론(fallacious argument)**
- 추론 규칙
  - 기본적인 추론 규칙은 논리적 동치(항진명제)를 이용함  
    ![image](https://user-images.githubusercontent.com/61646760/220858781-8cbb8166-b26a-4af2-b5d0-886fd4317406.png)
  - 다음 추론은 유효한 추론인가?
    - `𝒑 → 𝒒`, `𝒒`, `∴ 𝒑`
      - 유효하지 않은 추론임!  
        ![image](https://user-images.githubusercontent.com/61646760/220859457-66ad64aa-23d8-42b4-a4b5-fde58ab74157.png)
        - 전제가 모두 참일 때 결론이 T이기도 하고 F이기도 함

## 3강. 증명
### 3.1 기본사항
- **공리(axiom)**
  - 어떤 다른 명제들을 증명하기 위해 **전제로 사용되는 가장 기본적인 가정**으로, **별도의 증명 없이 참으로 이용되는 명제**를 공리라고 한다.
  - 공리의 예
    - 두 점이 주어졌을 때, 두 점을 통과하는 직선을 그릴 수 있다. (유클리드 기하학)
    - 어떤 자연수도, 그 수의 다음 수가 존재한다. (페아노의 공리)
    - 어떤 것도 포함하지 않는 집합이 존재한다. (공리적 집합론)
- **증명(proof)**
  - 증명이란 **특정한 공리들을 가정**하고, **그 가정하에 제안된 명제가 참임을 입증**하는 작업이다.
- **정리(theorem)**
  - **공리로부터 증명된 명제**를 정리라고 한다.
  - **보조정리(lemma)**
    - 정리를 증명하는 과정 중에 사용되는 증명된 명제
    - “a lemma is a proven proposition which is used as a stepping stone to a larger result”
  - **따름정리(corollary)**
    - 정리로부터 쉽게 도출되는 부가적인 명제
    - “a corollary typically follows a theorem”
- 증명 방법
  - 직접 증명법
    - 공리와 정의, 그리고 정리를 논리적으로 직접 연결하여 증명한다.
  - 수학적 귀납법
    - 자연수 𝑛에 대한 명제의 성질을 증명하는 데 유용한 증명 방법
    - 기본단계, 귀납가정, 귀납단계를 이용한다
  - 간접 증명법
    - 증명해야 할 명제를 증명하기 쉬운 형태로 변형하여 증명하는 방법이다.
    - `예) 대우 증명법, 모순 증명법, 반례 증명법, 존재 증명법 등`
  - 그 외
    - 전수 증명법, 조합적 증명법, 컴퓨터 이용 증명법
### 3.2 직접 증명법
- **직접 증명법(direct proof)**
  - 다른 말로 '**연역법(deduction)**'이라고도 함
    - 연역법 : 이미 증명된 하나 또는 둘 이상의 명제를 전제로 하여 새로운 명제를 결론으로 이끌어 내는 것
  - 명제를 변형하지 않고 증명함
  - 주로, 공리와 정의 그리고 이미 증명된 정리를 논리적으로 직접 연결해 증명하는 형식을 따른다.
- **파스칼 삼각형(Pascal’s triangle)**
  - Pascal’s triangle is a triangular array of the binomial coefficients (즉 이항계수들을 삼각형 형태로 만든 것)  
    ![image](https://user-images.githubusercontent.com/61646760/220874046-de2417ab-ba3b-4772-bd56-90f7f5b4ace2.png)
  - **이항계수(binomial coefficient)**
    - 2개로 이루어진 식, 즉 이항식을 이항 정리로 전개했을 때의 각 항의 계수  
      ![image](https://user-images.githubusercontent.com/61646760/220875207-80f8e936-225c-45a4-911d-95a338cd9409.png)
      - (𝒙+𝒚)^5을 이항 정리로 풀면 각 항의 계수는 파스칼 삼각형에서 볼 수 있듯 1, 5, 10, 10, 5, 1이 된다.
  - 정리
    - 𝒏, 𝒌는 양의 정수이고, 𝒌 ≤ 𝒏이라고 가정하면 `𝑪(𝒏+𝟏, 𝒌) = 𝑪(𝒏, 𝒌) + 𝑪(𝒏, 𝒌−𝟏)`이다.
### 3.3 수학적 귀납법
- **수학적 귀납법(mathematical induction)**
  - 모든 자연수가 어떤 주어진 성질을 만족시킨다는 명제를 증명하는 방법의 하나
    - 모든 자연수 𝒏에 대해 명제를 증명하는 데 유용
  - **기초 단계와 귀납 단계가 성립함**을 보임으로써 **모든 자연수 𝒏에 대해 𝑷(𝒏)이 참**임을 보이는 증명 방법
    - `예) 𝒏=1일 때 𝑷가 참(T)이다. 만약 𝒏=𝒌일 때 𝑷가 참(T)이라고 가정하고, 𝒏=𝒌+1일 때도 명제가 성립하는지 증명하면 모든 자연수에 대해 𝑷(𝒏)이 참이 된다.`
- 3단계 과정
  1. **기본 단계(basis)** : 𝒏의 출발점에서 명제가 성립하는가 확인
  2. **귀납 가정(inductive assumption)** : 𝒏 = 𝒌일 때 명제가 성립한다고 가정
  3. **귀납 단계(inductive step)** : 𝒏 = 𝒌+1일 때도 명제가 성립함을 증명
- `예) 𝒏이 자연수일 때 다음을 증명하시오. 1+2+⋯+𝒏 = 𝒏(𝒏+1)/2`
### 3.4 간접 증명법
- **간접 증명법(indirect proof)**
  - 증명해야 할 명제를 증명하기 쉬운 형태로 변형하여 증명하는 방법
  - 대표적인 종류
    - 대우 증명법
    - 모순 증명법
    - 반례 증명법
    - 존재 증명법
- **대우 증명법(proof by transposition)**
  - 𝑷→𝑸 ⇔ ∼𝑸→∼𝑷
    - 명제 𝒑→𝒒와 ∼𝒒→∼𝒑가 동치임(대우가 참이면 주어진 명제도 참)을 이용한 증명법
  - `예) 𝒙^𝟐이 홀수라면 𝒙도 홀수임을 증명하시오.`
- **모순 증명법(proof by contradiction)**
  - 동의어
    - **귀류법(歸謬法)** : 오류로 귀착된다는 것을 보임
    - **배리법(背理法)** : 이치에 어긋나게 된다는 것을 보임
  - 𝑷→𝑸를 증명할 때 ∼𝑷를 가정하면 모순이 발생함을 보임
  - `예) √2가 유리수가 아님을 증명하시오.`
- 한정자=양화사(quantifier)가 포함된 명제의 증명
  - **반례 증명법(proof by counter-example)**
    - 전체 한정자=보편 양화사(∀)가 사용된 명제가 거짓임을 증명
      - 주어진 명제에 모순이 되는 예(반례)를 찾아 증명하는 방법
    - `예) 다음 명제가 거짓임을 증명하시오. “모든 실수 𝒂, 𝒃에 대해 𝒂^𝟐=𝒃^𝟐이면 𝒂=𝒃이다.”`
  - **존재 증명법(existence proof)**
    - 존재 한정자=존재 양화사(∃)가 사용된 명제가 참임을 증명
      - 주어진 명제가 참이 되는 예를 찾아 증명하는 방법
    - **구성적 존재 증명법(constructive proof)**
      - 명제함수 ∃𝒙𝑷(𝒙)를 증명할 때 𝑷(𝒙)를 참으로 만드는 𝒙를 찾거나 찾는 과정을 제시함
      - `예) 𝒂^𝒃이 무리수가 되는 유리수 𝒂, 𝒃가 존재함을 증명하시오.`
    - **비구성적 존재 증명법(non constructive proof)**
      - 명제함수 ∃𝒙𝑷(𝒙)를 증명할 때 𝑷(𝒙)를 참으로 만드는 𝒙를 찾지 않고 우회적으로 명제가 타당함을 보이는 방법
      - `예) 𝒂^𝒃이 유리수가 되는 무리수 𝒂, 𝒃가 존재함을 비구성적인 방법을 사용해 증명하시오.`
### 3.5 다양한 증명 방법
- **전수 증명법(exhaustive proof)**
  - 명제에서 유도될 수 있는 경우의 수가 적을 때 일일이 모든 경우의 수를 조사하는 방법
  - `예) 𝒏이 5 이하의 자연수일 때 (𝒏+𝟏)^𝟐 ≥ 𝟐^𝒏임을 증명하시오.`
- **조합적 증명법(combinatorial proof)**
  - 두 집합의 원소의 개수가 동일함을 증명할 때 사용됨
  - 전단 증명
    - 원소가 𝒏개인 집합 𝑨와 원소가 𝒎개인 집합 𝑩를 찾은 후, 두 집합이 일대일 관계임을 보여 𝒏 = 𝒎임을 증명함
    - 참고
      - **전단사 함수(bijection, bijective function)** : 두 집합 사이를 중복 없이 모두 일대일로 대응시키는 함수
      - **전사 함수(surjection, surjective function)** : 공역=치역인 함수
      - **단사 함수(injection, injective function)** : 일대일 함수. 정의역의 서로 다른 원소를 공역의 서로 다른 원소로 대응시키는 함수
  - 중복 산정 : 동일한 집합의 원소를 두 가지 방법으로 센 다음, 그 결과가 각각 𝒏과 𝒎이라면 𝒏 = 𝒎임을 증명함
- **컴퓨터를 이용한 증명(computer-assisted proof)**
  - 증명하기가 복잡한 경우 컴퓨터의 데이터 처리 능력을 이용하여 증명함
  - `예) 4색 정리`
    - 평면을 유한 개의 부분으로 나누어 각 부분에 색을 칠할 때, 서로 맞닿은 부분을 다른 색으로 칠한다면 네 가지 색으로 충분하다.

## 4강. 집합론
### 4.1 기본사항
- 논리학과 집합론  
  ![image](https://user-images.githubusercontent.com/61646760/221367212-874e87f0-5dda-448e-9243-d02ba6f2d8a0.png)
  - `𝑨∪𝑩` : 논리합(∨)을 합집합(∪)으로 표현
  - `𝑨∩𝑩` : 논리곱(∧)을 교집합(∩)으로 표현
    - `𝑨` : 𝒑(𝒙)를 만족하는 𝒙를 모두 모은 집합
    - `𝑩` : 𝒈(𝒙)를 만족하는 𝒙를 모두 모은 집합
  - 논리학과 집합론을 비교해 가며 공부해야 함
- 집합과 원소
  - **무정의 용어=근본 원리(primitive notion)**
    - 정의 없이 사용하는 용어
    - a concept that is not defined in terms of previously-defined concepts [wikipedia]
      - 한 용어를 설명하기 위해 다른 용어를 설명하고 거기에 사용된 다른 용어를 사용하게 되면 계속 순환에 빠지게 되므로 정의 없이 사용하는 것
    - 직관적으로 이해할 수 있으나 다른 용어로 정의하기 힘든 대상을 표현하기 위해 사용됨
    - `예) 공리적 집합론의 '집합'`
  - Georg Cantor의 집합
    - “우리의 직관이나 사고로부터 한정적이고 분리된 객체들의 전체 M에서의 수집”
- 집합의 표시법
  - 𝑺 : 하나의 집합
    - 𝒂∈𝑺 : 𝒂가 𝑺의 원소
    - 𝒃∉𝑺 : 𝒃가 𝑺의 원소가 아님
  - {𝑺} : 집합은 중괄호 {}로 표시
    - 원소 나열법 : `𝑺 = {1, 2, 3}`
    - 조건 나열법 : `𝑺 = {𝒙｜𝟎<𝒙<𝟒인 자연수}`
  - ｜𝑺｜ : 집합의 크기
    - `예) ｜𝑺｜=3`
  - 집합을 원소로 갖는 집합도 존재
    - `예) {{𝒂} , 𝒃}`
  - 전체 집합 기호들
    - ℕ : 모든 자연수의 집합
    - ℤ : 모든 정수의 집합
    - ℚ : 모든 유리수의 집합
    - ℝ : 모든 실수의 집합
    - ℂ : 모든 복소수의 집합
- **부분집합(subset)**
  - 𝑨의 모든 원소가 𝑩의 원소이면 𝑨는 𝑩의 부분집합
    - 𝑨⊆𝑩 또는 𝐀⊂𝑩로 표기
  - 즉, 𝑨⊆𝑩 ⇔ ∀𝒙 (𝒙∈𝑨 → 𝒙∈𝑩)
    - 모든 𝒙에 대해 𝑨에 속하면 𝑩에도 속함
  - **진부분집합(proper subset)**
    - 𝑨는 𝑩의 진부분집합 ⇔ 𝑨⊆𝑩, 𝑩⊄𝑨 ⇔ 𝑨⊆𝑩, 𝑨≠𝑩
  - **상동(equal)**
    - 𝑨=𝑩 ⇔ 𝑨⊆𝑩 𝒂𝒏𝒅 𝑩⊆𝑨
  - 공집합(∅)은 모든 집합의 부분집합
- **서로소(disjoint)**
  - 교집합이 공집합(𝑨∩𝑩=∅)일 때 서로소
  - **쌍으로 서로소(pairwise disjoint)**
    - 𝒏개의 집합 𝑨_𝟏, 𝑨_𝟐, ⋯, 𝑨_𝒏이 쌍으로 서로소라는 것은 𝒏개의 집합 중 교집합이 하나도 없는 경우
    - 𝑨_𝒊∩𝑨_𝒋=∅ (𝒊≠𝒋, 𝟏≤𝒊, 𝒋≤𝒏) ⇔ ∩_{𝒊∈𝜤}𝑨_𝒊=∅
- **분할(partition)**
  - 집합 𝑨를 **∅이 아닌 부분집합들로 나눌 때, 𝑨의 모든 원소들이 각각 나누어진 부분집합들 중 하나에만 포함**될 경우 이 부분집합들 전체의 집합을 **𝑨의 분할**이라고 함
    - 즉, 집합 𝑨를 𝑨_𝟏, ⋯, 𝑨_𝒏의 𝒏개의 집합으로 나누었을 때, 아래 조건을 만족하는 {𝑨_𝟏, ⋯, 𝑨_𝒏}이 𝑨의 분할이 됨
      1. 𝒏개의 집합의 합집합은 𝑨
      2. 𝑨_𝟏, ⋯, 𝑨_𝒏은 쌍으로 서로소
      3. 𝑨의 분할은 ∅은 포함하지 않음
  - 집합 𝑷={𝑨_𝟏, 𝑨_𝟐, ⋯, 𝑨_𝒏}이 집합 𝑨의 분할  
    ![image](https://user-images.githubusercontent.com/61646760/221398962-41468784-c341-45d3-861d-e12163f6bd7f.png)
  - 예제
    - `예) 𝑨={1, 2, 3}에 대해 𝑨의 분할이 아닌 사례는?`
      - `{∅, {1, 2}, {3}}` : ∅이 포함됨
      - `{{1, 2}, {2, 3}}` : 교집합이 있음
      - `{{1}, {2}}` : 합집합이 𝑨가 아님
    - `예) ℤ가 모든 정수의 집합일 때, ℤ_𝟎 = {𝒛｜𝒛=𝟐𝒌, 𝒌는 정수}, ℤ_𝟏 = {𝒛｜𝒛=𝟐𝒌+𝟏, 𝒌는 정수}라면, {ℤ_𝟎, ℤ_𝟏}은 ℤ의 분할인가?`
      - `ℤ_𝟎∪ℤ_𝟏 = ℤ`이고 `ℤ_𝟎∩ℤ_𝟏 = ∅`이므로 ℤ의 분할
  - **자명한 분할(trivial partition)**
    - 𝑨≠∅ ⟹ 𝑷={𝑨}
      - 𝑷는 trivial partition
    - `예) 𝑨={1, 2, 3} ⟹ 𝑷={{1, 2, 3}}`
- **멱집합(power set)**
  - 집합 𝑨의 모든 부분집합들의 집합을 𝑨의 멱집합이라고 함
    - 𝑷(𝑨)로 표기
  - 멱집합의 원소 수
    - ｜𝑺｜=𝒏이면 ｜𝑷(𝑺)｜=2^𝒏
  - `예) 집합 𝑺={a, b, c}일 때, 𝑺의 멱집합 𝑷(𝑺)를 구하시오.`
    - `{∅, {a}, {b}, {c}, {a, b}, {a, c}, {b, c}, {a, b, c}}`
    - 참고 : 집합 𝑺의 크기가 3이므로 𝑷(𝑺)의 크기는 2^3 = 8
### 4.2 집합 연산
- 𝑼: 전체집합, 𝑨⊂𝑼, 𝑩⊂𝑼라 할 때
  - **합집합** : 𝑨∪𝑩 = {𝒙∈𝑼｜𝒙∈𝑨∨𝒙∈𝑩}
  - **교집합** : 𝑨∩𝑩 = {𝒙∈𝑼｜𝒙∈𝑨∧𝒙∈𝑩}
  - **차집합** : 𝑨−𝑩 = {𝒙∈𝑼｜𝒙∈𝑨∧𝒙∉𝑩}
  - **여집합** : 𝑨^𝒄 = 𝑼−𝑨 = {𝒙∈𝑼｜𝒙∉𝑨}
  - **대칭차집합** : 𝑨⨁𝑩 = {𝒙∈𝑼｜𝒙∈𝑨∪𝑩 ∧ 𝒙∉𝑨∩𝑩}  
    ![image](https://user-images.githubusercontent.com/61646760/221400412-fa025311-7634-4512-981a-4e96e0134a3f.png)
  - `예) 𝑨 = {𝟏,𝟐,𝟑}, 𝑩 = {𝟐,𝟑,𝟒}일 때 𝑨⨁𝑩를 구하시오.`
    - `𝑨⨁𝑩 = {𝟏,𝟒}`
- **곱집합(Cartesian product)**
  - 𝑼를 전체집합, 𝑨⊂𝑼, 𝑩⊂𝑼라 할 때, 𝑨의 원소 𝒂와 𝑩의 원소 𝒃로 만들어지는 순서쌍(ordered pair)인 (𝒂,𝒃)들의 집합을 𝑨와 𝑩의 곱집합이라고 함
    - 𝑨×𝑩 = {(𝒂,𝒃)｜𝒂∈𝑨, 𝒃∈𝑩}
      - 첫 번째 성분 𝒂는 𝑨에서, 두 번째 성분 𝒃는 𝑩에서 와야 함
  - 데카르트에서 따옴(cartesian)
  - 6강 관계에서 다시 나옴
### 4.3 집합의 대수 법칙
#### 4.3.1 집합의 크기에 관한 성질
- 정리) 합집합의 크기
  - 집합 A, B 가 유한집합이면 다음이 성립한다.
    - ｜𝑨∪𝑩｜=｜𝑨｜+｜𝑩｜−｜𝑨∩𝑩｜
  - 따름정리
    - 집합 𝑨, 𝑩, 𝑪가 유한집합이면 ｜𝑨∪𝑩∪𝑪｜=｜𝑨｜+｜𝑩｜+｜𝑪｜−｜𝑨∩𝑩｜−｜𝑨∩𝑪｜−｜𝑩∩𝑪｜+｜𝑨∩𝑩∩𝑪｜
- 정리) 서로소인 집합의 합집합의 크기
  - 집합 𝑨, 𝑩가 유한집합이면서 서로소이면 ｜𝑨∪𝑩｜=｜𝑨｜+｜𝑩｜이다.
#### 4.3.2 포함관계 및 항등식
- 정리) 교집합, 합집합, 포함관계의 이행성
  - 모든 집합 𝑨, 𝑩, 𝑪에 대해서 다음을 만족한다.
    - 교집합
      - (𝑨∩𝑩)⊆𝑨
      - (𝑨∩𝑩)⊆𝑩
    - 합집합
      - 𝑨⊆(𝑨∪𝑩)
      - 𝑩⊆(𝑨∪𝑩)
    - 이행성
      - 만약 𝑨⊆𝑩이고 𝑩⊆𝑪이면, 𝑨⊆𝑪이다.
- 원소 논증
  - 집합 𝑿, 𝒀에 대해 𝑿⊆𝒀를 증명하고자 할 때 ∀𝒙∈𝑿 → 𝒙∈𝒀임을 보인다.
  - `예) 𝑨∩𝑩⊆𝑩의 증명`
    - `𝒙∈𝑨∩𝑩 → 𝒙∈𝑨∧𝒙∈𝑩 → 𝒙∈𝑩`
- 정리) 집합의 항등식
  - 𝑼: 전체집합 , 𝑨, 𝑩, 𝑪⊂𝑼라 하자.
    - 교환법칙 : `𝑨∪𝑩 = 𝑩∪𝑨`, `𝑨∩𝑩 = 𝑩∩𝑨`
    - 결합법칙 : `(𝑨∪𝑩)∪𝑪 = 𝑨∪(𝑩∪𝑪)`, `(𝑨∩𝑩)∩𝑪 = 𝑨∩(𝑩∩𝑪)`
    - 분배법칙 : `𝑨∪(𝑩∩𝑪) = (𝑨∪𝑩)∩(𝑨∪𝑪)`, `𝑨∩(𝑩∪𝑪) = (𝑨∩𝑩)∪(𝑨∩𝑪)`
    - 항등법칙 : `𝑨∪∅ = 𝑨`, `𝑨∩𝑼 = 𝑨`
    - 보수법칙 : `𝑨∪𝑨^𝒄 = 𝑼`, `𝑨∩𝑨^𝒄 = ∅`
    - 이중보수법칙 : `(𝑨^𝒄)^𝒄 = 𝑨`
    - 멱등법칙 : `𝑨∪𝑨 = 𝑨`, `𝑨∩𝑨 = 𝑨`
    - 전체한계법칙 : `𝑨∪𝑼 = 𝑼`, `𝑨∩∅ = ∅`
    - 드모르간의 법칙 : `(𝑨∪𝑩)^𝒄 = 𝑨^𝒄∩𝑩^𝒄`, `(𝑨∩𝑩)^𝒄=𝑨^𝒄∪𝑩^𝒄`
    - 흡수법칙 : `𝑨∪(𝑨∩𝑩) = 𝑨`, `𝑨∩(𝑨∪𝑩) = 𝑨`
    - 𝑼와 ∅의 여집합 : `𝑼^𝒄=∅`, `∅^𝒄=𝑼`
    - 차집합법칙 : `𝑨−𝑩 = 𝑨∩𝑩^𝒄`
  - [논리적 동치](#논리적-동치) 부분 참고
- 정리) 포함관계에 대한 동치  
  ![image](https://user-images.githubusercontent.com/61646760/221401981-b76239e8-58a5-4558-ab29-e12a519ad657.png)
  - 𝑼: 전체집합 , 𝑨, 𝑩⊂𝑼라 할 때, 다음은 모두 동치이다.
    1. 𝑨⊆𝑩
    2. 𝑩^𝒄⊆𝑨^𝒄
    3. 𝑨∪𝑩 = 𝑩
    4. 𝑨∩𝑩 = 𝑨
    5. 𝑨^𝒄∪𝑩 = 𝑼
    6. 𝑨∩𝑩^𝒄 = ∅
    7. 𝑨−𝑩 = ∅

## 5강. 행렬
### 5.1 기본사항
- **행렬(matrix)**
  - 행과 열로 구성되는 사각형 형태로 수를 배열한 것  
    ![image](https://user-images.githubusercontent.com/61646760/223025284-1cf58a39-aebd-46eb-93e8-94933843f81c.png)
    - **𝒎×𝒏 행렬** : 𝒎,𝒏이 양의 정수일 때, 𝒎개의 행과 𝒏개의 열로 구성된 직사각형의 수 배열 𝑨를 𝒎×𝒏 행렬이라 한다.
      - **𝒂_(𝒊𝒋)** : 행렬 𝑨에서 𝒊번째 행의 𝒋번째 열의 수를 행렬 𝑨의 (𝒊,𝒋) 원소라 하며 𝒂_(𝒊𝒋)로 표기함
      - **𝑨=(𝒂_(𝒊𝒋))** : 행렬 𝑨를 간단히 𝑨=(𝒂_(𝒊𝒋))로 표기하기도 함
    - **행벡터(row vector)** : 𝟏×𝒏행렬
    - **열벡터(column vector)** : 𝒎×𝟏행렬
  - 컴퓨터 분야의 활용
    - 프로그래밍 언어, 자료구조, 컴퓨터 그래픽스, 패턴인식, 로봇동작, 인공지능 등
- 영행렬(zero matrix)**
  - 모든 원소가 0인 행렬  
    ![image](https://user-images.githubusercontent.com/61646760/223028082-5c4a2540-11ca-46ae-8aec-f41b5a0e8c76.png)
### 5.2 행렬의 연산
#### 5.2.1 기본연산
- 행렬의 합, 차, 스칼라 곱
  - 크기가 같은 행렬 𝑨, 𝑩가 있고, 𝒌를 실수라 할 때,
    - 𝑨+𝑩 : 같은 위치의 𝑨와 𝑩의 원소를 더해서 구해지는 행렬로서 (𝒊,𝒋) 원소의 값은 '**𝒂_(𝒊𝒋)+𝒃_(𝒊𝒋)**'이다.
    - 𝑨−𝑩 : 같은 위치의 𝑨의 원소로부터 𝑩의 원소를 빼서 구해지는 행렬로서 (𝒊,𝒋) 원소의 값은 '**𝒂𝒊𝒋−𝒃𝒊𝒋**'이다.
    - 𝒌𝑨 : 𝑨의 각 원소에 𝒌를 곱해서 구해지는 행렬로서 (𝒊,𝒋) 원소의 값은 '**𝒌𝒂_(𝒊𝒋)**'이다.
- 정리) 행렬의 합과 스칼라 곱의 연산법칙
  - 행렬의 합과 스칼라 곱은 같은 크기의 행렬 𝑨, 𝑩, 𝑪에 대해 다음과 같은 연산법칙들을 만족한다. (𝒂, 𝒃는 실수이고 𝑶은 모든 원소가 0인 영행렬을 의미한다.)
    1. 𝑨+𝑩 = 𝑩+𝑨 : 합의 교환법칙
    2. 𝑨+𝑩+𝑪 = 𝑨+𝑩+𝑪 : 합의 결합법칙
    3. 𝑨+𝑶 = 𝑨 : 합의 항등원
    4. 𝑨+(−𝑨) = 𝑶 : 합의 역원
    5. (𝒂𝒃)𝑨 = 𝒂(𝒃𝑨) : 스칼라 곱의 결합법칙
    6. (𝒂+𝒃)𝑨 = 𝒂𝑨+𝒃𝑨 : 스칼라 곱의 분배법칙
    7. (𝒂−𝒃)𝑨 = 𝒂𝑨−𝒃𝑨 : 스칼라 곱의 분배법칙
    8. 𝒂(𝑨+𝑩) = 𝒂𝑨+𝒂𝑩 : 스칼라 곱의 분배법칙
    9. 𝒂(𝑨−𝑩) = 𝒂𝑨−𝒂𝑩 : 스칼라 곱의 분배법칙
- 행렬의 곱
  - 𝑨가 **𝒎×𝒏** 행렬이고 𝑩가 **𝒏×𝒍** 행렬일 때, 행렬의 곱 𝑨𝑩는 (𝒊,𝒋) 원소가 다음과 같이 정의되는 **𝒎×𝒍** 행렬이다.  
    ![image](https://user-images.githubusercontent.com/61646760/223029869-a9f13060-8788-4f32-85b8-645a3155886b.png)  
    ![image](https://user-images.githubusercontent.com/61646760/223030136-c382f525-d2cc-4955-bdd8-4b9d427351ed.png)
    - **𝒄_(𝒊𝒋)는 𝑨의 행벡터와 𝑩의 열벡터의 내적**이 됨 (𝒎×𝒏, 𝒏×𝒍이어야 행렬의 곱이 가능한 이유)
  - 벡터의 **내적(inner product = dot product)**
    - 𝑨·𝑩로 표기함
    - 𝑨=(𝒂_1, 𝒂_2, ⋯, 𝒂_𝒏)와 𝑩=(𝒃_1, 𝒃_2, ⋯, 𝒃_𝒏)가 𝒏차원 벡터라고 할 때, 𝑨와 𝑩의 내적(inner product) 𝑨·𝑩는 다음과 같이 정의함
      - **𝑨·𝑩 = 𝒂_1𝒃_1 + 𝒂_2𝒃_2 + ⋯, 𝒂_𝒏𝒃_𝒏)**
    - `예) 𝑨=(1, 2, 3), 𝑩=(-1, 0, 2)일 때 𝑨·𝑩는?`
      - -1 + 0 + 6 = 5
- 행렬 곱의 연산법칙
  - 행렬 𝑨, 𝑩, 𝑪가 각 연산에 적합한 크기의 행렬이라 할 때, 다음과 같은 연산법칙들을 만족한다.
    1. 𝑨(𝑩𝑪) = (𝑨𝑩)𝑪 : 곱의 결합법칙
    2. 𝑨(𝑩+𝑪) = 𝑨𝑩+𝑨𝑪 : 곱의 분배법칙
    3. (𝑨+𝑩)𝑪 = 𝑨𝑪+𝑩𝑪 : 곱의 분배법칙
  - 교환법칙? 항등원, 역원?
    - 항등원은 단위행렬, 역원은 역행렬
    - 행렬의 곱은 **교환법칙이 성립하지 않음**
      - `예) 행렬 𝑨, 𝑩가 다음과 같을 때, 𝑨𝑩와 𝑩𝑨를 계산하시오.`  
        ![image](https://user-images.githubusercontent.com/61646760/223034023-81bbb03a-1c37-4a59-96af-519b0fda3e6e.png)
        - 정답  
          ![image](https://user-images.githubusercontent.com/61646760/223034125-9a5abfb8-7d46-40a3-aeed-0208a80d1ef2.png)
  - 행렬 곱의 특이 성질
    1. 𝑨𝑩≠𝑩𝑨 : 교환법칙이 성립하지 않음
    2. 행렬의 거듭제곱 (𝑨가 정방행렬) : 𝑨^𝒓𝑨^𝒔 = 𝑨^(𝒓+𝒔), (𝑨^𝒓)^𝒔 = 𝑨^(𝒓𝒔)
    3. ∃𝑨≠𝑶, ∃𝑩≠𝑶 ⇒ 𝑨𝑩=𝑶 : 행렬 𝑨, 𝑩가 영집합이 아니지만 곱한 결과 영집합이 나올 수 있음
#### 5.2.2 가우스 소거법
- **가우스 소거법(Gaussian elimination)**
  - 연립일차방정식을 풀이하는 알고리즘
    - 미지수가 𝒏개인 연립일차방정식을 나타내는 행렬에 기본 행 연산(Elementary Row Operation)을 적용하여 행 사다리꼴 행렬(Row Echelon Matrix)로 만들어 해를 구하는 방법  
      ![image](https://user-images.githubusercontent.com/61646760/223035562-7eefdb08-f45f-42e1-a5d8-7e7ce18d9251.png)
      - 연립일차방정식을 행렬방정식 𝑨𝑿=𝑩로 나타낼 수 있음
      - 만일 𝑨의 역행렬 𝑨^(−𝟏)이 존재한다면 𝑨𝑿=𝑩의 양변에 𝑨^(−𝟏)를 곱하면 𝑨^(−𝟏)𝑨𝑿 = 𝑰𝑿 = 𝑿 = 𝑨^(−𝟏)𝑩와 같이 방정식의 해를 구할 수 있음
- **기본 행 연산(elementary row operation)**
  - **행 교환(row interchange)** 연산
    - 𝑹_(𝒊,𝒋)
    - 두 행의 위치를 서로 바꾸는 연산
  - **행 스케일링(row scaling)** 연산
    - 𝑹_𝒊(𝒄)
    - 하나의 행에 0이 아닌 스칼라를 곱하는 연산
  - **행 대체(row replacement)** 연산
    - 𝑹_(𝒊,𝒋)(𝒄)
    - 하나의 행에 스칼라 곱을 해서 다른 행에 더하는 연산
- **가우스-조르단 소거법(Gauss-Jordan elimination)**  
  ![image](https://user-images.githubusercontent.com/61646760/223038020-6bfb7060-0e5b-49d2-b3b8-30035d9725f7.png)
  - 가우스 소거법 : 행제형 행렬까지 구해서 푸는 방법
  - 가우스-조르단 소거법 : 소거 행제형 행렬까지 구해서 푸는 방법
- **행제형 행렬 = 행사다리꼴 행렬(row echelon matrix)**
  - 다음 세 가지 조건을 만족하는 행렬을 행사다리꼴(행제형)이라고 한다.
    1. **영행이 아닌 행은 영행의 위**에 있다.
    2. 영행이 아닌 행의 첫 번째 0이 아닌 원소를 그 행의 '**선도원소(leading element)**'라 하는데, **모든 선도원소는 1**이다.
    3. 주어진 **행의 선도원소는 그 아래 행의 선도원소보다 왼쪽**에 있다.
- **소거행제형 행렬 = 기약 행사다리꼴 행렬(reduced row echelon matrix)**
  - 다음 조건을 만족하는 행제형 행렬을 소거행제형 행렬이라고 한다.
    - **선도원소가 포함된 열**에서 **선도원소를 제외한 모든 원소는 0**이다.
#### 5.2.3 가우스 소거법 예제
- `예) 다음 일차연립방정식의 해를 구하시오.`  
  ```
  𝒙_𝟐+𝟓𝒙_𝟑 = 𝟐
  𝒙_𝟏−𝟑𝒙_𝟑 = −𝟐
  𝟐𝒙_𝟏+𝟐𝒙_𝟐+𝟗𝒙_𝟑 = 𝟏
  ```
- 풀이  
  ![image](https://user-images.githubusercontent.com/61646760/223041094-e0e2abac-45c0-4b5b-acc2-dec0c12810da.png)
  - 𝒙_𝟏= −𝟏.𝟒
  - 𝒙_𝟐 = 𝟏
  - 𝒙_𝟑 = 𝟎.𝟐
### 5.3 행렬의 종류
- **정방행렬(square matrix)**
  - 𝒏×𝒏 행렬을 **𝒏차 정방행렬**이라고 하며, 𝒏을 정방행렬의 **차수**라 함
  - 𝒏차 정방행렬은 다음과 같은 형태를 가짐  
    ![image](https://user-images.githubusercontent.com/61646760/223041419-5d9d191d-17fb-4f67-9f88-f15e1d2def28.png)
  - **대각원소(diagonal element)** : 정방행렬의 𝒂_𝟏𝟏, 𝒂_𝟐𝟐, ⋯, 𝒂_(𝒏𝒏) 원소
  - **주대각선(main diagonal)** : 대각원소를 포함하는 대각선
- **대각행렬(diagonal matrix)**
  - 𝒏차 정방행렬에서 대각원소 이외의 모든 원소가 0인 행렬을 대각행렬이라 함  
    ![image](https://user-images.githubusercontent.com/61646760/223041970-36c6574e-7ef5-4b22-bcb7-36184ea6304e.png)
    - 즉, 𝒊≠𝒋이면 𝒂_(𝒊𝒋)=𝟎
- **단위행렬(unit matrix)**
  - 𝒏차 정방행렬에서 대각원소가 모두 1이고 나머지 원소는 모두 0인 행렬을 단위행렬이라 함
  - **𝑰_𝒏**으로 표기  
    ![image](https://user-images.githubusercontent.com/61646760/223042533-eeadf01a-87a0-4cb1-8818-0b8af58ae334.png)
    - 즉, 𝒊=𝒋이면 𝒂_(𝒊𝒋)=𝟏이고, 𝒊≠𝒋이면 𝒂_(𝒊𝒋)=𝟎이다.
- **대칭행렬(symmetric matrix)**
  - 𝒏차 정방행렬에서 𝒂_(𝒊𝒋)=𝒂_(𝒋𝒊)인 행렬을 대칭행렬이라 함  
    ![image](https://user-images.githubusercontent.com/61646760/223042711-1c1146e0-9111-4028-992d-805d6ab5cee2.png)
- **역대칭행렬(skew symmetric matrix)**
  - 𝒏차 정방행렬에서 𝒂_(𝒊𝒋)=−𝒂_(𝒋𝒊)이고 대각원소가 모두 0인 행렬을 역대칭행렬[교대행렬]이라 함  
    ![image](https://user-images.githubusercontent.com/61646760/223042916-1da8f14c-c313-40b5-9463-3dea399610d6.png)
    - 즉, 𝒊=𝒋이면 𝒂_(𝒊𝒋)=𝟎이고 , 𝒊≠𝒋이면 𝒂_(𝒊𝒋)=−𝒂_(𝒋𝒊)이다.
- **삼각행렬(triangular matrix)**
  - 𝒏차 정방행렬에서
    - **상삼각행렬** : 주대각선 아래에 있는 모든 원소들이 0일 경우 (𝒊>𝒋일 때, 𝒂_(𝒊𝒋)=0)  
      ![image](https://user-images.githubusercontent.com/61646760/223043283-993e5ee1-f546-421a-891e-74c931eb15d9.png)
    - **하삼각행렬** : 주대각선 위에 있는 모든 원소들이 0일 경우 (𝒊<𝒋일 때, 𝒂_(𝒊𝒋)=0)  
      ![image](https://user-images.githubusercontent.com/61646760/223043338-52886173-025d-434a-8ec3-2e1caa056d1f.png)
    - **삼각행렬** : 상삼각행렬 또는 하삼각행렬
- **전치행렬(transpose matrix)**
  - 𝒎×𝒏행렬 𝑨가 주어졌을 때, 𝑨의 행과 열을 서로 교환한 행렬을 𝑨의 전치행렬이라고 함
  - 𝑨^𝑻로 표기
  - 𝑨^𝑻의 크기는 𝒏×𝒎  
    ![image](https://user-images.githubusercontent.com/61646760/223043874-4d998c4b-7dd0-4ccd-b278-09b209fd5c40.png)
- **역행렬(inverse matrix)**
  - 𝒏차 정방행렬 𝑨, 𝑩가 주어졌을 때, 𝑨𝑩=𝑩𝑨=𝑰_𝒏인 행렬 𝑩가 존재하는 경우 행렬 𝑨를 역가능(invertible)하다고 함
  - 이때, 행렬 𝑩를 행렬 **𝑨의 역행렬**이라고 하고 **𝑨^(−𝟏)**로 표기함
### 5.4 부울행렬
- **부울행렬(boolean matrix)**
  - 행렬의 모든 원소가 부울값(0 or 1)으로만 구성된 행렬
- 부울행렬의 합, 교차, 부울곱
  - 크기가 𝒎×𝒏인 두 행렬 𝑨=[𝒂_𝒊𝒋] 와 𝑩=[𝒃_𝒊𝒋]가 부울행렬일 때,
    - 𝑨와 𝑩의 합(join)
      - (𝒊,𝒋) 원소가 **𝒂_(𝒊𝒋)∨𝒃_(𝒊𝒋)이고 크기가 𝒎×𝒏인 부울행렬 𝑪
      - **𝑪=𝑨∨𝑩**로 나타냄
    - 𝑨와 𝑩의 교차(meet)
      - (𝒊,𝒋) 원소가 **𝒂_(𝒊𝒋)∧𝒃_(𝒊𝒋)**이고 크기가 𝒎×𝒏인 부울행렬 𝑪
      - **𝑪=𝑨∧𝑩**로 나타냄
    - 𝑨와 𝑩의 부울곱(boolean product)
      - (𝒊,𝒋) 원소가 다음과 같이 정의되는 𝒎×𝒍 크기의 부울행렬 𝑪
        - 𝒄_𝒊𝒋 = (𝒂_(𝒊𝟏)∧𝒃_(𝟏𝒋))∨(𝒂_(𝒊𝟐)∧𝒃_(𝟐𝒋))∨ ⋯ ∨(𝒂_(𝒊𝒏)∧𝒃_(𝒏𝒋))
      - **𝑪=𝑨⨀𝑩**로 나타낸다
## 6강. 관계
### 6.1 기본사항
- **곱집합(Cartesian Product)**
  - 집합 𝑨와 𝑩의 곱집합(Cartesian Product) 𝑨×𝑩는 𝑨의 원소와 𝑩의 원소의 모든 순서쌍(ordered pair)들의 집합
    - 즉, 𝑨×𝑩 = {(𝒂,𝒃)｜𝒂∈𝑨, 𝒃∈𝑩}
  - 갑자기 웬 곱집합?
    - 관계란 **집합 𝑨와 𝑩의 곱집합의 부분집합**으로 정의됨
- **(이항)관계(relation)**
  - 집합 𝑿에서 집합 𝒀로의 (이항)관계((binary) relation) **𝑹은 𝑿×𝒀의 부분집합**
    - 관계 𝑹은 집합
  - **(𝒙,𝒚)∈𝑹**
    - "𝒙는 𝒚와 𝑹의 관계가 있다."라는 의미
    - **𝒙𝑹𝒚**로 표기
      - 관계가 없으면 𝒙𝑹_(bar)𝒚로 표기
  - 𝑿=𝒀이면 𝑹을 **𝑿에서의 관계**라고 함
    - 𝑿에서 𝑿로의 관계이기 때문
  - `예) 아래의 경우, 수강관계 𝑹은?`
    - 학생집합 𝑿 = {민수, 영수, 영이, 소담}
    - 과목집합 𝒀 = {C언어, 알고리즘, 그래픽스, 네트워크}
    - 정답
      - 𝑿×𝒀는 4*4로 16개이나, 관계 𝑹은 그중 일부분
      - 수강관계 𝑹 = {(민수,C언어), (민수,알고리즘), (민수,그래픽스), (영수,알고리즘), (영수,네트워크), (영이,알고리즘), (영이,그래픽스), (소담,C언어), (소담,그래픽스), (소담,네트워크)}
### 6.2 관계의 표현
- 화살표 도표, 방향 그래프, 부울행렬을 활용해 관계를 표현할 수 있음
- **화살표 도표**
  - 𝑿에서 𝒀로의 관계 𝑹 (𝒙∈𝑿,𝒚∈𝒀, (𝒙,𝒚)∈𝑹)  
    ![image](https://user-images.githubusercontent.com/61646760/222919016-d7ac1283-5640-44f5-9f04-bb0217e82334.png)
    - 관계 있는 원소(𝒙,𝒚)만 화살표로 연결
- **방향 그래프**
  - **그래프(graph)**
    - 점=꼭지점(vertex)과 선=변(edge)으로 이루어진 도형
      - [9강](#9강-그래프) 참고
    - G = (V, E)  
      ![image](https://user-images.githubusercontent.com/61646760/222920321-eb2df02e-13eb-4d8b-90ed-0226add1680f.png)
  - **방향 그래프(directed graph)**
    - G = (V, E)에서 변이
    - 방향을 가지면 G는 방향 그래프, 방향을 가지지 않으면 G는 무향 그래프(undirected graph)  
      ![image](https://user-images.githubusercontent.com/61646760/222920328-befb62d1-b63b-480a-8f8c-8926860063b1.png)
  - **𝑿에서의** 관계 𝑹 (𝒙,𝒚∈𝑿, (𝒙,𝒚)∈𝑹)  
    ![image](https://user-images.githubusercontent.com/61646760/222920598-277957ee-8678-4873-a00f-d65b45bf4f78.png)
  - `예) 관계 T를 방향 그래프로 나타내시오.`
    - 𝑨 = {𝟏,𝟐,𝟑}
    - 𝑻 = {(𝟏,𝟏), (𝟏,𝟐), (𝟐,𝟏), (𝟐,𝟐), (𝟑,𝟏), (𝟑,𝟐)}
    - 정답  
      ![image](https://user-images.githubusercontent.com/61646760/222920731-904c24ef-5447-4809-be3d-95f102b5f5ad.png)
      - 위상만(연결성만) 같으면 같은 구조
- **부울행렬**
  - 𝑿 = {𝒙_𝟏, 𝒙_𝟐, ⋯, 𝒙_𝒎}, 𝒀 = {𝒚_𝟏, 𝒚_𝟐, ⋯, 𝒚_𝒏}
    - (𝒙_𝒊,𝒚_𝒋)∈𝑹 ⇔ 𝒎×𝒏 부울행렬 𝑴_𝑹 = (𝒂_{𝒊𝒋})  
      ![image](https://user-images.githubusercontent.com/61646760/224698530-dee45c58-79a7-4587-a353-0e2892d776b6.png)
  - `예) 관계 T를 부울행렬로 나타내시오.`
    - 𝑨 = {𝟏, 𝟐, 𝟑}, 𝑻 = {(𝟏, 𝟏), (𝟏, 𝟐), (𝟐, 𝟏), (𝟐, 𝟐), (𝟑, 𝟏), (𝟑, 𝟐)}
    - 정답  
      ![image](https://user-images.githubusercontent.com/61646760/224698969-953ae5bb-fbca-43cb-bb94-000a31dc9964.png)
### 6.3 관계의 성질
- 관계의 성질
  - 집합 A 에서의 관계 R이
    - **반사적(reflexive)**
      - ∀𝒂∈𝑨, (𝒂,𝒂)∈𝑹  
        ![image](https://user-images.githubusercontent.com/61646760/224700276-eccdfd05-08c1-48c4-802b-beb95a6a4b59.png)
    - **대칭적(symmetric)**
      - ∀𝒂,𝒃∈𝑨, 𝒂,𝒃∈𝑹 ⇒ (𝒃,𝒂)∈𝑹  
        ![image](https://user-images.githubusercontent.com/61646760/224700347-e8bef534-35f5-4ffc-8f9f-9269018540e3.png)
        - 𝑴_𝑹이 대칭행렬 (즉, 𝑴_𝑹=𝑴_{𝑹}^{𝑻})
    - **추이적(transitive)**
      - ∀𝒂,𝒃,𝒄∈𝑨, ((𝒂,𝒃)∈𝑹 ∧ (𝒃,𝒄)∈𝑹) ⇒ (𝒂,𝒄)∈𝑹  
        ![image](https://user-images.githubusercontent.com/61646760/224700551-a8b443fa-696b-49d8-978b-3dd3d1bb2bb0.png)
      - 관계 𝑹이 추이적이 되기 위해서는 다음을 만족해야 한다.
        - 𝑹_1, 𝑹_2, ⋯, 𝑹_𝒌, ⋯⊂𝑹
          - 𝑹_𝒌 : 집합 A의 원소가 관계 R을 통해 𝒌번만에 도착할 수 있는 순서쌍의 집합
### 6.4 관계의 종류
- **역관계(inverse relation)**
  - 𝑿,𝒀∶ 집합, 𝑹∶ 𝑿에서 𝒀로의 관계
    - **𝑹^{−𝟏}** ∶ 𝑹의 역관계
  - 𝑹^{−𝟏} = {(𝒚,𝒙)｜(𝒙,𝒚)∈𝑹} ⊂ 𝒀×𝑿
- **합성관계(composition relation)**
  - 𝑨,𝑩,𝑪∶ 집합, 𝑹∶ 𝑨에서 𝑩로의 관계, 𝑺∶ 𝑩에서 𝑪로의 관계
    - 𝑺∘𝑹 = {(𝒂,𝒄)｜𝒂∈𝑨, 𝒃∈𝑩, 𝒄∈𝑪, (𝒂,𝒃)∈𝑹, (𝒃,𝒄)∈𝑺} : 𝑹과 𝐒의 합성관계
  - 𝑺∘𝑹 ⊂ 𝑨×𝑪 (𝑨에서 𝑪로의 관계)
- **동치관계(equivalence relation)**
  - 𝑹∶ 집합 𝑨에서 관계
    - **𝑹이 반사적, 대칭적, 추이적이면 𝑹을 동치관계**라고 부른다.
  - 나머지 함수
    - 하나의 식을 다른 값으로 나눈 뒤 나머지를 구하는 함수
    - `예) 8 mod 5 = 3, 13 mod 5 = 3`
  - **모듈러 합동(Modular congruent)**
    - 두 정수 𝒎과 𝒏에 대해 양의 정수 𝒅로 나머지 연산을 하였을 때, 같은 값이 나오는 경우 𝒎과 𝒏을 𝒅에 관한 모듈러 합동이라 함
      - `𝒎 ≡ 𝒏 (mod 𝒅)`
    - `예) 8 ≡ 13 (mod 5)`
      - 8과 13이 5에 관한 모듈러-5 합동
    - **모듈러 합동 관계는 항상 동치관계**이다.
      - 즉, 항상 반사적, 대칭적, 추이적
- **동치류(equivalence class)**
  - 𝑨∶ 집합, 𝑹∶ 𝑨에서의 동치관계
    - 𝑨의 임의의 원소 𝒂에 대해서 **[𝒂] = {𝒙∈𝑨｜(𝒂,𝒙)∈𝑹}를 𝒂의 동치류**라고 부른다.
